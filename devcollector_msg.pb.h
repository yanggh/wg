// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: devcollector_msg.proto

#ifndef PROTOBUF_devcollector_5fmsg_2eproto__INCLUDED
#define PROTOBUF_devcollector_5fmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "msg_common.pb.h"
// @@protoc_insertion_point(includes)

namespace protobuf_devcollector_5fmsg_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[63];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsSnmpBaseParaImpl();
void InitDefaultsSnmpBasePara();
void InitDefaultsSnmpExtParaImpl();
void InitDefaultsSnmpExtPara();
void InitDefaultsSnmpInfoImpl();
void InitDefaultsSnmpInfo();
void InitDefaultsTelnetParaImpl();
void InitDefaultsTelnetPara();
void InitDefaultsSshParaImpl();
void InitDefaultsSshPara();
void InitDefaultsPingParaImpl();
void InitDefaultsPingPara();
void InitDefaultsDbLoginParaImpl();
void InitDefaultsDbLoginPara();
void InitDefaultsNetDevBaseInfoImpl();
void InitDefaultsNetDevBaseInfo();
void InitDefaultsDiskInfoImpl();
void InitDefaultsDiskInfo();
void InitDefaultsPartitionInfoImpl();
void InitDefaultsPartitionInfo();
void InitDefaultsProcessorInfoImpl();
void InitDefaultsProcessorInfo();
void InitDefaultsHostBaseInfoImpl();
void InitDefaultsHostBaseInfo();
void InitDefaultsIfBaseInfoImpl();
void InitDefaultsIfBaseInfo();
void InitDefaultsIfResInfoImpl();
void InitDefaultsIfResInfo();
void InitDefaultsProcessInfoImpl();
void InitDefaultsProcessInfo();
void InitDefaultsSoftwareInfoImpl();
void InitDefaultsSoftwareInfo();
void InitDefaultsPerfParameterImpl();
void InitDefaultsPerfParameter();
void InitDefaultsMidwarePerfImpl();
void InitDefaultsMidwarePerf();
void InitDefaultsDatabasePerfImpl();
void InitDefaultsDatabasePerf();
void InitDefaultsIfPerfImpl();
void InitDefaultsIfPerf();
void InitDefaultsMsgTopoDiscoveryRespImpl();
void InitDefaultsMsgTopoDiscoveryResp();
void InitDefaultsDiscoveredDevImpl();
void InitDefaultsDiscoveredDev();
void InitDefaultsMsgTopoDiscoveryNotifyImpl();
void InitDefaultsMsgTopoDiscoveryNotify();
void InitDefaultsResSynInfoImpl();
void InitDefaultsResSynInfo();
void InitDefaultsRespAddrImpl();
void InitDefaultsRespAddr();
void InitDefaultsMsgResSynReqImpl();
void InitDefaultsMsgResSynReq();
void InitDefaultsMsgResSynRespImpl();
void InitDefaultsMsgResSynResp();
void InitDefaultsResSynResultImpl();
void InitDefaultsResSynResult();
void InitDefaultsMsgResSynNotifyImpl();
void InitDefaultsMsgResSynNotify();
void InitDefaultsMsgDevPerfCollectReqImpl();
void InitDefaultsMsgDevPerfCollectReq();
void InitDefaultsMsgDevPerfCollectRespImpl();
void InitDefaultsMsgDevPerfCollectResp();
void InitDefaultsMsgGetHostProcListReqImpl();
void InitDefaultsMsgGetHostProcListReq();
void InitDefaultsMsgGetHostProcListRespImpl();
void InitDefaultsMsgGetHostProcListResp();
void InitDefaultsMsgGetHostFileSystemListReqImpl();
void InitDefaultsMsgGetHostFileSystemListReq();
void InitDefaultsMsgGetHostFileSystemListRespImpl();
void InitDefaultsMsgGetHostFileSystemListResp();
void InitDefaultsDBResInfoImpl();
void InitDefaultsDBResInfo();
void InitDefaultsMsgDBPerfCollectReqImpl();
void InitDefaultsMsgDBPerfCollectReq();
void InitDefaultsMsgDBPerfCollectRespImpl();
void InitDefaultsMsgDBPerfCollectResp();
void InitDefaultsMidwareResInfoImpl();
void InitDefaultsMidwareResInfo();
void InitDefaultsMsgMidwarePerfCollectReqImpl();
void InitDefaultsMsgMidwarePerfCollectReq();
void InitDefaultsMsgMidwarePerfCollectRespImpl();
void InitDefaultsMsgMidwarePerfCollectResp();
void InitDefaultsDataSourceIdImpl();
void InitDefaultsDataSourceId();
void InitDefaultsMsgRoomResSyncReqImpl();
void InitDefaultsMsgRoomResSyncReq();
void InitDefaultsSensorImpl();
void InitDefaultsSensor();
void InitDefaultsDataSourceSyncResultImpl();
void InitDefaultsDataSourceSyncResult();
void InitDefaultsMsgMachineRoomResSyncRespImpl();
void InitDefaultsMsgMachineRoomResSyncResp();
void InitDefaultsMsgGetSenserValueReqImpl();
void InitDefaultsMsgGetSenserValueReq();
void InitDefaultsSenserValueImpl();
void InitDefaultsSenserValue();
void InitDefaultsSenserSyncResultImpl();
void InitDefaultsSenserSyncResult();
void InitDefaultsMsgGetSenserValueRespImpl();
void InitDefaultsMsgGetSenserValueResp();
void InitDefaultsConnectivityTestSynReqImpl();
void InitDefaultsConnectivityTestSynReq();
void InitDefaultsMsgConnectivityTestSynRespImpl();
void InitDefaultsMsgConnectivityTestSynResp();
void InitDefaultsMsgDevTestParaImpl();
void InitDefaultsMsgDevTestPara();
void InitDefaultsMsgReachableTestReqImpl();
void InitDefaultsMsgReachableTestReq();
void InitDefaultsMsgReachableTestRespImpl();
void InitDefaultsMsgReachableTestResp();
void InitDefaultsPingPerfImpl();
void InitDefaultsPingPerf();
void InitDefaultsReachableTestResultImpl();
void InitDefaultsReachableTestResult();
void InitDefaultsMsgReachableTestNotifyImpl();
void InitDefaultsMsgReachableTestNotify();
void InitDefaultsIpGroupImpl();
void InitDefaultsIpGroup();
void InitDefaultsMsgTopoDiscoveryReqImpl();
void InitDefaultsMsgTopoDiscoveryReq();
void InitDefaultsMsgTopoFindRespImpl();
void InitDefaultsMsgTopoFindResp();
void InitDefaultsTopoNodeInfoImpl();
void InitDefaultsTopoNodeInfo();
void InitDefaultsTopoLinkInfoImpl();
void InitDefaultsTopoLinkInfo();
inline void InitDefaults() {
  InitDefaultsSnmpBasePara();
  InitDefaultsSnmpExtPara();
  InitDefaultsSnmpInfo();
  InitDefaultsTelnetPara();
  InitDefaultsSshPara();
  InitDefaultsPingPara();
  InitDefaultsDbLoginPara();
  InitDefaultsNetDevBaseInfo();
  InitDefaultsDiskInfo();
  InitDefaultsPartitionInfo();
  InitDefaultsProcessorInfo();
  InitDefaultsHostBaseInfo();
  InitDefaultsIfBaseInfo();
  InitDefaultsIfResInfo();
  InitDefaultsProcessInfo();
  InitDefaultsSoftwareInfo();
  InitDefaultsPerfParameter();
  InitDefaultsMidwarePerf();
  InitDefaultsDatabasePerf();
  InitDefaultsIfPerf();
  InitDefaultsMsgTopoDiscoveryResp();
  InitDefaultsDiscoveredDev();
  InitDefaultsMsgTopoDiscoveryNotify();
  InitDefaultsResSynInfo();
  InitDefaultsRespAddr();
  InitDefaultsMsgResSynReq();
  InitDefaultsMsgResSynResp();
  InitDefaultsResSynResult();
  InitDefaultsMsgResSynNotify();
  InitDefaultsMsgDevPerfCollectReq();
  InitDefaultsMsgDevPerfCollectResp();
  InitDefaultsMsgGetHostProcListReq();
  InitDefaultsMsgGetHostProcListResp();
  InitDefaultsMsgGetHostFileSystemListReq();
  InitDefaultsMsgGetHostFileSystemListResp();
  InitDefaultsDBResInfo();
  InitDefaultsMsgDBPerfCollectReq();
  InitDefaultsMsgDBPerfCollectResp();
  InitDefaultsMidwareResInfo();
  InitDefaultsMsgMidwarePerfCollectReq();
  InitDefaultsMsgMidwarePerfCollectResp();
  InitDefaultsDataSourceId();
  InitDefaultsMsgRoomResSyncReq();
  InitDefaultsSensor();
  InitDefaultsDataSourceSyncResult();
  InitDefaultsMsgMachineRoomResSyncResp();
  InitDefaultsMsgGetSenserValueReq();
  InitDefaultsSenserValue();
  InitDefaultsSenserSyncResult();
  InitDefaultsMsgGetSenserValueResp();
  InitDefaultsConnectivityTestSynReq();
  InitDefaultsMsgConnectivityTestSynResp();
  InitDefaultsMsgDevTestPara();
  InitDefaultsMsgReachableTestReq();
  InitDefaultsMsgReachableTestResp();
  InitDefaultsPingPerf();
  InitDefaultsReachableTestResult();
  InitDefaultsMsgReachableTestNotify();
  InitDefaultsIpGroup();
  InitDefaultsMsgTopoDiscoveryReq();
  InitDefaultsMsgTopoFindResp();
  InitDefaultsTopoNodeInfo();
  InitDefaultsTopoLinkInfo();
}
}  // namespace protobuf_devcollector_5fmsg_2eproto
namespace mpfmessage {
class ConnectivityTestSynReq;
class ConnectivityTestSynReqDefaultTypeInternal;
extern ConnectivityTestSynReqDefaultTypeInternal _ConnectivityTestSynReq_default_instance_;
class DBResInfo;
class DBResInfoDefaultTypeInternal;
extern DBResInfoDefaultTypeInternal _DBResInfo_default_instance_;
class DataSourceId;
class DataSourceIdDefaultTypeInternal;
extern DataSourceIdDefaultTypeInternal _DataSourceId_default_instance_;
class DataSourceSyncResult;
class DataSourceSyncResultDefaultTypeInternal;
extern DataSourceSyncResultDefaultTypeInternal _DataSourceSyncResult_default_instance_;
class DatabasePerf;
class DatabasePerfDefaultTypeInternal;
extern DatabasePerfDefaultTypeInternal _DatabasePerf_default_instance_;
class DbLoginPara;
class DbLoginParaDefaultTypeInternal;
extern DbLoginParaDefaultTypeInternal _DbLoginPara_default_instance_;
class DiscoveredDev;
class DiscoveredDevDefaultTypeInternal;
extern DiscoveredDevDefaultTypeInternal _DiscoveredDev_default_instance_;
class DiskInfo;
class DiskInfoDefaultTypeInternal;
extern DiskInfoDefaultTypeInternal _DiskInfo_default_instance_;
class HostBaseInfo;
class HostBaseInfoDefaultTypeInternal;
extern HostBaseInfoDefaultTypeInternal _HostBaseInfo_default_instance_;
class IfBaseInfo;
class IfBaseInfoDefaultTypeInternal;
extern IfBaseInfoDefaultTypeInternal _IfBaseInfo_default_instance_;
class IfPerf;
class IfPerfDefaultTypeInternal;
extern IfPerfDefaultTypeInternal _IfPerf_default_instance_;
class IfResInfo;
class IfResInfoDefaultTypeInternal;
extern IfResInfoDefaultTypeInternal _IfResInfo_default_instance_;
class IpGroup;
class IpGroupDefaultTypeInternal;
extern IpGroupDefaultTypeInternal _IpGroup_default_instance_;
class MidwarePerf;
class MidwarePerfDefaultTypeInternal;
extern MidwarePerfDefaultTypeInternal _MidwarePerf_default_instance_;
class MidwareResInfo;
class MidwareResInfoDefaultTypeInternal;
extern MidwareResInfoDefaultTypeInternal _MidwareResInfo_default_instance_;
class MsgConnectivityTestSynResp;
class MsgConnectivityTestSynRespDefaultTypeInternal;
extern MsgConnectivityTestSynRespDefaultTypeInternal _MsgConnectivityTestSynResp_default_instance_;
class MsgDBPerfCollectReq;
class MsgDBPerfCollectReqDefaultTypeInternal;
extern MsgDBPerfCollectReqDefaultTypeInternal _MsgDBPerfCollectReq_default_instance_;
class MsgDBPerfCollectResp;
class MsgDBPerfCollectRespDefaultTypeInternal;
extern MsgDBPerfCollectRespDefaultTypeInternal _MsgDBPerfCollectResp_default_instance_;
class MsgDevPerfCollectReq;
class MsgDevPerfCollectReqDefaultTypeInternal;
extern MsgDevPerfCollectReqDefaultTypeInternal _MsgDevPerfCollectReq_default_instance_;
class MsgDevPerfCollectResp;
class MsgDevPerfCollectRespDefaultTypeInternal;
extern MsgDevPerfCollectRespDefaultTypeInternal _MsgDevPerfCollectResp_default_instance_;
class MsgDevTestPara;
class MsgDevTestParaDefaultTypeInternal;
extern MsgDevTestParaDefaultTypeInternal _MsgDevTestPara_default_instance_;
class MsgGetHostFileSystemListReq;
class MsgGetHostFileSystemListReqDefaultTypeInternal;
extern MsgGetHostFileSystemListReqDefaultTypeInternal _MsgGetHostFileSystemListReq_default_instance_;
class MsgGetHostFileSystemListResp;
class MsgGetHostFileSystemListRespDefaultTypeInternal;
extern MsgGetHostFileSystemListRespDefaultTypeInternal _MsgGetHostFileSystemListResp_default_instance_;
class MsgGetHostProcListReq;
class MsgGetHostProcListReqDefaultTypeInternal;
extern MsgGetHostProcListReqDefaultTypeInternal _MsgGetHostProcListReq_default_instance_;
class MsgGetHostProcListResp;
class MsgGetHostProcListRespDefaultTypeInternal;
extern MsgGetHostProcListRespDefaultTypeInternal _MsgGetHostProcListResp_default_instance_;
class MsgGetSenserValueReq;
class MsgGetSenserValueReqDefaultTypeInternal;
extern MsgGetSenserValueReqDefaultTypeInternal _MsgGetSenserValueReq_default_instance_;
class MsgGetSenserValueResp;
class MsgGetSenserValueRespDefaultTypeInternal;
extern MsgGetSenserValueRespDefaultTypeInternal _MsgGetSenserValueResp_default_instance_;
class MsgMachineRoomResSyncResp;
class MsgMachineRoomResSyncRespDefaultTypeInternal;
extern MsgMachineRoomResSyncRespDefaultTypeInternal _MsgMachineRoomResSyncResp_default_instance_;
class MsgMidwarePerfCollectReq;
class MsgMidwarePerfCollectReqDefaultTypeInternal;
extern MsgMidwarePerfCollectReqDefaultTypeInternal _MsgMidwarePerfCollectReq_default_instance_;
class MsgMidwarePerfCollectResp;
class MsgMidwarePerfCollectRespDefaultTypeInternal;
extern MsgMidwarePerfCollectRespDefaultTypeInternal _MsgMidwarePerfCollectResp_default_instance_;
class MsgReachableTestNotify;
class MsgReachableTestNotifyDefaultTypeInternal;
extern MsgReachableTestNotifyDefaultTypeInternal _MsgReachableTestNotify_default_instance_;
class MsgReachableTestReq;
class MsgReachableTestReqDefaultTypeInternal;
extern MsgReachableTestReqDefaultTypeInternal _MsgReachableTestReq_default_instance_;
class MsgReachableTestResp;
class MsgReachableTestRespDefaultTypeInternal;
extern MsgReachableTestRespDefaultTypeInternal _MsgReachableTestResp_default_instance_;
class MsgResSynNotify;
class MsgResSynNotifyDefaultTypeInternal;
extern MsgResSynNotifyDefaultTypeInternal _MsgResSynNotify_default_instance_;
class MsgResSynReq;
class MsgResSynReqDefaultTypeInternal;
extern MsgResSynReqDefaultTypeInternal _MsgResSynReq_default_instance_;
class MsgResSynResp;
class MsgResSynRespDefaultTypeInternal;
extern MsgResSynRespDefaultTypeInternal _MsgResSynResp_default_instance_;
class MsgRoomResSyncReq;
class MsgRoomResSyncReqDefaultTypeInternal;
extern MsgRoomResSyncReqDefaultTypeInternal _MsgRoomResSyncReq_default_instance_;
class MsgTopoDiscoveryNotify;
class MsgTopoDiscoveryNotifyDefaultTypeInternal;
extern MsgTopoDiscoveryNotifyDefaultTypeInternal _MsgTopoDiscoveryNotify_default_instance_;
class MsgTopoDiscoveryReq;
class MsgTopoDiscoveryReqDefaultTypeInternal;
extern MsgTopoDiscoveryReqDefaultTypeInternal _MsgTopoDiscoveryReq_default_instance_;
class MsgTopoDiscoveryResp;
class MsgTopoDiscoveryRespDefaultTypeInternal;
extern MsgTopoDiscoveryRespDefaultTypeInternal _MsgTopoDiscoveryResp_default_instance_;
class MsgTopoFindResp;
class MsgTopoFindRespDefaultTypeInternal;
extern MsgTopoFindRespDefaultTypeInternal _MsgTopoFindResp_default_instance_;
class NetDevBaseInfo;
class NetDevBaseInfoDefaultTypeInternal;
extern NetDevBaseInfoDefaultTypeInternal _NetDevBaseInfo_default_instance_;
class PartitionInfo;
class PartitionInfoDefaultTypeInternal;
extern PartitionInfoDefaultTypeInternal _PartitionInfo_default_instance_;
class PerfParameter;
class PerfParameterDefaultTypeInternal;
extern PerfParameterDefaultTypeInternal _PerfParameter_default_instance_;
class PingPara;
class PingParaDefaultTypeInternal;
extern PingParaDefaultTypeInternal _PingPara_default_instance_;
class PingPerf;
class PingPerfDefaultTypeInternal;
extern PingPerfDefaultTypeInternal _PingPerf_default_instance_;
class ProcessInfo;
class ProcessInfoDefaultTypeInternal;
extern ProcessInfoDefaultTypeInternal _ProcessInfo_default_instance_;
class ProcessorInfo;
class ProcessorInfoDefaultTypeInternal;
extern ProcessorInfoDefaultTypeInternal _ProcessorInfo_default_instance_;
class ReachableTestResult;
class ReachableTestResultDefaultTypeInternal;
extern ReachableTestResultDefaultTypeInternal _ReachableTestResult_default_instance_;
class ResSynInfo;
class ResSynInfoDefaultTypeInternal;
extern ResSynInfoDefaultTypeInternal _ResSynInfo_default_instance_;
class ResSynResult;
class ResSynResultDefaultTypeInternal;
extern ResSynResultDefaultTypeInternal _ResSynResult_default_instance_;
class RespAddr;
class RespAddrDefaultTypeInternal;
extern RespAddrDefaultTypeInternal _RespAddr_default_instance_;
class SenserSyncResult;
class SenserSyncResultDefaultTypeInternal;
extern SenserSyncResultDefaultTypeInternal _SenserSyncResult_default_instance_;
class SenserValue;
class SenserValueDefaultTypeInternal;
extern SenserValueDefaultTypeInternal _SenserValue_default_instance_;
class Sensor;
class SensorDefaultTypeInternal;
extern SensorDefaultTypeInternal _Sensor_default_instance_;
class SnmpBasePara;
class SnmpBaseParaDefaultTypeInternal;
extern SnmpBaseParaDefaultTypeInternal _SnmpBasePara_default_instance_;
class SnmpExtPara;
class SnmpExtParaDefaultTypeInternal;
extern SnmpExtParaDefaultTypeInternal _SnmpExtPara_default_instance_;
class SnmpInfo;
class SnmpInfoDefaultTypeInternal;
extern SnmpInfoDefaultTypeInternal _SnmpInfo_default_instance_;
class SoftwareInfo;
class SoftwareInfoDefaultTypeInternal;
extern SoftwareInfoDefaultTypeInternal _SoftwareInfo_default_instance_;
class SshPara;
class SshParaDefaultTypeInternal;
extern SshParaDefaultTypeInternal _SshPara_default_instance_;
class TelnetPara;
class TelnetParaDefaultTypeInternal;
extern TelnetParaDefaultTypeInternal _TelnetPara_default_instance_;
class TopoLinkInfo;
class TopoLinkInfoDefaultTypeInternal;
extern TopoLinkInfoDefaultTypeInternal _TopoLinkInfo_default_instance_;
class TopoNodeInfo;
class TopoNodeInfoDefaultTypeInternal;
extern TopoNodeInfoDefaultTypeInternal _TopoNodeInfo_default_instance_;
}  // namespace mpfmessage
namespace mpfmessage {

enum ResType {
  ROUTER = 1,
  SWITCH = 2,
  FIREWALL = 3,
  HOST = 4,
  INTERFACE = 5,
  DATABASE = 6,
  MIDWARE = 7,
  ROOM = 8,
  OTHER_TYPE = 9
};
bool ResType_IsValid(int value);
const ResType ResType_MIN = ROUTER;
const ResType ResType_MAX = OTHER_TYPE;
const int ResType_ARRAYSIZE = ResType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ResType_descriptor();
inline const ::std::string& ResType_Name(ResType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ResType_descriptor(), value);
}
inline bool ResType_Parse(
    const ::std::string& name, ResType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ResType>(
    ResType_descriptor(), name, value);
}
enum SnmpVersion {
  SNMP_V1 = 1,
  SNMP_V2 = 2,
  SNMP_V3 = 3
};
bool SnmpVersion_IsValid(int value);
const SnmpVersion SnmpVersion_MIN = SNMP_V1;
const SnmpVersion SnmpVersion_MAX = SNMP_V3;
const int SnmpVersion_ARRAYSIZE = SnmpVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnmpVersion_descriptor();
inline const ::std::string& SnmpVersion_Name(SnmpVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnmpVersion_descriptor(), value);
}
inline bool SnmpVersion_Parse(
    const ::std::string& name, SnmpVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnmpVersion>(
    SnmpVersion_descriptor(), name, value);
}
enum AuthMethod {
  MD5 = 1,
  SHA = 2,
  NONE_AUTH = 3
};
bool AuthMethod_IsValid(int value);
const AuthMethod AuthMethod_MIN = MD5;
const AuthMethod AuthMethod_MAX = NONE_AUTH;
const int AuthMethod_ARRAYSIZE = AuthMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthMethod_descriptor();
inline const ::std::string& AuthMethod_Name(AuthMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthMethod_descriptor(), value);
}
inline bool AuthMethod_Parse(
    const ::std::string& name, AuthMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthMethod>(
    AuthMethod_descriptor(), name, value);
}
enum EncryptMethod {
  DES = 1,
  AES = 2,
  NONE_ENCRYPT = 3
};
bool EncryptMethod_IsValid(int value);
const EncryptMethod EncryptMethod_MIN = DES;
const EncryptMethod EncryptMethod_MAX = NONE_ENCRYPT;
const int EncryptMethod_ARRAYSIZE = EncryptMethod_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncryptMethod_descriptor();
inline const ::std::string& EncryptMethod_Name(EncryptMethod value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncryptMethod_descriptor(), value);
}
inline bool EncryptMethod_Parse(
    const ::std::string& name, EncryptMethod* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptMethod>(
    EncryptMethod_descriptor(), name, value);
}
enum DatabaseType {
  ORACLE = 1,
  MYSQL = 2,
  MSSQLSERVER = 3,
  POSTGRES = 4
};
bool DatabaseType_IsValid(int value);
const DatabaseType DatabaseType_MIN = ORACLE;
const DatabaseType DatabaseType_MAX = POSTGRES;
const int DatabaseType_ARRAYSIZE = DatabaseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DatabaseType_descriptor();
inline const ::std::string& DatabaseType_Name(DatabaseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DatabaseType_descriptor(), value);
}
inline bool DatabaseType_Parse(
    const ::std::string& name, DatabaseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DatabaseType>(
    DatabaseType_descriptor(), name, value);
}
enum OSTYPE {
  WINDOWS = 1,
  LINUX = 2,
  MACOS = 3
};
bool OSTYPE_IsValid(int value);
const OSTYPE OSTYPE_MIN = WINDOWS;
const OSTYPE OSTYPE_MAX = MACOS;
const int OSTYPE_ARRAYSIZE = OSTYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* OSTYPE_descriptor();
inline const ::std::string& OSTYPE_Name(OSTYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    OSTYPE_descriptor(), value);
}
inline bool OSTYPE_Parse(
    const ::std::string& name, OSTYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSTYPE>(
    OSTYPE_descriptor(), name, value);
}
enum MidwareType {
  TOMCAT = 1,
  JETTY = 2,
  IIS = 3
};
bool MidwareType_IsValid(int value);
const MidwareType MidwareType_MIN = TOMCAT;
const MidwareType MidwareType_MAX = IIS;
const int MidwareType_ARRAYSIZE = MidwareType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MidwareType_descriptor();
inline const ::std::string& MidwareType_Name(MidwareType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MidwareType_descriptor(), value);
}
inline bool MidwareType_Parse(
    const ::std::string& name, MidwareType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MidwareType>(
    MidwareType_descriptor(), name, value);
}
enum DISK_ACCESS {
  readWrite = 1,
  readOnly = 2
};
bool DISK_ACCESS_IsValid(int value);
const DISK_ACCESS DISK_ACCESS_MIN = readWrite;
const DISK_ACCESS DISK_ACCESS_MAX = readOnly;
const int DISK_ACCESS_ARRAYSIZE = DISK_ACCESS_MAX + 1;

const ::google::protobuf::EnumDescriptor* DISK_ACCESS_descriptor();
inline const ::std::string& DISK_ACCESS_Name(DISK_ACCESS value) {
  return ::google::protobuf::internal::NameOfEnum(
    DISK_ACCESS_descriptor(), value);
}
inline bool DISK_ACCESS_Parse(
    const ::std::string& name, DISK_ACCESS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DISK_ACCESS>(
    DISK_ACCESS_descriptor(), name, value);
}
enum DISK_MEDIA_TYPE {
  other_media = 1,
  unknown_media = 2,
  hardDisk = 3,
  floppyDisk = 4,
  opticalDiskROM = 5,
  opticalDiskWORM = 6,
  opticalDiskRW = 7,
  ramDisk = 8
};
bool DISK_MEDIA_TYPE_IsValid(int value);
const DISK_MEDIA_TYPE DISK_MEDIA_TYPE_MIN = other_media;
const DISK_MEDIA_TYPE DISK_MEDIA_TYPE_MAX = ramDisk;
const int DISK_MEDIA_TYPE_ARRAYSIZE = DISK_MEDIA_TYPE_MAX + 1;

const ::google::protobuf::EnumDescriptor* DISK_MEDIA_TYPE_descriptor();
inline const ::std::string& DISK_MEDIA_TYPE_Name(DISK_MEDIA_TYPE value) {
  return ::google::protobuf::internal::NameOfEnum(
    DISK_MEDIA_TYPE_descriptor(), value);
}
inline bool DISK_MEDIA_TYPE_Parse(
    const ::std::string& name, DISK_MEDIA_TYPE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DISK_MEDIA_TYPE>(
    DISK_MEDIA_TYPE_descriptor(), name, value);
}
enum Status {
  up = 1,
  down = 2,
  testing = 3,
  unknown = 4,
  other_status = 5,
  not_present = 6
};
bool Status_IsValid(int value);
const Status Status_MIN = up;
const Status Status_MAX = not_present;
const int Status_ARRAYSIZE = Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* Status_descriptor();
inline const ::std::string& Status_Name(Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    Status_descriptor(), value);
}
inline bool Status_Parse(
    const ::std::string& name, Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Status>(
    Status_descriptor(), name, value);
}
enum IfType {
  others = 1,
  ethernetCsmacd = 6,
  ppp = 23,
  softwareLoopback = 24,
  atm = 37,
  fastEther = 62,
  channel = 70,
  ieee80211 = 71,
  adsl = 94,
  gigabitEthernet = 117,
  fast = 125,
  tunnel = 131,
  mpls = 166,
  pos = 171,
  usb = 160
};
bool IfType_IsValid(int value);
const IfType IfType_MIN = others;
const IfType IfType_MAX = pos;
const int IfType_ARRAYSIZE = IfType_MAX + 1;

const ::google::protobuf::EnumDescriptor* IfType_descriptor();
inline const ::std::string& IfType_Name(IfType value) {
  return ::google::protobuf::internal::NameOfEnum(
    IfType_descriptor(), value);
}
inline bool IfType_Parse(
    const ::std::string& name, IfType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IfType>(
    IfType_descriptor(), name, value);
}
enum SoftwareType {
  unknown_sw = 1,
  operatingSystem = 2,
  deviceDriver = 3,
  application = 4
};
bool SoftwareType_IsValid(int value);
const SoftwareType SoftwareType_MIN = unknown_sw;
const SoftwareType SoftwareType_MAX = application;
const int SoftwareType_ARRAYSIZE = SoftwareType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SoftwareType_descriptor();
inline const ::std::string& SoftwareType_Name(SoftwareType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SoftwareType_descriptor(), value);
}
inline bool SoftwareType_Parse(
    const ::std::string& name, SoftwareType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SoftwareType>(
    SoftwareType_descriptor(), name, value);
}
enum AvailableStatus {
  available = 1,
  no_available = 2
};
bool AvailableStatus_IsValid(int value);
const AvailableStatus AvailableStatus_MIN = available;
const AvailableStatus AvailableStatus_MAX = no_available;
const int AvailableStatus_ARRAYSIZE = AvailableStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* AvailableStatus_descriptor();
inline const ::std::string& AvailableStatus_Name(AvailableStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    AvailableStatus_descriptor(), value);
}
inline bool AvailableStatus_Parse(
    const ::std::string& name, AvailableStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AvailableStatus>(
    AvailableStatus_descriptor(), name, value);
}
enum ConnectivityTestType {
  PING_TEST = 1,
  SNMP_TEST = 2,
  TELNET_TEST = 4,
  SSH_TEST = 8
};
bool ConnectivityTestType_IsValid(int value);
const ConnectivityTestType ConnectivityTestType_MIN = PING_TEST;
const ConnectivityTestType ConnectivityTestType_MAX = SSH_TEST;
const int ConnectivityTestType_ARRAYSIZE = ConnectivityTestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectivityTestType_descriptor();
inline const ::std::string& ConnectivityTestType_Name(ConnectivityTestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectivityTestType_descriptor(), value);
}
inline bool ConnectivityTestType_Parse(
    const ::std::string& name, ConnectivityTestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectivityTestType>(
    ConnectivityTestType_descriptor(), name, value);
}
enum ConnectivityTestResult {
  UNREACHABLE = 1,
  LOGINERROR = 2,
  CONNECTIONOK = 3
};
bool ConnectivityTestResult_IsValid(int value);
const ConnectivityTestResult ConnectivityTestResult_MIN = UNREACHABLE;
const ConnectivityTestResult ConnectivityTestResult_MAX = CONNECTIONOK;
const int ConnectivityTestResult_ARRAYSIZE = ConnectivityTestResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConnectivityTestResult_descriptor();
inline const ::std::string& ConnectivityTestResult_Name(ConnectivityTestResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConnectivityTestResult_descriptor(), value);
}
inline bool ConnectivityTestResult_Parse(
    const ::std::string& name, ConnectivityTestResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConnectivityTestResult>(
    ConnectivityTestResult_descriptor(), name, value);
}
enum TestResult {
  REACHABLE_STATUS = 1,
  UNREACHABLE_STATUS = 2,
  MANAGEMENT_STATUS = 3,
  NOTMANAGEMENT_STATUS = 4,
  OTHER_STATUS = 5
};
bool TestResult_IsValid(int value);
const TestResult TestResult_MIN = REACHABLE_STATUS;
const TestResult TestResult_MAX = OTHER_STATUS;
const int TestResult_ARRAYSIZE = TestResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* TestResult_descriptor();
inline const ::std::string& TestResult_Name(TestResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    TestResult_descriptor(), value);
}
inline bool TestResult_Parse(
    const ::std::string& name, TestResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TestResult>(
    TestResult_descriptor(), name, value);
}
// ===================================================================

class SnmpBasePara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SnmpBasePara) */ {
 public:
  SnmpBasePara();
  virtual ~SnmpBasePara();

  SnmpBasePara(const SnmpBasePara& from);

  inline SnmpBasePara& operator=(const SnmpBasePara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnmpBasePara(SnmpBasePara&& from) noexcept
    : SnmpBasePara() {
    *this = ::std::move(from);
  }

  inline SnmpBasePara& operator=(SnmpBasePara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnmpBasePara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnmpBasePara* internal_default_instance() {
    return reinterpret_cast<const SnmpBasePara*>(
               &_SnmpBasePara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(SnmpBasePara* other);
  friend void swap(SnmpBasePara& a, SnmpBasePara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnmpBasePara* New() const PROTOBUF_FINAL { return New(NULL); }

  SnmpBasePara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SnmpBasePara& from);
  void MergeFrom(const SnmpBasePara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SnmpBasePara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip_addr = 1;
  bool has_ip_addr() const;
  void clear_ip_addr();
  static const int kIpAddrFieldNumber = 1;
  const ::std::string& ip_addr() const;
  void set_ip_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_ip_addr(::std::string&& value);
  #endif
  void set_ip_addr(const char* value);
  void set_ip_addr(const char* value, size_t size);
  ::std::string* mutable_ip_addr();
  ::std::string* release_ip_addr();
  void set_allocated_ip_addr(::std::string* ip_addr);

  // optional string read_community = 3;
  bool has_read_community() const;
  void clear_read_community();
  static const int kReadCommunityFieldNumber = 3;
  const ::std::string& read_community() const;
  void set_read_community(const ::std::string& value);
  #if LANG_CXX11
  void set_read_community(::std::string&& value);
  #endif
  void set_read_community(const char* value);
  void set_read_community(const char* value, size_t size);
  ::std::string* mutable_read_community();
  ::std::string* release_read_community();
  void set_allocated_read_community(::std::string* read_community);

  // optional string write_community = 4;
  bool has_write_community() const;
  void clear_write_community();
  static const int kWriteCommunityFieldNumber = 4;
  const ::std::string& write_community() const;
  void set_write_community(const ::std::string& value);
  #if LANG_CXX11
  void set_write_community(::std::string&& value);
  #endif
  void set_write_community(const char* value);
  void set_write_community(const char* value, size_t size);
  ::std::string* mutable_write_community();
  ::std::string* release_write_community();
  void set_allocated_write_community(::std::string* write_community);

  // optional uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional .mpfmessage.SnmpVersion version = 5;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 5;
  ::mpfmessage::SnmpVersion version() const;
  void set_version(::mpfmessage::SnmpVersion value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SnmpBasePara)
 private:
  void set_has_ip_addr();
  void clear_has_ip_addr();
  void set_has_port();
  void clear_has_port();
  void set_has_read_community();
  void clear_has_read_community();
  void set_has_write_community();
  void clear_has_write_community();
  void set_has_version();
  void clear_has_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_addr_;
  ::google::protobuf::internal::ArenaStringPtr read_community_;
  ::google::protobuf::internal::ArenaStringPtr write_community_;
  ::google::protobuf::uint32 port_;
  int version_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSnmpBaseParaImpl();
};
// -------------------------------------------------------------------

class SnmpExtPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SnmpExtPara) */ {
 public:
  SnmpExtPara();
  virtual ~SnmpExtPara();

  SnmpExtPara(const SnmpExtPara& from);

  inline SnmpExtPara& operator=(const SnmpExtPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnmpExtPara(SnmpExtPara&& from) noexcept
    : SnmpExtPara() {
    *this = ::std::move(from);
  }

  inline SnmpExtPara& operator=(SnmpExtPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnmpExtPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnmpExtPara* internal_default_instance() {
    return reinterpret_cast<const SnmpExtPara*>(
               &_SnmpExtPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(SnmpExtPara* other);
  friend void swap(SnmpExtPara& a, SnmpExtPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnmpExtPara* New() const PROTOBUF_FINAL { return New(NULL); }

  SnmpExtPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SnmpExtPara& from);
  void MergeFrom(const SnmpExtPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SnmpExtPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string auth_password = 3;
  bool has_auth_password() const;
  void clear_auth_password();
  static const int kAuthPasswordFieldNumber = 3;
  const ::std::string& auth_password() const;
  void set_auth_password(const ::std::string& value);
  #if LANG_CXX11
  void set_auth_password(::std::string&& value);
  #endif
  void set_auth_password(const char* value);
  void set_auth_password(const char* value, size_t size);
  ::std::string* mutable_auth_password();
  ::std::string* release_auth_password();
  void set_allocated_auth_password(::std::string* auth_password);

  // optional string encrypt_password = 5;
  bool has_encrypt_password() const;
  void clear_encrypt_password();
  static const int kEncryptPasswordFieldNumber = 5;
  const ::std::string& encrypt_password() const;
  void set_encrypt_password(const ::std::string& value);
  #if LANG_CXX11
  void set_encrypt_password(::std::string&& value);
  #endif
  void set_encrypt_password(const char* value);
  void set_encrypt_password(const char* value, size_t size);
  ::std::string* mutable_encrypt_password();
  ::std::string* release_encrypt_password();
  void set_allocated_encrypt_password(::std::string* encrypt_password);

  // optional string engine_id = 6;
  bool has_engine_id() const;
  void clear_engine_id();
  static const int kEngineIdFieldNumber = 6;
  const ::std::string& engine_id() const;
  void set_engine_id(const ::std::string& value);
  #if LANG_CXX11
  void set_engine_id(::std::string&& value);
  #endif
  void set_engine_id(const char* value);
  void set_engine_id(const char* value, size_t size);
  ::std::string* mutable_engine_id();
  ::std::string* release_engine_id();
  void set_allocated_engine_id(::std::string* engine_id);

  // optional .mpfmessage.AuthMethod auth_method = 2;
  bool has_auth_method() const;
  void clear_auth_method();
  static const int kAuthMethodFieldNumber = 2;
  ::mpfmessage::AuthMethod auth_method() const;
  void set_auth_method(::mpfmessage::AuthMethod value);

  // optional .mpfmessage.EncryptMethod encryptMethod = 4;
  bool has_encryptmethod() const;
  void clear_encryptmethod();
  static const int kEncryptMethodFieldNumber = 4;
  ::mpfmessage::EncryptMethod encryptmethod() const;
  void set_encryptmethod(::mpfmessage::EncryptMethod value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SnmpExtPara)
 private:
  void set_has_user();
  void clear_has_user();
  void set_has_auth_method();
  void clear_has_auth_method();
  void set_has_auth_password();
  void clear_has_auth_password();
  void set_has_encryptmethod();
  void clear_has_encryptmethod();
  void set_has_encrypt_password();
  void clear_has_encrypt_password();
  void set_has_engine_id();
  void clear_has_engine_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr auth_password_;
  ::google::protobuf::internal::ArenaStringPtr encrypt_password_;
  ::google::protobuf::internal::ArenaStringPtr engine_id_;
  int auth_method_;
  int encryptmethod_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSnmpExtParaImpl();
};
// -------------------------------------------------------------------

class SnmpInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SnmpInfo) */ {
 public:
  SnmpInfo();
  virtual ~SnmpInfo();

  SnmpInfo(const SnmpInfo& from);

  inline SnmpInfo& operator=(const SnmpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SnmpInfo(SnmpInfo&& from) noexcept
    : SnmpInfo() {
    *this = ::std::move(from);
  }

  inline SnmpInfo& operator=(SnmpInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SnmpInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SnmpInfo* internal_default_instance() {
    return reinterpret_cast<const SnmpInfo*>(
               &_SnmpInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(SnmpInfo* other);
  friend void swap(SnmpInfo& a, SnmpInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SnmpInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SnmpInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SnmpInfo& from);
  void MergeFrom(const SnmpInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SnmpInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpBasePara base_para = 1;
  bool has_base_para() const;
  void clear_base_para();
  static const int kBaseParaFieldNumber = 1;
  const ::mpfmessage::SnmpBasePara& base_para() const;
  ::mpfmessage::SnmpBasePara* release_base_para();
  ::mpfmessage::SnmpBasePara* mutable_base_para();
  void set_allocated_base_para(::mpfmessage::SnmpBasePara* base_para);

  // optional .mpfmessage.SnmpExtPara ext_para = 2;
  bool has_ext_para() const;
  void clear_ext_para();
  static const int kExtParaFieldNumber = 2;
  const ::mpfmessage::SnmpExtPara& ext_para() const;
  ::mpfmessage::SnmpExtPara* release_ext_para();
  ::mpfmessage::SnmpExtPara* mutable_ext_para();
  void set_allocated_ext_para(::mpfmessage::SnmpExtPara* ext_para);

  // optional uint32 timeout = 3;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 retry = 4;
  bool has_retry() const;
  void clear_retry();
  static const int kRetryFieldNumber = 4;
  ::google::protobuf::uint32 retry() const;
  void set_retry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SnmpInfo)
 private:
  void set_has_base_para();
  void clear_has_base_para();
  void set_has_ext_para();
  void clear_has_ext_para();
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_retry();
  void clear_has_retry();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpBasePara* base_para_;
  ::mpfmessage::SnmpExtPara* ext_para_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 retry_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSnmpInfoImpl();
};
// -------------------------------------------------------------------

class TelnetPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.TelnetPara) */ {
 public:
  TelnetPara();
  virtual ~TelnetPara();

  TelnetPara(const TelnetPara& from);

  inline TelnetPara& operator=(const TelnetPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TelnetPara(TelnetPara&& from) noexcept
    : TelnetPara() {
    *this = ::std::move(from);
  }

  inline TelnetPara& operator=(TelnetPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TelnetPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TelnetPara* internal_default_instance() {
    return reinterpret_cast<const TelnetPara*>(
               &_TelnetPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(TelnetPara* other);
  friend void swap(TelnetPara& a, TelnetPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TelnetPara* New() const PROTOBUF_FINAL { return New(NULL); }

  TelnetPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TelnetPara& from);
  void MergeFrom(const TelnetPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TelnetPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string pass = 2;
  bool has_pass() const;
  void clear_pass();
  static const int kPassFieldNumber = 2;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  #if LANG_CXX11
  void set_pass(::std::string&& value);
  #endif
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // optional string ip = 5;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 5;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 timeout = 3;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 3;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 retry = 4;
  bool has_retry() const;
  void clear_retry();
  static const int kRetryFieldNumber = 4;
  ::google::protobuf::uint32 retry() const;
  void set_retry(::google::protobuf::uint32 value);

  // optional uint32 port = 6;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 6;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.TelnetPara)
 private:
  void set_has_user();
  void clear_has_user();
  void set_has_pass();
  void clear_has_pass();
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_retry();
  void clear_has_retry();
  void set_has_ip();
  void clear_has_ip();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 retry_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsTelnetParaImpl();
};
// -------------------------------------------------------------------

class SshPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SshPara) */ {
 public:
  SshPara();
  virtual ~SshPara();

  SshPara(const SshPara& from);

  inline SshPara& operator=(const SshPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SshPara(SshPara&& from) noexcept
    : SshPara() {
    *this = ::std::move(from);
  }

  inline SshPara& operator=(SshPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SshPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SshPara* internal_default_instance() {
    return reinterpret_cast<const SshPara*>(
               &_SshPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SshPara* other);
  friend void swap(SshPara& a, SshPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SshPara* New() const PROTOBUF_FINAL { return New(NULL); }

  SshPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SshPara& from);
  void MergeFrom(const SshPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SshPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string user = 1;
  bool has_user() const;
  void clear_user();
  static const int kUserFieldNumber = 1;
  const ::std::string& user() const;
  void set_user(const ::std::string& value);
  #if LANG_CXX11
  void set_user(::std::string&& value);
  #endif
  void set_user(const char* value);
  void set_user(const char* value, size_t size);
  ::std::string* mutable_user();
  ::std::string* release_user();
  void set_allocated_user(::std::string* user);

  // optional string pass = 2;
  bool has_pass() const;
  void clear_pass();
  static const int kPassFieldNumber = 2;
  const ::std::string& pass() const;
  void set_pass(const ::std::string& value);
  #if LANG_CXX11
  void set_pass(::std::string&& value);
  #endif
  void set_pass(const char* value);
  void set_pass(const char* value, size_t size);
  ::std::string* mutable_pass();
  ::std::string* release_pass();
  void set_allocated_pass(::std::string* pass);

  // optional string ip = 6;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 6;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional uint32 timeout = 4;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // optional uint32 retry = 5;
  bool has_retry() const;
  void clear_retry();
  static const int kRetryFieldNumber = 5;
  ::google::protobuf::uint32 retry() const;
  void set_retry(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SshPara)
 private:
  void set_has_user();
  void clear_has_user();
  void set_has_pass();
  void clear_has_pass();
  void set_has_port();
  void clear_has_port();
  void set_has_timeout();
  void clear_has_timeout();
  void set_has_retry();
  void clear_has_retry();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_;
  ::google::protobuf::internal::ArenaStringPtr pass_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 port_;
  ::google::protobuf::uint32 timeout_;
  ::google::protobuf::uint32 retry_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSshParaImpl();
};
// -------------------------------------------------------------------

class PingPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.PingPara) */ {
 public:
  PingPara();
  virtual ~PingPara();

  PingPara(const PingPara& from);

  inline PingPara& operator=(const PingPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingPara(PingPara&& from) noexcept
    : PingPara() {
    *this = ::std::move(from);
  }

  inline PingPara& operator=(PingPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingPara* internal_default_instance() {
    return reinterpret_cast<const PingPara*>(
               &_PingPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(PingPara* other);
  friend void swap(PingPara& a, PingPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingPara* New() const PROTOBUF_FINAL { return New(NULL); }

  PingPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingPara& from);
  void MergeFrom(const PingPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 retry = 2;
  bool has_retry() const;
  void clear_retry();
  static const int kRetryFieldNumber = 2;
  ::google::protobuf::uint32 retry() const;
  void set_retry(::google::protobuf::uint32 value);

  // optional uint32 res_id = 3;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 3;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional uint32 timeout = 4;
  bool has_timeout() const;
  void clear_timeout();
  static const int kTimeoutFieldNumber = 4;
  ::google::protobuf::uint32 timeout() const;
  void set_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.PingPara)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_retry();
  void clear_has_retry();
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_timeout();
  void clear_has_timeout();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 retry_;
  ::google::protobuf::uint32 res_id_;
  ::google::protobuf::uint32 timeout_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsPingParaImpl();
};
// -------------------------------------------------------------------

class DbLoginPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DbLoginPara) */ {
 public:
  DbLoginPara();
  virtual ~DbLoginPara();

  DbLoginPara(const DbLoginPara& from);

  inline DbLoginPara& operator=(const DbLoginPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DbLoginPara(DbLoginPara&& from) noexcept
    : DbLoginPara() {
    *this = ::std::move(from);
  }

  inline DbLoginPara& operator=(DbLoginPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DbLoginPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DbLoginPara* internal_default_instance() {
    return reinterpret_cast<const DbLoginPara*>(
               &_DbLoginPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DbLoginPara* other);
  friend void swap(DbLoginPara& a, DbLoginPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DbLoginPara* New() const PROTOBUF_FINAL { return New(NULL); }

  DbLoginPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DbLoginPara& from);
  void MergeFrom(const DbLoginPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DbLoginPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string login_ip = 2;
  bool has_login_ip() const;
  void clear_login_ip();
  static const int kLoginIpFieldNumber = 2;
  const ::std::string& login_ip() const;
  void set_login_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_login_ip(::std::string&& value);
  #endif
  void set_login_ip(const char* value);
  void set_login_ip(const char* value, size_t size);
  ::std::string* mutable_login_ip();
  ::std::string* release_login_ip();
  void set_allocated_login_ip(::std::string* login_ip);

  // optional string dbname = 5;
  bool has_dbname() const;
  void clear_dbname();
  static const int kDbnameFieldNumber = 5;
  const ::std::string& dbname() const;
  void set_dbname(const ::std::string& value);
  #if LANG_CXX11
  void set_dbname(::std::string&& value);
  #endif
  void set_dbname(const char* value);
  void set_dbname(const char* value, size_t size);
  ::std::string* mutable_dbname();
  ::std::string* release_dbname();
  void set_allocated_dbname(::std::string* dbname);

  // optional string uid = 6;
  bool has_uid() const;
  void clear_uid();
  static const int kUidFieldNumber = 6;
  const ::std::string& uid() const;
  void set_uid(const ::std::string& value);
  #if LANG_CXX11
  void set_uid(::std::string&& value);
  #endif
  void set_uid(const char* value);
  void set_uid(const char* value, size_t size);
  ::std::string* mutable_uid();
  ::std::string* release_uid();
  void set_allocated_uid(::std::string* uid);

  // optional string password = 7;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 7;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string db_version = 8;
  bool has_db_version() const;
  void clear_db_version();
  static const int kDbVersionFieldNumber = 8;
  const ::std::string& db_version() const;
  void set_db_version(const ::std::string& value);
  #if LANG_CXX11
  void set_db_version(::std::string&& value);
  #endif
  void set_db_version(const char* value);
  void set_db_version(const char* value, size_t size);
  ::std::string* mutable_db_version();
  ::std::string* release_db_version();
  void set_allocated_db_version(::std::string* db_version);

  // optional uint32 port = 3;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 3;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // optional .mpfmessage.DatabaseType db_type = 1;
  bool has_db_type() const;
  void clear_db_type();
  static const int kDbTypeFieldNumber = 1;
  ::mpfmessage::DatabaseType db_type() const;
  void set_db_type(::mpfmessage::DatabaseType value);

  // optional .mpfmessage.OSTYPE os_type = 4;
  bool has_os_type() const;
  void clear_os_type();
  static const int kOsTypeFieldNumber = 4;
  ::mpfmessage::OSTYPE os_type() const;
  void set_os_type(::mpfmessage::OSTYPE value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DbLoginPara)
 private:
  void set_has_db_type();
  void clear_has_db_type();
  void set_has_login_ip();
  void clear_has_login_ip();
  void set_has_port();
  void clear_has_port();
  void set_has_os_type();
  void clear_has_os_type();
  void set_has_dbname();
  void clear_has_dbname();
  void set_has_uid();
  void clear_has_uid();
  void set_has_password();
  void clear_has_password();
  void set_has_db_version();
  void clear_has_db_version();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr login_ip_;
  ::google::protobuf::internal::ArenaStringPtr dbname_;
  ::google::protobuf::internal::ArenaStringPtr uid_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr db_version_;
  ::google::protobuf::uint32 port_;
  int db_type_;
  int os_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDbLoginParaImpl();
};
// -------------------------------------------------------------------

class NetDevBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.NetDevBaseInfo) */ {
 public:
  NetDevBaseInfo();
  virtual ~NetDevBaseInfo();

  NetDevBaseInfo(const NetDevBaseInfo& from);

  inline NetDevBaseInfo& operator=(const NetDevBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NetDevBaseInfo(NetDevBaseInfo&& from) noexcept
    : NetDevBaseInfo() {
    *this = ::std::move(from);
  }

  inline NetDevBaseInfo& operator=(NetDevBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetDevBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NetDevBaseInfo* internal_default_instance() {
    return reinterpret_cast<const NetDevBaseInfo*>(
               &_NetDevBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(NetDevBaseInfo* other);
  friend void swap(NetDevBaseInfo& a, NetDevBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NetDevBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  NetDevBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const NetDevBaseInfo& from);
  void MergeFrom(const NetDevBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(NetDevBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dev_serial = 3;
  bool has_dev_serial() const;
  void clear_dev_serial();
  static const int kDevSerialFieldNumber = 3;
  const ::std::string& dev_serial() const;
  void set_dev_serial(const ::std::string& value);
  #if LANG_CXX11
  void set_dev_serial(::std::string&& value);
  #endif
  void set_dev_serial(const char* value);
  void set_dev_serial(const char* value, size_t size);
  ::std::string* mutable_dev_serial();
  ::std::string* release_dev_serial();
  void set_allocated_dev_serial(::std::string* dev_serial);

  // optional string sys_oid = 4;
  bool has_sys_oid() const;
  void clear_sys_oid();
  static const int kSysOidFieldNumber = 4;
  const ::std::string& sys_oid() const;
  void set_sys_oid(const ::std::string& value);
  #if LANG_CXX11
  void set_sys_oid(::std::string&& value);
  #endif
  void set_sys_oid(const char* value);
  void set_sys_oid(const char* value, size_t size);
  ::std::string* mutable_sys_oid();
  ::std::string* release_sys_oid();
  void set_allocated_sys_oid(::std::string* sys_oid);

  // optional string sys_desc = 5;
  bool has_sys_desc() const;
  void clear_sys_desc();
  static const int kSysDescFieldNumber = 5;
  const ::std::string& sys_desc() const;
  void set_sys_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_sys_desc(::std::string&& value);
  #endif
  void set_sys_desc(const char* value);
  void set_sys_desc(const char* value, size_t size);
  ::std::string* mutable_sys_desc();
  ::std::string* release_sys_desc();
  void set_allocated_sys_desc(::std::string* sys_desc);

  // optional string sys_name = 6;
  bool has_sys_name() const;
  void clear_sys_name();
  static const int kSysNameFieldNumber = 6;
  const ::std::string& sys_name() const;
  void set_sys_name(const ::std::string& value);
  #if LANG_CXX11
  void set_sys_name(::std::string&& value);
  #endif
  void set_sys_name(const char* value);
  void set_sys_name(const char* value, size_t size);
  ::std::string* mutable_sys_name();
  ::std::string* release_sys_name();
  void set_allocated_sys_name(::std::string* sys_name);

  // optional string contactor = 7;
  bool has_contactor() const;
  void clear_contactor();
  static const int kContactorFieldNumber = 7;
  const ::std::string& contactor() const;
  void set_contactor(const ::std::string& value);
  #if LANG_CXX11
  void set_contactor(::std::string&& value);
  #endif
  void set_contactor(const char* value);
  void set_contactor(const char* value, size_t size);
  ::std::string* mutable_contactor();
  ::std::string* release_contactor();
  void set_allocated_contactor(::std::string* contactor);

  // optional string location = 8;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 8;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // optional uint32 up_time = 9;
  bool has_up_time() const;
  void clear_up_time();
  static const int kUpTimeFieldNumber = 9;
  ::google::protobuf::uint32 up_time() const;
  void set_up_time(::google::protobuf::uint32 value);

  // optional uint32 syn_time = 10;
  bool has_syn_time() const;
  void clear_syn_time();
  static const int kSynTimeFieldNumber = 10;
  ::google::protobuf::uint32 syn_time() const;
  void set_syn_time(::google::protobuf::uint32 value);

  // optional .mpfmessage.Status dev_status = 1;
  bool has_dev_status() const;
  void clear_dev_status();
  static const int kDevStatusFieldNumber = 1;
  ::mpfmessage::Status dev_status() const;
  void set_dev_status(::mpfmessage::Status value);

  // optional .mpfmessage.ResType dev_type = 2;
  bool has_dev_type() const;
  void clear_dev_type();
  static const int kDevTypeFieldNumber = 2;
  ::mpfmessage::ResType dev_type() const;
  void set_dev_type(::mpfmessage::ResType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.NetDevBaseInfo)
 private:
  void set_has_dev_status();
  void clear_has_dev_status();
  void set_has_dev_type();
  void clear_has_dev_type();
  void set_has_dev_serial();
  void clear_has_dev_serial();
  void set_has_sys_oid();
  void clear_has_sys_oid();
  void set_has_sys_desc();
  void clear_has_sys_desc();
  void set_has_sys_name();
  void clear_has_sys_name();
  void set_has_contactor();
  void clear_has_contactor();
  void set_has_location();
  void clear_has_location();
  void set_has_up_time();
  void clear_has_up_time();
  void set_has_syn_time();
  void clear_has_syn_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dev_serial_;
  ::google::protobuf::internal::ArenaStringPtr sys_oid_;
  ::google::protobuf::internal::ArenaStringPtr sys_desc_;
  ::google::protobuf::internal::ArenaStringPtr sys_name_;
  ::google::protobuf::internal::ArenaStringPtr contactor_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint32 up_time_;
  ::google::protobuf::uint32 syn_time_;
  int dev_status_;
  int dev_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsNetDevBaseInfoImpl();
};
// -------------------------------------------------------------------

class DiskInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DiskInfo) */ {
 public:
  DiskInfo();
  virtual ~DiskInfo();

  DiskInfo(const DiskInfo& from);

  inline DiskInfo& operator=(const DiskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiskInfo(DiskInfo&& from) noexcept
    : DiskInfo() {
    *this = ::std::move(from);
  }

  inline DiskInfo& operator=(DiskInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiskInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiskInfo* internal_default_instance() {
    return reinterpret_cast<const DiskInfo*>(
               &_DiskInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(DiskInfo* other);
  friend void swap(DiskInfo& a, DiskInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiskInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DiskInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiskInfo& from);
  void MergeFrom(const DiskInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiskInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 disk_size = 3;
  bool has_disk_size() const;
  void clear_disk_size();
  static const int kDiskSizeFieldNumber = 3;
  ::google::protobuf::uint32 disk_size() const;
  void set_disk_size(::google::protobuf::uint32 value);

  // optional .mpfmessage.DISK_ACCESS disk_access = 1;
  bool has_disk_access() const;
  void clear_disk_access();
  static const int kDiskAccessFieldNumber = 1;
  ::mpfmessage::DISK_ACCESS disk_access() const;
  void set_disk_access(::mpfmessage::DISK_ACCESS value);

  // optional .mpfmessage.DISK_MEDIA_TYPE media_type = 2;
  bool has_media_type() const;
  void clear_media_type();
  static const int kMediaTypeFieldNumber = 2;
  ::mpfmessage::DISK_MEDIA_TYPE media_type() const;
  void set_media_type(::mpfmessage::DISK_MEDIA_TYPE value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DiskInfo)
 private:
  void set_has_disk_access();
  void clear_has_disk_access();
  void set_has_media_type();
  void clear_has_media_type();
  void set_has_disk_size();
  void clear_has_disk_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 disk_size_;
  int disk_access_;
  int media_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDiskInfoImpl();
};
// -------------------------------------------------------------------

class PartitionInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.PartitionInfo) */ {
 public:
  PartitionInfo();
  virtual ~PartitionInfo();

  PartitionInfo(const PartitionInfo& from);

  inline PartitionInfo& operator=(const PartitionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PartitionInfo(PartitionInfo&& from) noexcept
    : PartitionInfo() {
    *this = ::std::move(from);
  }

  inline PartitionInfo& operator=(PartitionInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PartitionInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PartitionInfo* internal_default_instance() {
    return reinterpret_cast<const PartitionInfo*>(
               &_PartitionInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(PartitionInfo* other);
  friend void swap(PartitionInfo& a, PartitionInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PartitionInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  PartitionInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PartitionInfo& from);
  void MergeFrom(const PartitionInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PartitionInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string part_name = 2;
  bool has_part_name() const;
  void clear_part_name();
  static const int kPartNameFieldNumber = 2;
  const ::std::string& part_name() const;
  void set_part_name(const ::std::string& value);
  #if LANG_CXX11
  void set_part_name(::std::string&& value);
  #endif
  void set_part_name(const char* value);
  void set_part_name(const char* value, size_t size);
  ::std::string* mutable_part_name();
  ::std::string* release_part_name();
  void set_allocated_part_name(::std::string* part_name);

  // optional uint32 part_index = 1;
  bool has_part_index() const;
  void clear_part_index();
  static const int kPartIndexFieldNumber = 1;
  ::google::protobuf::uint32 part_index() const;
  void set_part_index(::google::protobuf::uint32 value);

  // optional uint32 part_size = 3;
  bool has_part_size() const;
  void clear_part_size();
  static const int kPartSizeFieldNumber = 3;
  ::google::protobuf::uint32 part_size() const;
  void set_part_size(::google::protobuf::uint32 value);

  // optional uint32 part_used = 4;
  bool has_part_used() const;
  void clear_part_used();
  static const int kPartUsedFieldNumber = 4;
  ::google::protobuf::uint32 part_used() const;
  void set_part_used(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.PartitionInfo)
 private:
  void set_has_part_index();
  void clear_has_part_index();
  void set_has_part_name();
  void clear_has_part_name();
  void set_has_part_size();
  void clear_has_part_size();
  void set_has_part_used();
  void clear_has_part_used();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr part_name_;
  ::google::protobuf::uint32 part_index_;
  ::google::protobuf::uint32 part_size_;
  ::google::protobuf::uint32 part_used_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsPartitionInfoImpl();
};
// -------------------------------------------------------------------

class ProcessorInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ProcessorInfo) */ {
 public:
  ProcessorInfo();
  virtual ~ProcessorInfo();

  ProcessorInfo(const ProcessorInfo& from);

  inline ProcessorInfo& operator=(const ProcessorInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessorInfo(ProcessorInfo&& from) noexcept
    : ProcessorInfo() {
    *this = ::std::move(from);
  }

  inline ProcessorInfo& operator=(ProcessorInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessorInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessorInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessorInfo*>(
               &_ProcessorInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(ProcessorInfo* other);
  friend void swap(ProcessorInfo& a, ProcessorInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessorInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessorInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessorInfo& from);
  void MergeFrom(const ProcessorInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessorInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string processor_desc = 2;
  bool has_processor_desc() const;
  void clear_processor_desc();
  static const int kProcessorDescFieldNumber = 2;
  const ::std::string& processor_desc() const;
  void set_processor_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_processor_desc(::std::string&& value);
  #endif
  void set_processor_desc(const char* value);
  void set_processor_desc(const char* value, size_t size);
  ::std::string* mutable_processor_desc();
  ::std::string* release_processor_desc();
  void set_allocated_processor_desc(::std::string* processor_desc);

  // optional uint32 processor_index = 1;
  bool has_processor_index() const;
  void clear_processor_index();
  static const int kProcessorIndexFieldNumber = 1;
  ::google::protobuf::uint32 processor_index() const;
  void set_processor_index(::google::protobuf::uint32 value);

  // optional uint32 processor_load = 3;
  bool has_processor_load() const;
  void clear_processor_load();
  static const int kProcessorLoadFieldNumber = 3;
  ::google::protobuf::uint32 processor_load() const;
  void set_processor_load(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ProcessorInfo)
 private:
  void set_has_processor_index();
  void clear_has_processor_index();
  void set_has_processor_desc();
  void clear_has_processor_desc();
  void set_has_processor_load();
  void clear_has_processor_load();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr processor_desc_;
  ::google::protobuf::uint32 processor_index_;
  ::google::protobuf::uint32 processor_load_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsProcessorInfoImpl();
};
// -------------------------------------------------------------------

class HostBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.HostBaseInfo) */ {
 public:
  HostBaseInfo();
  virtual ~HostBaseInfo();

  HostBaseInfo(const HostBaseInfo& from);

  inline HostBaseInfo& operator=(const HostBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HostBaseInfo(HostBaseInfo&& from) noexcept
    : HostBaseInfo() {
    *this = ::std::move(from);
  }

  inline HostBaseInfo& operator=(HostBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HostBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HostBaseInfo* internal_default_instance() {
    return reinterpret_cast<const HostBaseInfo*>(
               &_HostBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(HostBaseInfo* other);
  friend void swap(HostBaseInfo& a, HostBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HostBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  HostBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HostBaseInfo& from);
  void MergeFrom(const HostBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HostBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.ProcessorInfo cpulist = 5;
  int cpulist_size() const;
  void clear_cpulist();
  static const int kCpulistFieldNumber = 5;
  const ::mpfmessage::ProcessorInfo& cpulist(int index) const;
  ::mpfmessage::ProcessorInfo* mutable_cpulist(int index);
  ::mpfmessage::ProcessorInfo* add_cpulist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessorInfo >*
      mutable_cpulist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessorInfo >&
      cpulist() const;

  // repeated .mpfmessage.DiskInfo diskList = 9;
  int disklist_size() const;
  void clear_disklist();
  static const int kDiskListFieldNumber = 9;
  const ::mpfmessage::DiskInfo& disklist(int index) const;
  ::mpfmessage::DiskInfo* mutable_disklist(int index);
  ::mpfmessage::DiskInfo* add_disklist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DiskInfo >*
      mutable_disklist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DiskInfo >&
      disklist() const;

  // repeated .mpfmessage.PartitionInfo partiList = 10;
  int partilist_size() const;
  void clear_partilist();
  static const int kPartiListFieldNumber = 10;
  const ::mpfmessage::PartitionInfo& partilist(int index) const;
  ::mpfmessage::PartitionInfo* mutable_partilist(int index);
  ::mpfmessage::PartitionInfo* add_partilist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >*
      mutable_partilist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >&
      partilist() const;

  // optional string sys_time = 1;
  bool has_sys_time() const;
  void clear_sys_time();
  static const int kSysTimeFieldNumber = 1;
  const ::std::string& sys_time() const;
  void set_sys_time(const ::std::string& value);
  #if LANG_CXX11
  void set_sys_time(::std::string&& value);
  #endif
  void set_sys_time(const char* value);
  void set_sys_time(const char* value, size_t size);
  ::std::string* mutable_sys_time();
  ::std::string* release_sys_time();
  void set_allocated_sys_time(::std::string* sys_time);

  // optional uint32 run_time = 2;
  bool has_run_time() const;
  void clear_run_time();
  static const int kRunTimeFieldNumber = 2;
  ::google::protobuf::uint32 run_time() const;
  void set_run_time(::google::protobuf::uint32 value);

  // optional uint32 online_user_num = 3;
  bool has_online_user_num() const;
  void clear_online_user_num();
  static const int kOnlineUserNumFieldNumber = 3;
  ::google::protobuf::uint32 online_user_num() const;
  void set_online_user_num(::google::protobuf::uint32 value);

  // optional uint32 process_num = 4;
  bool has_process_num() const;
  void clear_process_num();
  static const int kProcessNumFieldNumber = 4;
  ::google::protobuf::uint32 process_num() const;
  void set_process_num(::google::protobuf::uint32 value);

  // optional uint32 total_phy_memory = 6;
  bool has_total_phy_memory() const;
  void clear_total_phy_memory();
  static const int kTotalPhyMemoryFieldNumber = 6;
  ::google::protobuf::uint32 total_phy_memory() const;
  void set_total_phy_memory(::google::protobuf::uint32 value);

  // optional uint32 total_virtual_memory = 7;
  bool has_total_virtual_memory() const;
  void clear_total_virtual_memory();
  static const int kTotalVirtualMemoryFieldNumber = 7;
  ::google::protobuf::uint32 total_virtual_memory() const;
  void set_total_virtual_memory(::google::protobuf::uint32 value);

  // optional uint32 total_disk_space = 8;
  bool has_total_disk_space() const;
  void clear_total_disk_space();
  static const int kTotalDiskSpaceFieldNumber = 8;
  ::google::protobuf::uint32 total_disk_space() const;
  void set_total_disk_space(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.HostBaseInfo)
 private:
  void set_has_sys_time();
  void clear_has_sys_time();
  void set_has_run_time();
  void clear_has_run_time();
  void set_has_online_user_num();
  void clear_has_online_user_num();
  void set_has_process_num();
  void clear_has_process_num();
  void set_has_total_phy_memory();
  void clear_has_total_phy_memory();
  void set_has_total_virtual_memory();
  void clear_has_total_virtual_memory();
  void set_has_total_disk_space();
  void clear_has_total_disk_space();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessorInfo > cpulist_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DiskInfo > disklist_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo > partilist_;
  ::google::protobuf::internal::ArenaStringPtr sys_time_;
  ::google::protobuf::uint32 run_time_;
  ::google::protobuf::uint32 online_user_num_;
  ::google::protobuf::uint32 process_num_;
  ::google::protobuf::uint32 total_phy_memory_;
  ::google::protobuf::uint32 total_virtual_memory_;
  ::google::protobuf::uint32 total_disk_space_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsHostBaseInfoImpl();
};
// -------------------------------------------------------------------

class IfBaseInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.IfBaseInfo) */ {
 public:
  IfBaseInfo();
  virtual ~IfBaseInfo();

  IfBaseInfo(const IfBaseInfo& from);

  inline IfBaseInfo& operator=(const IfBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfBaseInfo(IfBaseInfo&& from) noexcept
    : IfBaseInfo() {
    *this = ::std::move(from);
  }

  inline IfBaseInfo& operator=(IfBaseInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IfBaseInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfBaseInfo* internal_default_instance() {
    return reinterpret_cast<const IfBaseInfo*>(
               &_IfBaseInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(IfBaseInfo* other);
  friend void swap(IfBaseInfo& a, IfBaseInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfBaseInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  IfBaseInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IfBaseInfo& from);
  void MergeFrom(const IfBaseInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IfBaseInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional bytes if_phys_addr = 4;
  bool has_if_phys_addr() const;
  void clear_if_phys_addr();
  static const int kIfPhysAddrFieldNumber = 4;
  const ::std::string& if_phys_addr() const;
  void set_if_phys_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_if_phys_addr(::std::string&& value);
  #endif
  void set_if_phys_addr(const char* value);
  void set_if_phys_addr(const void* value, size_t size);
  ::std::string* mutable_if_phys_addr();
  ::std::string* release_if_phys_addr();
  void set_allocated_if_phys_addr(::std::string* if_phys_addr);

  // optional string ip = 7;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 7;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional string mask = 8;
  bool has_mask() const;
  void clear_mask();
  static const int kMaskFieldNumber = 8;
  const ::std::string& mask() const;
  void set_mask(const ::std::string& value);
  #if LANG_CXX11
  void set_mask(::std::string&& value);
  #endif
  void set_mask(const char* value);
  void set_mask(const char* value, size_t size);
  ::std::string* mutable_mask();
  ::std::string* release_mask();
  void set_allocated_mask(::std::string* mask);

  // optional string alias = 11;
  bool has_alias() const;
  void clear_alias();
  static const int kAliasFieldNumber = 11;
  const ::std::string& alias() const;
  void set_alias(const ::std::string& value);
  #if LANG_CXX11
  void set_alias(::std::string&& value);
  #endif
  void set_alias(const char* value);
  void set_alias(const char* value, size_t size);
  ::std::string* mutable_alias();
  ::std::string* release_alias();
  void set_allocated_alias(::std::string* alias);

  // optional uint32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional uint32 rate = 5;
  bool has_rate() const;
  void clear_rate();
  static const int kRateFieldNumber = 5;
  ::google::protobuf::uint32 rate() const;
  void set_rate(::google::protobuf::uint32 value);

  // optional uint32 mtu = 6;
  bool has_mtu() const;
  void clear_mtu();
  static const int kMtuFieldNumber = 6;
  ::google::protobuf::uint32 mtu() const;
  void set_mtu(::google::protobuf::uint32 value);

  // optional .mpfmessage.Status admin_status = 10;
  bool has_admin_status() const;
  void clear_admin_status();
  static const int kAdminStatusFieldNumber = 10;
  ::mpfmessage::Status admin_status() const;
  void set_admin_status(::mpfmessage::Status value);

  // optional .mpfmessage.IfType iftype = 3;
  bool has_iftype() const;
  void clear_iftype();
  static const int kIftypeFieldNumber = 3;
  ::mpfmessage::IfType iftype() const;
  void set_iftype(::mpfmessage::IfType value);

  // optional .mpfmessage.Status oper_status = 9;
  bool has_oper_status() const;
  void clear_oper_status();
  static const int kOperStatusFieldNumber = 9;
  ::mpfmessage::Status oper_status() const;
  void set_oper_status(::mpfmessage::Status value);

  // @@protoc_insertion_point(class_scope:mpfmessage.IfBaseInfo)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_desc();
  void clear_has_desc();
  void set_has_iftype();
  void clear_has_iftype();
  void set_has_if_phys_addr();
  void clear_has_if_phys_addr();
  void set_has_rate();
  void clear_has_rate();
  void set_has_mtu();
  void clear_has_mtu();
  void set_has_ip();
  void clear_has_ip();
  void set_has_mask();
  void clear_has_mask();
  void set_has_oper_status();
  void clear_has_oper_status();
  void set_has_admin_status();
  void clear_has_admin_status();
  void set_has_alias();
  void clear_has_alias();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr if_phys_addr_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr mask_;
  ::google::protobuf::internal::ArenaStringPtr alias_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 rate_;
  ::google::protobuf::uint32 mtu_;
  int admin_status_;
  int iftype_;
  int oper_status_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsIfBaseInfoImpl();
};
// -------------------------------------------------------------------

class IfResInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.IfResInfo) */ {
 public:
  IfResInfo();
  virtual ~IfResInfo();

  IfResInfo(const IfResInfo& from);

  inline IfResInfo& operator=(const IfResInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfResInfo(IfResInfo&& from) noexcept
    : IfResInfo() {
    *this = ::std::move(from);
  }

  inline IfResInfo& operator=(IfResInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IfResInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfResInfo* internal_default_instance() {
    return reinterpret_cast<const IfResInfo*>(
               &_IfResInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(IfResInfo* other);
  friend void swap(IfResInfo& a, IfResInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfResInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  IfResInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IfResInfo& from);
  void MergeFrom(const IfResInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IfResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ifdesc = 4;
  bool has_ifdesc() const;
  void clear_ifdesc();
  static const int kIfdescFieldNumber = 4;
  const ::std::string& ifdesc() const;
  void set_ifdesc(const ::std::string& value);
  #if LANG_CXX11
  void set_ifdesc(::std::string&& value);
  #endif
  void set_ifdesc(const char* value);
  void set_ifdesc(const char* value, size_t size);
  ::std::string* mutable_ifdesc();
  ::std::string* release_ifdesc();
  void set_allocated_ifdesc(::std::string* ifdesc);

  // optional string ip = 5;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 5;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional uint32 dev_resid = 1;
  bool has_dev_resid() const;
  void clear_dev_resid();
  static const int kDevResidFieldNumber = 1;
  ::google::protobuf::uint32 dev_resid() const;
  void set_dev_resid(::google::protobuf::uint32 value);

  // optional uint32 if_resid = 2;
  bool has_if_resid() const;
  void clear_if_resid();
  static const int kIfResidFieldNumber = 2;
  ::google::protobuf::uint32 if_resid() const;
  void set_if_resid(::google::protobuf::uint32 value);

  // optional uint32 ifindex = 3;
  bool has_ifindex() const;
  void clear_ifindex();
  static const int kIfindexFieldNumber = 3;
  ::google::protobuf::uint32 ifindex() const;
  void set_ifindex(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.IfResInfo)
 private:
  void set_has_dev_resid();
  void clear_has_dev_resid();
  void set_has_if_resid();
  void clear_has_if_resid();
  void set_has_ifindex();
  void clear_has_ifindex();
  void set_has_ifdesc();
  void clear_has_ifdesc();
  void set_has_ip();
  void clear_has_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ifdesc_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::uint32 dev_resid_;
  ::google::protobuf::uint32 if_resid_;
  ::google::protobuf::uint32 ifindex_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsIfResInfoImpl();
};
// -------------------------------------------------------------------

class ProcessInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ProcessInfo) */ {
 public:
  ProcessInfo();
  virtual ~ProcessInfo();

  ProcessInfo(const ProcessInfo& from);

  inline ProcessInfo& operator=(const ProcessInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProcessInfo(ProcessInfo&& from) noexcept
    : ProcessInfo() {
    *this = ::std::move(from);
  }

  inline ProcessInfo& operator=(ProcessInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcessInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProcessInfo* internal_default_instance() {
    return reinterpret_cast<const ProcessInfo*>(
               &_ProcessInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(ProcessInfo* other);
  friend void swap(ProcessInfo& a, ProcessInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProcessInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ProcessInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ProcessInfo& from);
  void MergeFrom(const ProcessInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ProcessInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string run_path = 6;
  bool has_run_path() const;
  void clear_run_path();
  static const int kRunPathFieldNumber = 6;
  const ::std::string& run_path() const;
  void set_run_path(const ::std::string& value);
  #if LANG_CXX11
  void set_run_path(::std::string&& value);
  #endif
  void set_run_path(const char* value);
  void set_run_path(const char* value, size_t size);
  ::std::string* mutable_run_path();
  ::std::string* release_run_path();
  void set_allocated_run_path(::std::string* run_path);

  // optional string parameter = 7;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 7;
  const ::std::string& parameter() const;
  void set_parameter(const ::std::string& value);
  #if LANG_CXX11
  void set_parameter(::std::string&& value);
  #endif
  void set_parameter(const char* value);
  void set_parameter(const char* value, size_t size);
  ::std::string* mutable_parameter();
  ::std::string* release_parameter();
  void set_allocated_parameter(::std::string* parameter);

  // optional uint32 pid = 1;
  bool has_pid() const;
  void clear_pid();
  static const int kPidFieldNumber = 1;
  ::google::protobuf::uint32 pid() const;
  void set_pid(::google::protobuf::uint32 value);

  // optional uint32 cpu_rate = 4;
  bool has_cpu_rate() const;
  void clear_cpu_rate();
  static const int kCpuRateFieldNumber = 4;
  ::google::protobuf::uint32 cpu_rate() const;
  void set_cpu_rate(::google::protobuf::uint32 value);

  // optional uint32 mem_use = 5;
  bool has_mem_use() const;
  void clear_mem_use();
  static const int kMemUseFieldNumber = 5;
  ::google::protobuf::uint32 mem_use() const;
  void set_mem_use(::google::protobuf::uint32 value);

  // optional uint32 status = 8;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 8;
  ::google::protobuf::uint32 status() const;
  void set_status(::google::protobuf::uint32 value);

  // optional .mpfmessage.SoftwareType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::mpfmessage::SoftwareType type() const;
  void set_type(::mpfmessage::SoftwareType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ProcessInfo)
 private:
  void set_has_pid();
  void clear_has_pid();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_cpu_rate();
  void clear_has_cpu_rate();
  void set_has_mem_use();
  void clear_has_mem_use();
  void set_has_run_path();
  void clear_has_run_path();
  void set_has_parameter();
  void clear_has_parameter();
  void set_has_status();
  void clear_has_status();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr run_path_;
  ::google::protobuf::internal::ArenaStringPtr parameter_;
  ::google::protobuf::uint32 pid_;
  ::google::protobuf::uint32 cpu_rate_;
  ::google::protobuf::uint32 mem_use_;
  ::google::protobuf::uint32 status_;
  int type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsProcessInfoImpl();
};
// -------------------------------------------------------------------

class SoftwareInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SoftwareInfo) */ {
 public:
  SoftwareInfo();
  virtual ~SoftwareInfo();

  SoftwareInfo(const SoftwareInfo& from);

  inline SoftwareInfo& operator=(const SoftwareInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SoftwareInfo(SoftwareInfo&& from) noexcept
    : SoftwareInfo() {
    *this = ::std::move(from);
  }

  inline SoftwareInfo& operator=(SoftwareInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftwareInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SoftwareInfo* internal_default_instance() {
    return reinterpret_cast<const SoftwareInfo*>(
               &_SoftwareInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(SoftwareInfo* other);
  friend void swap(SoftwareInfo& a, SoftwareInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SoftwareInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SoftwareInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SoftwareInfo& from);
  void MergeFrom(const SoftwareInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SoftwareInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string install_time = 3;
  bool has_install_time() const;
  void clear_install_time();
  static const int kInstallTimeFieldNumber = 3;
  const ::std::string& install_time() const;
  void set_install_time(const ::std::string& value);
  #if LANG_CXX11
  void set_install_time(::std::string&& value);
  #endif
  void set_install_time(const char* value);
  void set_install_time(const char* value, size_t size);
  ::std::string* mutable_install_time();
  ::std::string* release_install_time();
  void set_allocated_install_time(::std::string* install_time);

  // optional .mpfmessage.SoftwareType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::mpfmessage::SoftwareType type() const;
  void set_type(::mpfmessage::SoftwareType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SoftwareInfo)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_install_time();
  void clear_has_install_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr install_time_;
  int type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSoftwareInfoImpl();
};
// -------------------------------------------------------------------

class PerfParameter : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.PerfParameter) */ {
 public:
  PerfParameter();
  virtual ~PerfParameter();

  PerfParameter(const PerfParameter& from);

  inline PerfParameter& operator=(const PerfParameter& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PerfParameter(PerfParameter&& from) noexcept
    : PerfParameter() {
    *this = ::std::move(from);
  }

  inline PerfParameter& operator=(PerfParameter&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PerfParameter& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PerfParameter* internal_default_instance() {
    return reinterpret_cast<const PerfParameter*>(
               &_PerfParameter_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(PerfParameter* other);
  friend void swap(PerfParameter& a, PerfParameter& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PerfParameter* New() const PROTOBUF_FINAL { return New(NULL); }

  PerfParameter* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PerfParameter& from);
  void MergeFrom(const PerfParameter& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PerfParameter* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  static const int kTypeidFieldNumber = 1;
  ::google::protobuf::uint32 typeid_() const;
  void set_typeid_(::google::protobuf::uint32 value);

  // optional uint32 value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.PerfParameter)
 private:
  void set_has_typeid_();
  void clear_has_typeid_();
  void set_has_name();
  void clear_has_name();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 typeid__;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsPerfParameterImpl();
};
// -------------------------------------------------------------------

class MidwarePerf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MidwarePerf) */ {
 public:
  MidwarePerf();
  virtual ~MidwarePerf();

  MidwarePerf(const MidwarePerf& from);

  inline MidwarePerf& operator=(const MidwarePerf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MidwarePerf(MidwarePerf&& from) noexcept
    : MidwarePerf() {
    *this = ::std::move(from);
  }

  inline MidwarePerf& operator=(MidwarePerf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MidwarePerf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MidwarePerf* internal_default_instance() {
    return reinterpret_cast<const MidwarePerf*>(
               &_MidwarePerf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(MidwarePerf* other);
  friend void swap(MidwarePerf& a, MidwarePerf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MidwarePerf* New() const PROTOBUF_FINAL { return New(NULL); }

  MidwarePerf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MidwarePerf& from);
  void MergeFrom(const MidwarePerf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MidwarePerf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.PerfParameter paralist = 6;
  int paralist_size() const;
  void clear_paralist();
  static const int kParalistFieldNumber = 6;
  const ::mpfmessage::PerfParameter& paralist(int index) const;
  ::mpfmessage::PerfParameter* mutable_paralist(int index);
  ::mpfmessage::PerfParameter* add_paralist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >*
      mutable_paralist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >&
      paralist() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 resid = 1;
  bool has_resid() const;
  void clear_resid();
  static const int kResidFieldNumber = 1;
  ::google::protobuf::uint32 resid() const;
  void set_resid(::google::protobuf::uint32 value);

  // optional uint32 available = 3;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  ::google::protobuf::uint32 available() const;
  void set_available(::google::protobuf::uint32 value);

  // optional uint32 cpu_rate_app = 4;
  bool has_cpu_rate_app() const;
  void clear_cpu_rate_app();
  static const int kCpuRateAppFieldNumber = 4;
  ::google::protobuf::uint32 cpu_rate_app() const;
  void set_cpu_rate_app(::google::protobuf::uint32 value);

  // optional uint32 mem_use_app = 5;
  bool has_mem_use_app() const;
  void clear_mem_use_app();
  static const int kMemUseAppFieldNumber = 5;
  ::google::protobuf::uint32 mem_use_app() const;
  void set_mem_use_app(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MidwarePerf)
 private:
  void set_has_resid();
  void clear_has_resid();
  void set_has_name();
  void clear_has_name();
  void set_has_available();
  void clear_has_available();
  void set_has_cpu_rate_app();
  void clear_has_cpu_rate_app();
  void set_has_mem_use_app();
  void clear_has_mem_use_app();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter > paralist_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 resid_;
  ::google::protobuf::uint32 available_;
  ::google::protobuf::uint32 cpu_rate_app_;
  ::google::protobuf::uint32 mem_use_app_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMidwarePerfImpl();
};
// -------------------------------------------------------------------

class DatabasePerf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DatabasePerf) */ {
 public:
  DatabasePerf();
  virtual ~DatabasePerf();

  DatabasePerf(const DatabasePerf& from);

  inline DatabasePerf& operator=(const DatabasePerf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatabasePerf(DatabasePerf&& from) noexcept
    : DatabasePerf() {
    *this = ::std::move(from);
  }

  inline DatabasePerf& operator=(DatabasePerf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DatabasePerf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatabasePerf* internal_default_instance() {
    return reinterpret_cast<const DatabasePerf*>(
               &_DatabasePerf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(DatabasePerf* other);
  friend void swap(DatabasePerf& a, DatabasePerf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatabasePerf* New() const PROTOBUF_FINAL { return New(NULL); }

  DatabasePerf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DatabasePerf& from);
  void MergeFrom(const DatabasePerf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DatabasePerf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.PerfParameter paralist = 6;
  int paralist_size() const;
  void clear_paralist();
  static const int kParalistFieldNumber = 6;
  const ::mpfmessage::PerfParameter& paralist(int index) const;
  ::mpfmessage::PerfParameter* mutable_paralist(int index);
  ::mpfmessage::PerfParameter* add_paralist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >*
      mutable_paralist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >&
      paralist() const;

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional uint32 resid = 1;
  bool has_resid() const;
  void clear_resid();
  static const int kResidFieldNumber = 1;
  ::google::protobuf::uint32 resid() const;
  void set_resid(::google::protobuf::uint32 value);

  // optional uint32 available = 3;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  ::google::protobuf::uint32 available() const;
  void set_available(::google::protobuf::uint32 value);

  // optional uint32 cpu_rate_app = 4;
  bool has_cpu_rate_app() const;
  void clear_cpu_rate_app();
  static const int kCpuRateAppFieldNumber = 4;
  ::google::protobuf::uint32 cpu_rate_app() const;
  void set_cpu_rate_app(::google::protobuf::uint32 value);

  // optional uint32 mem_use_app = 5;
  bool has_mem_use_app() const;
  void clear_mem_use_app();
  static const int kMemUseAppFieldNumber = 5;
  ::google::protobuf::uint32 mem_use_app() const;
  void set_mem_use_app(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DatabasePerf)
 private:
  void set_has_resid();
  void clear_has_resid();
  void set_has_name();
  void clear_has_name();
  void set_has_available();
  void clear_has_available();
  void set_has_cpu_rate_app();
  void clear_has_cpu_rate_app();
  void set_has_mem_use_app();
  void clear_has_mem_use_app();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter > paralist_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::uint32 resid_;
  ::google::protobuf::uint32 available_;
  ::google::protobuf::uint32 cpu_rate_app_;
  ::google::protobuf::uint32 mem_use_app_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDatabasePerfImpl();
};
// -------------------------------------------------------------------

class IfPerf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.IfPerf) */ {
 public:
  IfPerf();
  virtual ~IfPerf();

  IfPerf(const IfPerf& from);

  inline IfPerf& operator=(const IfPerf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfPerf(IfPerf&& from) noexcept
    : IfPerf() {
    *this = ::std::move(from);
  }

  inline IfPerf& operator=(IfPerf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IfPerf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfPerf* internal_default_instance() {
    return reinterpret_cast<const IfPerf*>(
               &_IfPerf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(IfPerf* other);
  friend void swap(IfPerf& a, IfPerf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfPerf* New() const PROTOBUF_FINAL { return New(NULL); }

  IfPerf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IfPerf& from);
  void MergeFrom(const IfPerf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IfPerf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string desc = 2;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 2;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional uint32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional uint32 rate = 5;
  bool has_rate() const;
  void clear_rate();
  static const int kRateFieldNumber = 5;
  ::google::protobuf::uint32 rate() const;
  void set_rate(::google::protobuf::uint32 value);

  // optional uint32 byte_in = 6;
  bool has_byte_in() const;
  void clear_byte_in();
  static const int kByteInFieldNumber = 6;
  ::google::protobuf::uint32 byte_in() const;
  void set_byte_in(::google::protobuf::uint32 value);

  // optional uint32 byte_out = 7;
  bool has_byte_out() const;
  void clear_byte_out();
  static const int kByteOutFieldNumber = 7;
  ::google::protobuf::uint32 byte_out() const;
  void set_byte_out(::google::protobuf::uint32 value);

  // optional uint32 error_in = 8;
  bool has_error_in() const;
  void clear_error_in();
  static const int kErrorInFieldNumber = 8;
  ::google::protobuf::uint32 error_in() const;
  void set_error_in(::google::protobuf::uint32 value);

  // optional uint32 error_out = 9;
  bool has_error_out() const;
  void clear_error_out();
  static const int kErrorOutFieldNumber = 9;
  ::google::protobuf::uint32 error_out() const;
  void set_error_out(::google::protobuf::uint32 value);

  // optional uint32 discard_in = 10;
  bool has_discard_in() const;
  void clear_discard_in();
  static const int kDiscardInFieldNumber = 10;
  ::google::protobuf::uint32 discard_in() const;
  void set_discard_in(::google::protobuf::uint32 value);

  // optional uint32 discard_out = 11;
  bool has_discard_out() const;
  void clear_discard_out();
  static const int kDiscardOutFieldNumber = 11;
  ::google::protobuf::uint32 discard_out() const;
  void set_discard_out(::google::protobuf::uint32 value);

  // optional .mpfmessage.Status oper_status = 3;
  bool has_oper_status() const;
  void clear_oper_status();
  static const int kOperStatusFieldNumber = 3;
  ::mpfmessage::Status oper_status() const;
  void set_oper_status(::mpfmessage::Status value);

  // optional .mpfmessage.Status admin_status = 4;
  bool has_admin_status() const;
  void clear_admin_status();
  static const int kAdminStatusFieldNumber = 4;
  ::mpfmessage::Status admin_status() const;
  void set_admin_status(::mpfmessage::Status value);

  // @@protoc_insertion_point(class_scope:mpfmessage.IfPerf)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_desc();
  void clear_has_desc();
  void set_has_oper_status();
  void clear_has_oper_status();
  void set_has_admin_status();
  void clear_has_admin_status();
  void set_has_rate();
  void clear_has_rate();
  void set_has_byte_in();
  void clear_has_byte_in();
  void set_has_byte_out();
  void clear_has_byte_out();
  void set_has_error_in();
  void clear_has_error_in();
  void set_has_error_out();
  void clear_has_error_out();
  void set_has_discard_in();
  void clear_has_discard_in();
  void set_has_discard_out();
  void clear_has_discard_out();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 rate_;
  ::google::protobuf::uint32 byte_in_;
  ::google::protobuf::uint32 byte_out_;
  ::google::protobuf::uint32 error_in_;
  ::google::protobuf::uint32 error_out_;
  ::google::protobuf::uint32 discard_in_;
  ::google::protobuf::uint32 discard_out_;
  int oper_status_;
  int admin_status_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsIfPerfImpl();
};
// -------------------------------------------------------------------

class MsgTopoDiscoveryResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgTopoDiscoveryResp) */ {
 public:
  MsgTopoDiscoveryResp();
  virtual ~MsgTopoDiscoveryResp();

  MsgTopoDiscoveryResp(const MsgTopoDiscoveryResp& from);

  inline MsgTopoDiscoveryResp& operator=(const MsgTopoDiscoveryResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTopoDiscoveryResp(MsgTopoDiscoveryResp&& from) noexcept
    : MsgTopoDiscoveryResp() {
    *this = ::std::move(from);
  }

  inline MsgTopoDiscoveryResp& operator=(MsgTopoDiscoveryResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTopoDiscoveryResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTopoDiscoveryResp* internal_default_instance() {
    return reinterpret_cast<const MsgTopoDiscoveryResp*>(
               &_MsgTopoDiscoveryResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(MsgTopoDiscoveryResp* other);
  friend void swap(MsgTopoDiscoveryResp& a, MsgTopoDiscoveryResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTopoDiscoveryResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTopoDiscoveryResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTopoDiscoveryResp& from);
  void MergeFrom(const MsgTopoDiscoveryResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTopoDiscoveryResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgTopoDiscoveryResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgTopoDiscoveryRespImpl();
};
// -------------------------------------------------------------------

class DiscoveredDev : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DiscoveredDev) */ {
 public:
  DiscoveredDev();
  virtual ~DiscoveredDev();

  DiscoveredDev(const DiscoveredDev& from);

  inline DiscoveredDev& operator=(const DiscoveredDev& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DiscoveredDev(DiscoveredDev&& from) noexcept
    : DiscoveredDev() {
    *this = ::std::move(from);
  }

  inline DiscoveredDev& operator=(DiscoveredDev&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscoveredDev& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DiscoveredDev* internal_default_instance() {
    return reinterpret_cast<const DiscoveredDev*>(
               &_DiscoveredDev_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(DiscoveredDev* other);
  friend void swap(DiscoveredDev& a, DiscoveredDev& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DiscoveredDev* New() const PROTOBUF_FINAL { return New(NULL); }

  DiscoveredDev* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DiscoveredDev& from);
  void MergeFrom(const DiscoveredDev& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DiscoveredDev* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.IfBaseInfo if_base_info = 6;
  int if_base_info_size() const;
  void clear_if_base_info();
  static const int kIfBaseInfoFieldNumber = 6;
  const ::mpfmessage::IfBaseInfo& if_base_info(int index) const;
  ::mpfmessage::IfBaseInfo* mutable_if_base_info(int index);
  ::mpfmessage::IfBaseInfo* add_if_base_info();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >*
      mutable_if_base_info();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >&
      if_base_info() const;

  // optional string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional string detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional .mpfmessage.NetDevBaseInfo dev_base_info = 4;
  bool has_dev_base_info() const;
  void clear_dev_base_info();
  static const int kDevBaseInfoFieldNumber = 4;
  const ::mpfmessage::NetDevBaseInfo& dev_base_info() const;
  ::mpfmessage::NetDevBaseInfo* release_dev_base_info();
  ::mpfmessage::NetDevBaseInfo* mutable_dev_base_info();
  void set_allocated_dev_base_info(::mpfmessage::NetDevBaseInfo* dev_base_info);

  // optional .mpfmessage.HostBaseInfo host_base_info = 5;
  bool has_host_base_info() const;
  void clear_host_base_info();
  static const int kHostBaseInfoFieldNumber = 5;
  const ::mpfmessage::HostBaseInfo& host_base_info() const;
  ::mpfmessage::HostBaseInfo* release_host_base_info();
  ::mpfmessage::HostBaseInfo* mutable_host_base_info();
  void set_allocated_host_base_info(::mpfmessage::HostBaseInfo* host_base_info);

  // optional uint32 resultcode = 2;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 2;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DiscoveredDev)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();
  void set_has_dev_base_info();
  void clear_has_dev_base_info();
  void set_has_host_base_info();
  void clear_has_host_base_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo > if_base_info_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::mpfmessage::NetDevBaseInfo* dev_base_info_;
  ::mpfmessage::HostBaseInfo* host_base_info_;
  ::google::protobuf::uint32 resultcode_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDiscoveredDevImpl();
};
// -------------------------------------------------------------------

class MsgTopoDiscoveryNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgTopoDiscoveryNotify) */ {
 public:
  MsgTopoDiscoveryNotify();
  virtual ~MsgTopoDiscoveryNotify();

  MsgTopoDiscoveryNotify(const MsgTopoDiscoveryNotify& from);

  inline MsgTopoDiscoveryNotify& operator=(const MsgTopoDiscoveryNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTopoDiscoveryNotify(MsgTopoDiscoveryNotify&& from) noexcept
    : MsgTopoDiscoveryNotify() {
    *this = ::std::move(from);
  }

  inline MsgTopoDiscoveryNotify& operator=(MsgTopoDiscoveryNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTopoDiscoveryNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTopoDiscoveryNotify* internal_default_instance() {
    return reinterpret_cast<const MsgTopoDiscoveryNotify*>(
               &_MsgTopoDiscoveryNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(MsgTopoDiscoveryNotify* other);
  friend void swap(MsgTopoDiscoveryNotify& a, MsgTopoDiscoveryNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTopoDiscoveryNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTopoDiscoveryNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTopoDiscoveryNotify& from);
  void MergeFrom(const MsgTopoDiscoveryNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTopoDiscoveryNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.TopoNodeInfo topo_node_info = 1;
  int topo_node_info_size() const;
  void clear_topo_node_info();
  static const int kTopoNodeInfoFieldNumber = 1;
  const ::mpfmessage::TopoNodeInfo& topo_node_info(int index) const;
  ::mpfmessage::TopoNodeInfo* mutable_topo_node_info(int index);
  ::mpfmessage::TopoNodeInfo* add_topo_node_info();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoNodeInfo >*
      mutable_topo_node_info();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoNodeInfo >&
      topo_node_info() const;

  // repeated .mpfmessage.TopoLinkInfo topo_link_info = 2;
  int topo_link_info_size() const;
  void clear_topo_link_info();
  static const int kTopoLinkInfoFieldNumber = 2;
  const ::mpfmessage::TopoLinkInfo& topo_link_info(int index) const;
  ::mpfmessage::TopoLinkInfo* mutable_topo_link_info(int index);
  ::mpfmessage::TopoLinkInfo* add_topo_link_info();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoLinkInfo >*
      mutable_topo_link_info();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoLinkInfo >&
      topo_link_info() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgTopoDiscoveryNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoNodeInfo > topo_node_info_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoLinkInfo > topo_link_info_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgTopoDiscoveryNotifyImpl();
};
// -------------------------------------------------------------------

class ResSynInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ResSynInfo) */ {
 public:
  ResSynInfo();
  virtual ~ResSynInfo();

  ResSynInfo(const ResSynInfo& from);

  inline ResSynInfo& operator=(const ResSynInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResSynInfo(ResSynInfo&& from) noexcept
    : ResSynInfo() {
    *this = ::std::move(from);
  }

  inline ResSynInfo& operator=(ResSynInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResSynInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResSynInfo* internal_default_instance() {
    return reinterpret_cast<const ResSynInfo*>(
               &_ResSynInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(ResSynInfo* other);
  friend void swap(ResSynInfo& a, ResSynInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResSynInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  ResSynInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResSynInfo& from);
  void MergeFrom(const ResSynInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResSynInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.IfResInfo if_list = 6;
  int if_list_size() const;
  void clear_if_list();
  static const int kIfListFieldNumber = 6;
  const ::mpfmessage::IfResInfo& if_list(int index) const;
  ::mpfmessage::IfResInfo* mutable_if_list(int index);
  ::mpfmessage::IfResInfo* add_if_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfResInfo >*
      mutable_if_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfResInfo >&
      if_list() const;

  // optional .mpfmessage.SnmpInfo snmp_info = 3;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 3;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional .mpfmessage.TelnetPara telentPara = 4;
  bool has_telentpara() const;
  void clear_telentpara();
  static const int kTelentParaFieldNumber = 4;
  const ::mpfmessage::TelnetPara& telentpara() const;
  ::mpfmessage::TelnetPara* release_telentpara();
  ::mpfmessage::TelnetPara* mutable_telentpara();
  void set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara);

  // optional .mpfmessage.SshPara sshPara = 5;
  bool has_sshpara() const;
  void clear_sshpara();
  static const int kSshParaFieldNumber = 5;
  const ::mpfmessage::SshPara& sshpara() const;
  ::mpfmessage::SshPara* release_sshpara();
  ::mpfmessage::SshPara* mutable_sshpara();
  void set_allocated_sshpara(::mpfmessage::SshPara* sshpara);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional .mpfmessage.ResType res_type = 2;
  bool has_res_type() const;
  void clear_res_type();
  static const int kResTypeFieldNumber = 2;
  ::mpfmessage::ResType res_type() const;
  void set_res_type(::mpfmessage::ResType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ResSynInfo)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_res_type();
  void clear_has_res_type();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_telentpara();
  void clear_has_telentpara();
  void set_has_sshpara();
  void clear_has_sshpara();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfResInfo > if_list_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::mpfmessage::TelnetPara* telentpara_;
  ::mpfmessage::SshPara* sshpara_;
  ::google::protobuf::uint32 res_id_;
  int res_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsResSynInfoImpl();
};
// -------------------------------------------------------------------

class RespAddr : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.RespAddr) */ {
 public:
  RespAddr();
  virtual ~RespAddr();

  RespAddr(const RespAddr& from);

  inline RespAddr& operator=(const RespAddr& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RespAddr(RespAddr&& from) noexcept
    : RespAddr() {
    *this = ::std::move(from);
  }

  inline RespAddr& operator=(RespAddr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RespAddr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RespAddr* internal_default_instance() {
    return reinterpret_cast<const RespAddr*>(
               &_RespAddr_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(RespAddr* other);
  friend void swap(RespAddr& a, RespAddr& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RespAddr* New() const PROTOBUF_FINAL { return New(NULL); }

  RespAddr* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RespAddr& from);
  void MergeFrom(const RespAddr& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RespAddr* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // optional uint32 port = 2;
  bool has_port() const;
  void clear_port();
  static const int kPortFieldNumber = 2;
  ::google::protobuf::uint32 port() const;
  void set_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.RespAddr)
 private:
  void set_has_addr();
  void clear_has_addr();
  void set_has_port();
  void clear_has_port();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::uint32 port_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsRespAddrImpl();
};
// -------------------------------------------------------------------

class MsgResSynReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgResSynReq) */ {
 public:
  MsgResSynReq();
  virtual ~MsgResSynReq();

  MsgResSynReq(const MsgResSynReq& from);

  inline MsgResSynReq& operator=(const MsgResSynReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgResSynReq(MsgResSynReq&& from) noexcept
    : MsgResSynReq() {
    *this = ::std::move(from);
  }

  inline MsgResSynReq& operator=(MsgResSynReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResSynReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgResSynReq* internal_default_instance() {
    return reinterpret_cast<const MsgResSynReq*>(
               &_MsgResSynReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(MsgResSynReq* other);
  friend void swap(MsgResSynReq& a, MsgResSynReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgResSynReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgResSynReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgResSynReq& from);
  void MergeFrom(const MsgResSynReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgResSynReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.ResSynInfo res_list = 1;
  int res_list_size() const;
  void clear_res_list();
  static const int kResListFieldNumber = 1;
  const ::mpfmessage::ResSynInfo& res_list(int index) const;
  ::mpfmessage::ResSynInfo* mutable_res_list(int index);
  ::mpfmessage::ResSynInfo* add_res_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >*
      mutable_res_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >&
      res_list() const;

  // optional .mpfmessage.RespAddr resp_addr = 2;
  bool has_resp_addr() const;
  void clear_resp_addr();
  static const int kRespAddrFieldNumber = 2;
  const ::mpfmessage::RespAddr& resp_addr() const;
  ::mpfmessage::RespAddr* release_resp_addr();
  ::mpfmessage::RespAddr* mutable_resp_addr();
  void set_allocated_resp_addr(::mpfmessage::RespAddr* resp_addr);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgResSynReq)
 private:
  void set_has_resp_addr();
  void clear_has_resp_addr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo > res_list_;
  ::mpfmessage::RespAddr* resp_addr_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgResSynReqImpl();
};
// -------------------------------------------------------------------

class MsgResSynResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgResSynResp) */ {
 public:
  MsgResSynResp();
  virtual ~MsgResSynResp();

  MsgResSynResp(const MsgResSynResp& from);

  inline MsgResSynResp& operator=(const MsgResSynResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgResSynResp(MsgResSynResp&& from) noexcept
    : MsgResSynResp() {
    *this = ::std::move(from);
  }

  inline MsgResSynResp& operator=(MsgResSynResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResSynResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgResSynResp* internal_default_instance() {
    return reinterpret_cast<const MsgResSynResp*>(
               &_MsgResSynResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(MsgResSynResp* other);
  friend void swap(MsgResSynResp& a, MsgResSynResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgResSynResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgResSynResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgResSynResp& from);
  void MergeFrom(const MsgResSynResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgResSynResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgResSynResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgResSynRespImpl();
};
// -------------------------------------------------------------------

class ResSynResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ResSynResult) */ {
 public:
  ResSynResult();
  virtual ~ResSynResult();

  ResSynResult(const ResSynResult& from);

  inline ResSynResult& operator=(const ResSynResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResSynResult(ResSynResult&& from) noexcept
    : ResSynResult() {
    *this = ::std::move(from);
  }

  inline ResSynResult& operator=(ResSynResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResSynResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResSynResult* internal_default_instance() {
    return reinterpret_cast<const ResSynResult*>(
               &_ResSynResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(ResSynResult* other);
  friend void swap(ResSynResult& a, ResSynResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResSynResult* New() const PROTOBUF_FINAL { return New(NULL); }

  ResSynResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ResSynResult& from);
  void MergeFrom(const ResSynResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ResSynResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.IfBaseInfo if_base_info = 7;
  int if_base_info_size() const;
  void clear_if_base_info();
  static const int kIfBaseInfoFieldNumber = 7;
  const ::mpfmessage::IfBaseInfo& if_base_info(int index) const;
  ::mpfmessage::IfBaseInfo* mutable_if_base_info(int index);
  ::mpfmessage::IfBaseInfo* add_if_base_info();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >*
      mutable_if_base_info();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >&
      if_base_info() const;

  // optional string detail = 4;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 4;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional .mpfmessage.NetDevBaseInfo dev_base_info = 5;
  bool has_dev_base_info() const;
  void clear_dev_base_info();
  static const int kDevBaseInfoFieldNumber = 5;
  const ::mpfmessage::NetDevBaseInfo& dev_base_info() const;
  ::mpfmessage::NetDevBaseInfo* release_dev_base_info();
  ::mpfmessage::NetDevBaseInfo* mutable_dev_base_info();
  void set_allocated_dev_base_info(::mpfmessage::NetDevBaseInfo* dev_base_info);

  // optional .mpfmessage.HostBaseInfo host_base_info = 6;
  bool has_host_base_info() const;
  void clear_host_base_info();
  static const int kHostBaseInfoFieldNumber = 6;
  const ::mpfmessage::HostBaseInfo& host_base_info() const;
  ::mpfmessage::HostBaseInfo* release_host_base_info();
  ::mpfmessage::HostBaseInfo* mutable_host_base_info();
  void set_allocated_host_base_info(::mpfmessage::HostBaseInfo* host_base_info);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional uint32 resultcode = 3;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 3;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // optional .mpfmessage.ResType res_type = 2;
  bool has_res_type() const;
  void clear_res_type();
  static const int kResTypeFieldNumber = 2;
  ::mpfmessage::ResType res_type() const;
  void set_res_type(::mpfmessage::ResType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ResSynResult)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_res_type();
  void clear_has_res_type();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();
  void set_has_dev_base_info();
  void clear_has_dev_base_info();
  void set_has_host_base_info();
  void clear_has_host_base_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo > if_base_info_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::mpfmessage::NetDevBaseInfo* dev_base_info_;
  ::mpfmessage::HostBaseInfo* host_base_info_;
  ::google::protobuf::uint32 res_id_;
  ::google::protobuf::uint32 resultcode_;
  int res_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsResSynResultImpl();
};
// -------------------------------------------------------------------

class MsgResSynNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgResSynNotify) */ {
 public:
  MsgResSynNotify();
  virtual ~MsgResSynNotify();

  MsgResSynNotify(const MsgResSynNotify& from);

  inline MsgResSynNotify& operator=(const MsgResSynNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgResSynNotify(MsgResSynNotify&& from) noexcept
    : MsgResSynNotify() {
    *this = ::std::move(from);
  }

  inline MsgResSynNotify& operator=(MsgResSynNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgResSynNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgResSynNotify* internal_default_instance() {
    return reinterpret_cast<const MsgResSynNotify*>(
               &_MsgResSynNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(MsgResSynNotify* other);
  friend void swap(MsgResSynNotify& a, MsgResSynNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgResSynNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgResSynNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgResSynNotify& from);
  void MergeFrom(const MsgResSynNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgResSynNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.ResSynResult res_syn_data = 1;
  int res_syn_data_size() const;
  void clear_res_syn_data();
  static const int kResSynDataFieldNumber = 1;
  const ::mpfmessage::ResSynResult& res_syn_data(int index) const;
  ::mpfmessage::ResSynResult* mutable_res_syn_data(int index);
  ::mpfmessage::ResSynResult* add_res_syn_data();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynResult >*
      mutable_res_syn_data();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynResult >&
      res_syn_data() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgResSynNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynResult > res_syn_data_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgResSynNotifyImpl();
};
// -------------------------------------------------------------------

class MsgDevPerfCollectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgDevPerfCollectReq) */ {
 public:
  MsgDevPerfCollectReq();
  virtual ~MsgDevPerfCollectReq();

  MsgDevPerfCollectReq(const MsgDevPerfCollectReq& from);

  inline MsgDevPerfCollectReq& operator=(const MsgDevPerfCollectReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDevPerfCollectReq(MsgDevPerfCollectReq&& from) noexcept
    : MsgDevPerfCollectReq() {
    *this = ::std::move(from);
  }

  inline MsgDevPerfCollectReq& operator=(MsgDevPerfCollectReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDevPerfCollectReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgDevPerfCollectReq* internal_default_instance() {
    return reinterpret_cast<const MsgDevPerfCollectReq*>(
               &_MsgDevPerfCollectReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(MsgDevPerfCollectReq* other);
  friend void swap(MsgDevPerfCollectReq& a, MsgDevPerfCollectReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDevPerfCollectReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDevPerfCollectReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgDevPerfCollectReq& from);
  void MergeFrom(const MsgDevPerfCollectReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDevPerfCollectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.ResSynInfo res_list = 1;
  int res_list_size() const;
  void clear_res_list();
  static const int kResListFieldNumber = 1;
  const ::mpfmessage::ResSynInfo& res_list(int index) const;
  ::mpfmessage::ResSynInfo* mutable_res_list(int index);
  ::mpfmessage::ResSynInfo* add_res_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >*
      mutable_res_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >&
      res_list() const;

  // optional uint32 collect_time = 2;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 2;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgDevPerfCollectReq)
 private:
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo > res_list_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgDevPerfCollectReqImpl();
};
// -------------------------------------------------------------------

class MsgDevPerfCollectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgDevPerfCollectResp) */ {
 public:
  MsgDevPerfCollectResp();
  virtual ~MsgDevPerfCollectResp();

  MsgDevPerfCollectResp(const MsgDevPerfCollectResp& from);

  inline MsgDevPerfCollectResp& operator=(const MsgDevPerfCollectResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDevPerfCollectResp(MsgDevPerfCollectResp&& from) noexcept
    : MsgDevPerfCollectResp() {
    *this = ::std::move(from);
  }

  inline MsgDevPerfCollectResp& operator=(MsgDevPerfCollectResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDevPerfCollectResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgDevPerfCollectResp* internal_default_instance() {
    return reinterpret_cast<const MsgDevPerfCollectResp*>(
               &_MsgDevPerfCollectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(MsgDevPerfCollectResp* other);
  friend void swap(MsgDevPerfCollectResp& a, MsgDevPerfCollectResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDevPerfCollectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDevPerfCollectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgDevPerfCollectResp& from);
  void MergeFrom(const MsgDevPerfCollectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDevPerfCollectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgDevPerfCollectResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgDevPerfCollectRespImpl();
};
// -------------------------------------------------------------------

class MsgGetHostProcListReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetHostProcListReq) */ {
 public:
  MsgGetHostProcListReq();
  virtual ~MsgGetHostProcListReq();

  MsgGetHostProcListReq(const MsgGetHostProcListReq& from);

  inline MsgGetHostProcListReq& operator=(const MsgGetHostProcListReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetHostProcListReq(MsgGetHostProcListReq&& from) noexcept
    : MsgGetHostProcListReq() {
    *this = ::std::move(from);
  }

  inline MsgGetHostProcListReq& operator=(MsgGetHostProcListReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetHostProcListReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetHostProcListReq* internal_default_instance() {
    return reinterpret_cast<const MsgGetHostProcListReq*>(
               &_MsgGetHostProcListReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(MsgGetHostProcListReq* other);
  friend void swap(MsgGetHostProcListReq& a, MsgGetHostProcListReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetHostProcListReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetHostProcListReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetHostProcListReq& from);
  void MergeFrom(const MsgGetHostProcListReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetHostProcListReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 2;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 2;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional .mpfmessage.TelnetPara telentPara = 3;
  bool has_telentpara() const;
  void clear_telentpara();
  static const int kTelentParaFieldNumber = 3;
  const ::mpfmessage::TelnetPara& telentpara() const;
  ::mpfmessage::TelnetPara* release_telentpara();
  ::mpfmessage::TelnetPara* mutable_telentpara();
  void set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara);

  // optional .mpfmessage.SshPara sshPara = 4;
  bool has_sshpara() const;
  void clear_sshpara();
  static const int kSshParaFieldNumber = 4;
  const ::mpfmessage::SshPara& sshpara() const;
  ::mpfmessage::SshPara* release_sshpara();
  ::mpfmessage::SshPara* mutable_sshpara();
  void set_allocated_sshpara(::mpfmessage::SshPara* sshpara);

  // optional uint32 host_res_id = 1;
  bool has_host_res_id() const;
  void clear_host_res_id();
  static const int kHostResIdFieldNumber = 1;
  ::google::protobuf::uint32 host_res_id() const;
  void set_host_res_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetHostProcListReq)
 private:
  void set_has_host_res_id();
  void clear_has_host_res_id();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_telentpara();
  void clear_has_telentpara();
  void set_has_sshpara();
  void clear_has_sshpara();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::mpfmessage::TelnetPara* telentpara_;
  ::mpfmessage::SshPara* sshpara_;
  ::google::protobuf::uint32 host_res_id_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetHostProcListReqImpl();
};
// -------------------------------------------------------------------

class MsgGetHostProcListResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetHostProcListResp) */ {
 public:
  MsgGetHostProcListResp();
  virtual ~MsgGetHostProcListResp();

  MsgGetHostProcListResp(const MsgGetHostProcListResp& from);

  inline MsgGetHostProcListResp& operator=(const MsgGetHostProcListResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetHostProcListResp(MsgGetHostProcListResp&& from) noexcept
    : MsgGetHostProcListResp() {
    *this = ::std::move(from);
  }

  inline MsgGetHostProcListResp& operator=(MsgGetHostProcListResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetHostProcListResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetHostProcListResp* internal_default_instance() {
    return reinterpret_cast<const MsgGetHostProcListResp*>(
               &_MsgGetHostProcListResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(MsgGetHostProcListResp* other);
  friend void swap(MsgGetHostProcListResp& a, MsgGetHostProcListResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetHostProcListResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetHostProcListResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetHostProcListResp& from);
  void MergeFrom(const MsgGetHostProcListResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetHostProcListResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.SoftwareInfo softwarelist = 4;
  int softwarelist_size() const;
  void clear_softwarelist();
  static const int kSoftwarelistFieldNumber = 4;
  const ::mpfmessage::SoftwareInfo& softwarelist(int index) const;
  ::mpfmessage::SoftwareInfo* mutable_softwarelist(int index);
  ::mpfmessage::SoftwareInfo* add_softwarelist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SoftwareInfo >*
      mutable_softwarelist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SoftwareInfo >&
      softwarelist() const;

  // repeated .mpfmessage.ProcessInfo proclist = 5;
  int proclist_size() const;
  void clear_proclist();
  static const int kProclistFieldNumber = 5;
  const ::mpfmessage::ProcessInfo& proclist(int index) const;
  ::mpfmessage::ProcessInfo* mutable_proclist(int index);
  ::mpfmessage::ProcessInfo* add_proclist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessInfo >*
      mutable_proclist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessInfo >&
      proclist() const;

  // optional string detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional uint32 host_res_id = 1;
  bool has_host_res_id() const;
  void clear_host_res_id();
  static const int kHostResIdFieldNumber = 1;
  ::google::protobuf::uint32 host_res_id() const;
  void set_host_res_id(::google::protobuf::uint32 value);

  // optional uint32 resultcode = 2;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 2;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // optional uint32 collect_time = 6;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 6;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetHostProcListResp)
 private:
  void set_has_host_res_id();
  void clear_has_host_res_id();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SoftwareInfo > softwarelist_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessInfo > proclist_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::uint32 host_res_id_;
  ::google::protobuf::uint32 resultcode_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetHostProcListRespImpl();
};
// -------------------------------------------------------------------

class MsgGetHostFileSystemListReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetHostFileSystemListReq) */ {
 public:
  MsgGetHostFileSystemListReq();
  virtual ~MsgGetHostFileSystemListReq();

  MsgGetHostFileSystemListReq(const MsgGetHostFileSystemListReq& from);

  inline MsgGetHostFileSystemListReq& operator=(const MsgGetHostFileSystemListReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetHostFileSystemListReq(MsgGetHostFileSystemListReq&& from) noexcept
    : MsgGetHostFileSystemListReq() {
    *this = ::std::move(from);
  }

  inline MsgGetHostFileSystemListReq& operator=(MsgGetHostFileSystemListReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetHostFileSystemListReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetHostFileSystemListReq* internal_default_instance() {
    return reinterpret_cast<const MsgGetHostFileSystemListReq*>(
               &_MsgGetHostFileSystemListReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(MsgGetHostFileSystemListReq* other);
  friend void swap(MsgGetHostFileSystemListReq& a, MsgGetHostFileSystemListReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetHostFileSystemListReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetHostFileSystemListReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetHostFileSystemListReq& from);
  void MergeFrom(const MsgGetHostFileSystemListReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetHostFileSystemListReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 2;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 2;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional .mpfmessage.TelnetPara telentPara = 3;
  bool has_telentpara() const;
  void clear_telentpara();
  static const int kTelentParaFieldNumber = 3;
  const ::mpfmessage::TelnetPara& telentpara() const;
  ::mpfmessage::TelnetPara* release_telentpara();
  ::mpfmessage::TelnetPara* mutable_telentpara();
  void set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara);

  // optional .mpfmessage.SshPara sshPara = 4;
  bool has_sshpara() const;
  void clear_sshpara();
  static const int kSshParaFieldNumber = 4;
  const ::mpfmessage::SshPara& sshpara() const;
  ::mpfmessage::SshPara* release_sshpara();
  ::mpfmessage::SshPara* mutable_sshpara();
  void set_allocated_sshpara(::mpfmessage::SshPara* sshpara);

  // optional uint32 host_res_id = 1;
  bool has_host_res_id() const;
  void clear_host_res_id();
  static const int kHostResIdFieldNumber = 1;
  ::google::protobuf::uint32 host_res_id() const;
  void set_host_res_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetHostFileSystemListReq)
 private:
  void set_has_host_res_id();
  void clear_has_host_res_id();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_telentpara();
  void clear_has_telentpara();
  void set_has_sshpara();
  void clear_has_sshpara();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::mpfmessage::TelnetPara* telentpara_;
  ::mpfmessage::SshPara* sshpara_;
  ::google::protobuf::uint32 host_res_id_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetHostFileSystemListReqImpl();
};
// -------------------------------------------------------------------

class MsgGetHostFileSystemListResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetHostFileSystemListResp) */ {
 public:
  MsgGetHostFileSystemListResp();
  virtual ~MsgGetHostFileSystemListResp();

  MsgGetHostFileSystemListResp(const MsgGetHostFileSystemListResp& from);

  inline MsgGetHostFileSystemListResp& operator=(const MsgGetHostFileSystemListResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetHostFileSystemListResp(MsgGetHostFileSystemListResp&& from) noexcept
    : MsgGetHostFileSystemListResp() {
    *this = ::std::move(from);
  }

  inline MsgGetHostFileSystemListResp& operator=(MsgGetHostFileSystemListResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetHostFileSystemListResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetHostFileSystemListResp* internal_default_instance() {
    return reinterpret_cast<const MsgGetHostFileSystemListResp*>(
               &_MsgGetHostFileSystemListResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(MsgGetHostFileSystemListResp* other);
  friend void swap(MsgGetHostFileSystemListResp& a, MsgGetHostFileSystemListResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetHostFileSystemListResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetHostFileSystemListResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetHostFileSystemListResp& from);
  void MergeFrom(const MsgGetHostFileSystemListResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetHostFileSystemListResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.PartitionInfo partiList = 4;
  int partilist_size() const;
  void clear_partilist();
  static const int kPartiListFieldNumber = 4;
  const ::mpfmessage::PartitionInfo& partilist(int index) const;
  ::mpfmessage::PartitionInfo* mutable_partilist(int index);
  ::mpfmessage::PartitionInfo* add_partilist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >*
      mutable_partilist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >&
      partilist() const;

  // optional string detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional uint32 host_res_id = 1;
  bool has_host_res_id() const;
  void clear_host_res_id();
  static const int kHostResIdFieldNumber = 1;
  ::google::protobuf::uint32 host_res_id() const;
  void set_host_res_id(::google::protobuf::uint32 value);

  // optional uint32 resultcode = 2;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 2;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // optional uint32 collect_time = 5;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 5;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetHostFileSystemListResp)
 private:
  void set_has_host_res_id();
  void clear_has_host_res_id();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo > partilist_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::uint32 host_res_id_;
  ::google::protobuf::uint32 resultcode_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetHostFileSystemListRespImpl();
};
// -------------------------------------------------------------------

class DBResInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DBResInfo) */ {
 public:
  DBResInfo();
  virtual ~DBResInfo();

  DBResInfo(const DBResInfo& from);

  inline DBResInfo& operator=(const DBResInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DBResInfo(DBResInfo&& from) noexcept
    : DBResInfo() {
    *this = ::std::move(from);
  }

  inline DBResInfo& operator=(DBResInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DBResInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DBResInfo* internal_default_instance() {
    return reinterpret_cast<const DBResInfo*>(
               &_DBResInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(DBResInfo* other);
  friend void swap(DBResInfo& a, DBResInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DBResInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  DBResInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DBResInfo& from);
  void MergeFrom(const DBResInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DBResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 2;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 2;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional .mpfmessage.DbLoginPara db_conn_pare = 3;
  bool has_db_conn_pare() const;
  void clear_db_conn_pare();
  static const int kDbConnPareFieldNumber = 3;
  const ::mpfmessage::DbLoginPara& db_conn_pare() const;
  ::mpfmessage::DbLoginPara* release_db_conn_pare();
  ::mpfmessage::DbLoginPara* mutable_db_conn_pare();
  void set_allocated_db_conn_pare(::mpfmessage::DbLoginPara* db_conn_pare);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DBResInfo)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_db_conn_pare();
  void clear_has_db_conn_pare();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::mpfmessage::DbLoginPara* db_conn_pare_;
  ::google::protobuf::uint32 res_id_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDBResInfoImpl();
};
// -------------------------------------------------------------------

class MsgDBPerfCollectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgDBPerfCollectReq) */ {
 public:
  MsgDBPerfCollectReq();
  virtual ~MsgDBPerfCollectReq();

  MsgDBPerfCollectReq(const MsgDBPerfCollectReq& from);

  inline MsgDBPerfCollectReq& operator=(const MsgDBPerfCollectReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDBPerfCollectReq(MsgDBPerfCollectReq&& from) noexcept
    : MsgDBPerfCollectReq() {
    *this = ::std::move(from);
  }

  inline MsgDBPerfCollectReq& operator=(MsgDBPerfCollectReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDBPerfCollectReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgDBPerfCollectReq* internal_default_instance() {
    return reinterpret_cast<const MsgDBPerfCollectReq*>(
               &_MsgDBPerfCollectReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(MsgDBPerfCollectReq* other);
  friend void swap(MsgDBPerfCollectReq& a, MsgDBPerfCollectReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDBPerfCollectReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDBPerfCollectReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgDBPerfCollectReq& from);
  void MergeFrom(const MsgDBPerfCollectReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDBPerfCollectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.DBResInfo dbreslist = 1;
  int dbreslist_size() const;
  void clear_dbreslist();
  static const int kDbreslistFieldNumber = 1;
  const ::mpfmessage::DBResInfo& dbreslist(int index) const;
  ::mpfmessage::DBResInfo* mutable_dbreslist(int index);
  ::mpfmessage::DBResInfo* add_dbreslist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DBResInfo >*
      mutable_dbreslist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DBResInfo >&
      dbreslist() const;

  // optional uint32 collect_time = 2;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 2;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgDBPerfCollectReq)
 private:
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DBResInfo > dbreslist_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgDBPerfCollectReqImpl();
};
// -------------------------------------------------------------------

class MsgDBPerfCollectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgDBPerfCollectResp) */ {
 public:
  MsgDBPerfCollectResp();
  virtual ~MsgDBPerfCollectResp();

  MsgDBPerfCollectResp(const MsgDBPerfCollectResp& from);

  inline MsgDBPerfCollectResp& operator=(const MsgDBPerfCollectResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDBPerfCollectResp(MsgDBPerfCollectResp&& from) noexcept
    : MsgDBPerfCollectResp() {
    *this = ::std::move(from);
  }

  inline MsgDBPerfCollectResp& operator=(MsgDBPerfCollectResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDBPerfCollectResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgDBPerfCollectResp* internal_default_instance() {
    return reinterpret_cast<const MsgDBPerfCollectResp*>(
               &_MsgDBPerfCollectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(MsgDBPerfCollectResp* other);
  friend void swap(MsgDBPerfCollectResp& a, MsgDBPerfCollectResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDBPerfCollectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDBPerfCollectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgDBPerfCollectResp& from);
  void MergeFrom(const MsgDBPerfCollectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDBPerfCollectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgDBPerfCollectResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgDBPerfCollectRespImpl();
};
// -------------------------------------------------------------------

class MidwareResInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MidwareResInfo) */ {
 public:
  MidwareResInfo();
  virtual ~MidwareResInfo();

  MidwareResInfo(const MidwareResInfo& from);

  inline MidwareResInfo& operator=(const MidwareResInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MidwareResInfo(MidwareResInfo&& from) noexcept
    : MidwareResInfo() {
    *this = ::std::move(from);
  }

  inline MidwareResInfo& operator=(MidwareResInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MidwareResInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MidwareResInfo* internal_default_instance() {
    return reinterpret_cast<const MidwareResInfo*>(
               &_MidwareResInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(MidwareResInfo* other);
  friend void swap(MidwareResInfo& a, MidwareResInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MidwareResInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  MidwareResInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MidwareResInfo& from);
  void MergeFrom(const MidwareResInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MidwareResInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 2;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 2;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional .mpfmessage.OSTYPE os_type = 3;
  bool has_os_type() const;
  void clear_os_type();
  static const int kOsTypeFieldNumber = 3;
  ::mpfmessage::OSTYPE os_type() const;
  void set_os_type(::mpfmessage::OSTYPE value);

  // optional .mpfmessage.MidwareType mid_type = 4;
  bool has_mid_type() const;
  void clear_mid_type();
  static const int kMidTypeFieldNumber = 4;
  ::mpfmessage::MidwareType mid_type() const;
  void set_mid_type(::mpfmessage::MidwareType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MidwareResInfo)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_os_type();
  void clear_has_os_type();
  void set_has_mid_type();
  void clear_has_mid_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::google::protobuf::uint32 res_id_;
  int os_type_;
  int mid_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMidwareResInfoImpl();
};
// -------------------------------------------------------------------

class MsgMidwarePerfCollectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgMidwarePerfCollectReq) */ {
 public:
  MsgMidwarePerfCollectReq();
  virtual ~MsgMidwarePerfCollectReq();

  MsgMidwarePerfCollectReq(const MsgMidwarePerfCollectReq& from);

  inline MsgMidwarePerfCollectReq& operator=(const MsgMidwarePerfCollectReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgMidwarePerfCollectReq(MsgMidwarePerfCollectReq&& from) noexcept
    : MsgMidwarePerfCollectReq() {
    *this = ::std::move(from);
  }

  inline MsgMidwarePerfCollectReq& operator=(MsgMidwarePerfCollectReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgMidwarePerfCollectReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgMidwarePerfCollectReq* internal_default_instance() {
    return reinterpret_cast<const MsgMidwarePerfCollectReq*>(
               &_MsgMidwarePerfCollectReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(MsgMidwarePerfCollectReq* other);
  friend void swap(MsgMidwarePerfCollectReq& a, MsgMidwarePerfCollectReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgMidwarePerfCollectReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgMidwarePerfCollectReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgMidwarePerfCollectReq& from);
  void MergeFrom(const MsgMidwarePerfCollectReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgMidwarePerfCollectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.MidwareResInfo midreslist = 1;
  int midreslist_size() const;
  void clear_midreslist();
  static const int kMidreslistFieldNumber = 1;
  const ::mpfmessage::MidwareResInfo& midreslist(int index) const;
  ::mpfmessage::MidwareResInfo* mutable_midreslist(int index);
  ::mpfmessage::MidwareResInfo* add_midreslist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::MidwareResInfo >*
      mutable_midreslist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::MidwareResInfo >&
      midreslist() const;

  // optional uint32 collect_time = 2;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 2;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgMidwarePerfCollectReq)
 private:
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::MidwareResInfo > midreslist_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgMidwarePerfCollectReqImpl();
};
// -------------------------------------------------------------------

class MsgMidwarePerfCollectResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgMidwarePerfCollectResp) */ {
 public:
  MsgMidwarePerfCollectResp();
  virtual ~MsgMidwarePerfCollectResp();

  MsgMidwarePerfCollectResp(const MsgMidwarePerfCollectResp& from);

  inline MsgMidwarePerfCollectResp& operator=(const MsgMidwarePerfCollectResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgMidwarePerfCollectResp(MsgMidwarePerfCollectResp&& from) noexcept
    : MsgMidwarePerfCollectResp() {
    *this = ::std::move(from);
  }

  inline MsgMidwarePerfCollectResp& operator=(MsgMidwarePerfCollectResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgMidwarePerfCollectResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgMidwarePerfCollectResp* internal_default_instance() {
    return reinterpret_cast<const MsgMidwarePerfCollectResp*>(
               &_MsgMidwarePerfCollectResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(MsgMidwarePerfCollectResp* other);
  friend void swap(MsgMidwarePerfCollectResp& a, MsgMidwarePerfCollectResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgMidwarePerfCollectResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgMidwarePerfCollectResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgMidwarePerfCollectResp& from);
  void MergeFrom(const MsgMidwarePerfCollectResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgMidwarePerfCollectResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgMidwarePerfCollectResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgMidwarePerfCollectRespImpl();
};
// -------------------------------------------------------------------

class DataSourceId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DataSourceId) */ {
 public:
  DataSourceId();
  virtual ~DataSourceId();

  DataSourceId(const DataSourceId& from);

  inline DataSourceId& operator=(const DataSourceId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataSourceId(DataSourceId&& from) noexcept
    : DataSourceId() {
    *this = ::std::move(from);
  }

  inline DataSourceId& operator=(DataSourceId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSourceId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataSourceId* internal_default_instance() {
    return reinterpret_cast<const DataSourceId*>(
               &_DataSourceId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(DataSourceId* other);
  friend void swap(DataSourceId& a, DataSourceId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataSourceId* New() const PROTOBUF_FINAL { return New(NULL); }

  DataSourceId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataSourceId& from);
  void MergeFrom(const DataSourceId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataSourceId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 3;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 3;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional uint32 device_room_id = 1;
  bool has_device_room_id() const;
  void clear_device_room_id();
  static const int kDeviceRoomIdFieldNumber = 1;
  ::google::protobuf::uint32 device_room_id() const;
  void set_device_room_id(::google::protobuf::uint32 value);

  // optional uint32 res_id = 2;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 2;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DataSourceId)
 private:
  void set_has_device_room_id();
  void clear_has_device_room_id();
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_snmp_info();
  void clear_has_snmp_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::google::protobuf::uint32 device_room_id_;
  ::google::protobuf::uint32 res_id_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDataSourceIdImpl();
};
// -------------------------------------------------------------------

class MsgRoomResSyncReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgRoomResSyncReq) */ {
 public:
  MsgRoomResSyncReq();
  virtual ~MsgRoomResSyncReq();

  MsgRoomResSyncReq(const MsgRoomResSyncReq& from);

  inline MsgRoomResSyncReq& operator=(const MsgRoomResSyncReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgRoomResSyncReq(MsgRoomResSyncReq&& from) noexcept
    : MsgRoomResSyncReq() {
    *this = ::std::move(from);
  }

  inline MsgRoomResSyncReq& operator=(MsgRoomResSyncReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgRoomResSyncReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgRoomResSyncReq* internal_default_instance() {
    return reinterpret_cast<const MsgRoomResSyncReq*>(
               &_MsgRoomResSyncReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(MsgRoomResSyncReq* other);
  friend void swap(MsgRoomResSyncReq& a, MsgRoomResSyncReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgRoomResSyncReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgRoomResSyncReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgRoomResSyncReq& from);
  void MergeFrom(const MsgRoomResSyncReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgRoomResSyncReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.DataSourceId ds_list = 1;
  int ds_list_size() const;
  void clear_ds_list();
  static const int kDsListFieldNumber = 1;
  const ::mpfmessage::DataSourceId& ds_list(int index) const;
  ::mpfmessage::DataSourceId* mutable_ds_list(int index);
  ::mpfmessage::DataSourceId* add_ds_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >*
      mutable_ds_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >&
      ds_list() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgRoomResSyncReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId > ds_list_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgRoomResSyncReqImpl();
};
// -------------------------------------------------------------------

class Sensor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.Sensor) */ {
 public:
  Sensor();
  virtual ~Sensor();

  Sensor(const Sensor& from);

  inline Sensor& operator=(const Sensor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Sensor(Sensor&& from) noexcept
    : Sensor() {
    *this = ::std::move(from);
  }

  inline Sensor& operator=(Sensor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Sensor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Sensor* internal_default_instance() {
    return reinterpret_cast<const Sensor*>(
               &_Sensor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(Sensor* other);
  friend void swap(Sensor& a, Sensor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Sensor* New() const PROTOBUF_FINAL { return New(NULL); }

  Sensor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Sensor& from);
  void MergeFrom(const Sensor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Sensor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string serial = 1;
  bool has_serial() const;
  void clear_serial();
  static const int kSerialFieldNumber = 1;
  const ::std::string& serial() const;
  void set_serial(const ::std::string& value);
  #if LANG_CXX11
  void set_serial(::std::string&& value);
  #endif
  void set_serial(const char* value);
  void set_serial(const char* value, size_t size);
  ::std::string* mutable_serial();
  ::std::string* release_serial();
  void set_allocated_serial(::std::string* serial);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string units = 4;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 4;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  #if LANG_CXX11
  void set_units(::std::string&& value);
  #endif
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // optional string index = 7;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 7;
  const ::std::string& index() const;
  void set_index(const ::std::string& value);
  #if LANG_CXX11
  void set_index(::std::string&& value);
  #endif
  void set_index(const char* value);
  void set_index(const char* value, size_t size);
  ::std::string* mutable_index();
  ::std::string* release_index();
  void set_allocated_index(::std::string* index);

  // optional uint32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 sensorid = 6;
  bool has_sensorid() const;
  void clear_sensorid();
  static const int kSensoridFieldNumber = 6;
  ::google::protobuf::uint32 sensorid() const;
  void set_sensorid(::google::protobuf::uint32 value);

  // optional .mpfmessage.AvailableStatus status = 5;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 5;
  ::mpfmessage::AvailableStatus status() const;
  void set_status(::mpfmessage::AvailableStatus value);

  // @@protoc_insertion_point(class_scope:mpfmessage.Sensor)
 private:
  void set_has_serial();
  void clear_has_serial();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_units();
  void clear_has_units();
  void set_has_status();
  void clear_has_status();
  void set_has_sensorid();
  void clear_has_sensorid();
  void set_has_index();
  void clear_has_index();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serial_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  ::google::protobuf::internal::ArenaStringPtr index_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 sensorid_;
  int status_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSensorImpl();
};
// -------------------------------------------------------------------

class DataSourceSyncResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.DataSourceSyncResult) */ {
 public:
  DataSourceSyncResult();
  virtual ~DataSourceSyncResult();

  DataSourceSyncResult(const DataSourceSyncResult& from);

  inline DataSourceSyncResult& operator=(const DataSourceSyncResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataSourceSyncResult(DataSourceSyncResult&& from) noexcept
    : DataSourceSyncResult() {
    *this = ::std::move(from);
  }

  inline DataSourceSyncResult& operator=(DataSourceSyncResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DataSourceSyncResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataSourceSyncResult* internal_default_instance() {
    return reinterpret_cast<const DataSourceSyncResult*>(
               &_DataSourceSyncResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(DataSourceSyncResult* other);
  friend void swap(DataSourceSyncResult& a, DataSourceSyncResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataSourceSyncResult* New() const PROTOBUF_FINAL { return New(NULL); }

  DataSourceSyncResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DataSourceSyncResult& from);
  void MergeFrom(const DataSourceSyncResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DataSourceSyncResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.Sensor sensorlist = 4;
  int sensorlist_size() const;
  void clear_sensorlist();
  static const int kSensorlistFieldNumber = 4;
  const ::mpfmessage::Sensor& sensorlist(int index) const;
  ::mpfmessage::Sensor* mutable_sensorlist(int index);
  ::mpfmessage::Sensor* add_sensorlist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::Sensor >*
      mutable_sensorlist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::Sensor >&
      sensorlist() const;

  // optional string detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional uint32 ds_res_id = 1;
  bool has_ds_res_id() const;
  void clear_ds_res_id();
  static const int kDsResIdFieldNumber = 1;
  ::google::protobuf::uint32 ds_res_id() const;
  void set_ds_res_id(::google::protobuf::uint32 value);

  // optional uint32 resultcode = 2;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 2;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.DataSourceSyncResult)
 private:
  void set_has_ds_res_id();
  void clear_has_ds_res_id();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::Sensor > sensorlist_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::uint32 ds_res_id_;
  ::google::protobuf::uint32 resultcode_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsDataSourceSyncResultImpl();
};
// -------------------------------------------------------------------

class MsgMachineRoomResSyncResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgMachineRoomResSyncResp) */ {
 public:
  MsgMachineRoomResSyncResp();
  virtual ~MsgMachineRoomResSyncResp();

  MsgMachineRoomResSyncResp(const MsgMachineRoomResSyncResp& from);

  inline MsgMachineRoomResSyncResp& operator=(const MsgMachineRoomResSyncResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgMachineRoomResSyncResp(MsgMachineRoomResSyncResp&& from) noexcept
    : MsgMachineRoomResSyncResp() {
    *this = ::std::move(from);
  }

  inline MsgMachineRoomResSyncResp& operator=(MsgMachineRoomResSyncResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgMachineRoomResSyncResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgMachineRoomResSyncResp* internal_default_instance() {
    return reinterpret_cast<const MsgMachineRoomResSyncResp*>(
               &_MsgMachineRoomResSyncResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(MsgMachineRoomResSyncResp* other);
  friend void swap(MsgMachineRoomResSyncResp& a, MsgMachineRoomResSyncResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgMachineRoomResSyncResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgMachineRoomResSyncResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgMachineRoomResSyncResp& from);
  void MergeFrom(const MsgMachineRoomResSyncResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgMachineRoomResSyncResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.DataSourceSyncResult ds_res_list = 1;
  int ds_res_list_size() const;
  void clear_ds_res_list();
  static const int kDsResListFieldNumber = 1;
  const ::mpfmessage::DataSourceSyncResult& ds_res_list(int index) const;
  ::mpfmessage::DataSourceSyncResult* mutable_ds_res_list(int index);
  ::mpfmessage::DataSourceSyncResult* add_ds_res_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceSyncResult >*
      mutable_ds_res_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceSyncResult >&
      ds_res_list() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgMachineRoomResSyncResp)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceSyncResult > ds_res_list_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgMachineRoomResSyncRespImpl();
};
// -------------------------------------------------------------------

class MsgGetSenserValueReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetSenserValueReq) */ {
 public:
  MsgGetSenserValueReq();
  virtual ~MsgGetSenserValueReq();

  MsgGetSenserValueReq(const MsgGetSenserValueReq& from);

  inline MsgGetSenserValueReq& operator=(const MsgGetSenserValueReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetSenserValueReq(MsgGetSenserValueReq&& from) noexcept
    : MsgGetSenserValueReq() {
    *this = ::std::move(from);
  }

  inline MsgGetSenserValueReq& operator=(MsgGetSenserValueReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetSenserValueReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetSenserValueReq* internal_default_instance() {
    return reinterpret_cast<const MsgGetSenserValueReq*>(
               &_MsgGetSenserValueReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(MsgGetSenserValueReq* other);
  friend void swap(MsgGetSenserValueReq& a, MsgGetSenserValueReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetSenserValueReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetSenserValueReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetSenserValueReq& from);
  void MergeFrom(const MsgGetSenserValueReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetSenserValueReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.DataSourceId ds_list = 1;
  int ds_list_size() const;
  void clear_ds_list();
  static const int kDsListFieldNumber = 1;
  const ::mpfmessage::DataSourceId& ds_list(int index) const;
  ::mpfmessage::DataSourceId* mutable_ds_list(int index);
  ::mpfmessage::DataSourceId* add_ds_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >*
      mutable_ds_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >&
      ds_list() const;

  // optional uint32 collect_time = 2;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 2;
  ::google::protobuf::uint32 collect_time() const;
  void set_collect_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetSenserValueReq)
 private:
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId > ds_list_;
  ::google::protobuf::uint32 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetSenserValueReqImpl();
};
// -------------------------------------------------------------------

class SenserValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SenserValue) */ {
 public:
  SenserValue();
  virtual ~SenserValue();

  SenserValue(const SenserValue& from);

  inline SenserValue& operator=(const SenserValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SenserValue(SenserValue&& from) noexcept
    : SenserValue() {
    *this = ::std::move(from);
  }

  inline SenserValue& operator=(SenserValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenserValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SenserValue* internal_default_instance() {
    return reinterpret_cast<const SenserValue*>(
               &_SenserValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(SenserValue* other);
  friend void swap(SenserValue& a, SenserValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SenserValue* New() const PROTOBUF_FINAL { return New(NULL); }

  SenserValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SenserValue& from);
  void MergeFrom(const SenserValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SenserValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  bool has_index() const;
  void clear_index();
  static const int kIndexFieldNumber = 1;
  ::google::protobuf::uint32 index() const;
  void set_index(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 available = 3;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 3;
  ::google::protobuf::uint32 available() const;
  void set_available(::google::protobuf::uint32 value);

  // optional uint32 value = 5;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 5;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // optional uint32 timestamp = 6;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional .mpfmessage.Status status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::mpfmessage::Status status() const;
  void set_status(::mpfmessage::Status value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SenserValue)
 private:
  void set_has_index();
  void clear_has_index();
  void set_has_type();
  void clear_has_type();
  void set_has_available();
  void clear_has_available();
  void set_has_status();
  void clear_has_status();
  void set_has_value();
  void clear_has_value();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 available_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 timestamp_;
  int status_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSenserValueImpl();
};
// -------------------------------------------------------------------

class SenserSyncResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.SenserSyncResult) */ {
 public:
  SenserSyncResult();
  virtual ~SenserSyncResult();

  SenserSyncResult(const SenserSyncResult& from);

  inline SenserSyncResult& operator=(const SenserSyncResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SenserSyncResult(SenserSyncResult&& from) noexcept
    : SenserSyncResult() {
    *this = ::std::move(from);
  }

  inline SenserSyncResult& operator=(SenserSyncResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SenserSyncResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SenserSyncResult* internal_default_instance() {
    return reinterpret_cast<const SenserSyncResult*>(
               &_SenserSyncResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(SenserSyncResult* other);
  friend void swap(SenserSyncResult& a, SenserSyncResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SenserSyncResult* New() const PROTOBUF_FINAL { return New(NULL); }

  SenserSyncResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SenserSyncResult& from);
  void MergeFrom(const SenserSyncResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SenserSyncResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.SenserValue valuelist = 4;
  int valuelist_size() const;
  void clear_valuelist();
  static const int kValuelistFieldNumber = 4;
  const ::mpfmessage::SenserValue& valuelist(int index) const;
  ::mpfmessage::SenserValue* mutable_valuelist(int index);
  ::mpfmessage::SenserValue* add_valuelist();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SenserValue >*
      mutable_valuelist();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SenserValue >&
      valuelist() const;

  // optional string detail = 3;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 3;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional uint32 ds_res_id = 1;
  bool has_ds_res_id() const;
  void clear_ds_res_id();
  static const int kDsResIdFieldNumber = 1;
  ::google::protobuf::uint32 ds_res_id() const;
  void set_ds_res_id(::google::protobuf::uint32 value);

  // optional uint32 resultcode = 2;
  bool has_resultcode() const;
  void clear_resultcode();
  static const int kResultcodeFieldNumber = 2;
  ::google::protobuf::uint32 resultcode() const;
  void set_resultcode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.SenserSyncResult)
 private:
  void set_has_ds_res_id();
  void clear_has_ds_res_id();
  void set_has_resultcode();
  void clear_has_resultcode();
  void set_has_detail();
  void clear_has_detail();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SenserValue > valuelist_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::google::protobuf::uint32 ds_res_id_;
  ::google::protobuf::uint32 resultcode_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsSenserSyncResultImpl();
};
// -------------------------------------------------------------------

class MsgGetSenserValueResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgGetSenserValueResp) */ {
 public:
  MsgGetSenserValueResp();
  virtual ~MsgGetSenserValueResp();

  MsgGetSenserValueResp(const MsgGetSenserValueResp& from);

  inline MsgGetSenserValueResp& operator=(const MsgGetSenserValueResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgGetSenserValueResp(MsgGetSenserValueResp&& from) noexcept
    : MsgGetSenserValueResp() {
    *this = ::std::move(from);
  }

  inline MsgGetSenserValueResp& operator=(MsgGetSenserValueResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgGetSenserValueResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgGetSenserValueResp* internal_default_instance() {
    return reinterpret_cast<const MsgGetSenserValueResp*>(
               &_MsgGetSenserValueResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(MsgGetSenserValueResp* other);
  friend void swap(MsgGetSenserValueResp& a, MsgGetSenserValueResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgGetSenserValueResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgGetSenserValueResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgGetSenserValueResp& from);
  void MergeFrom(const MsgGetSenserValueResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgGetSenserValueResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgGetSenserValueResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgGetSenserValueRespImpl();
};
// -------------------------------------------------------------------

class ConnectivityTestSynReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ConnectivityTestSynReq) */ {
 public:
  ConnectivityTestSynReq();
  virtual ~ConnectivityTestSynReq();

  ConnectivityTestSynReq(const ConnectivityTestSynReq& from);

  inline ConnectivityTestSynReq& operator=(const ConnectivityTestSynReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConnectivityTestSynReq(ConnectivityTestSynReq&& from) noexcept
    : ConnectivityTestSynReq() {
    *this = ::std::move(from);
  }

  inline ConnectivityTestSynReq& operator=(ConnectivityTestSynReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectivityTestSynReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConnectivityTestSynReq* internal_default_instance() {
    return reinterpret_cast<const ConnectivityTestSynReq*>(
               &_ConnectivityTestSynReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(ConnectivityTestSynReq* other);
  friend void swap(ConnectivityTestSynReq& a, ConnectivityTestSynReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConnectivityTestSynReq* New() const PROTOBUF_FINAL { return New(NULL); }

  ConnectivityTestSynReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ConnectivityTestSynReq& from);
  void MergeFrom(const ConnectivityTestSynReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ConnectivityTestSynReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.SnmpInfo snmp_info = 4;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 4;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional .mpfmessage.TelnetPara telentPara = 5;
  bool has_telentpara() const;
  void clear_telentpara();
  static const int kTelentParaFieldNumber = 5;
  const ::mpfmessage::TelnetPara& telentpara() const;
  ::mpfmessage::TelnetPara* release_telentpara();
  ::mpfmessage::TelnetPara* mutable_telentpara();
  void set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara);

  // optional .mpfmessage.SshPara sshPara = 6;
  bool has_sshpara() const;
  void clear_sshpara();
  static const int kSshParaFieldNumber = 6;
  const ::mpfmessage::SshPara& sshpara() const;
  ::mpfmessage::SshPara* release_sshpara();
  ::mpfmessage::SshPara* mutable_sshpara();
  void set_allocated_sshpara(::mpfmessage::SshPara* sshpara);

  // optional .mpfmessage.PingPara pingPara = 7;
  bool has_pingpara() const;
  void clear_pingpara();
  static const int kPingParaFieldNumber = 7;
  const ::mpfmessage::PingPara& pingpara() const;
  ::mpfmessage::PingPara* release_pingpara();
  ::mpfmessage::PingPara* mutable_pingpara();
  void set_allocated_pingpara(::mpfmessage::PingPara* pingpara);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional .mpfmessage.ResType res_type = 2;
  bool has_res_type() const;
  void clear_res_type();
  static const int kResTypeFieldNumber = 2;
  ::mpfmessage::ResType res_type() const;
  void set_res_type(::mpfmessage::ResType value);

  // optional .mpfmessage.ConnectivityTestType test_type = 3;
  bool has_test_type() const;
  void clear_test_type();
  static const int kTestTypeFieldNumber = 3;
  ::mpfmessage::ConnectivityTestType test_type() const;
  void set_test_type(::mpfmessage::ConnectivityTestType value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ConnectivityTestSynReq)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_res_type();
  void clear_has_res_type();
  void set_has_test_type();
  void clear_has_test_type();
  void set_has_snmp_info();
  void clear_has_snmp_info();
  void set_has_telentpara();
  void clear_has_telentpara();
  void set_has_sshpara();
  void clear_has_sshpara();
  void set_has_pingpara();
  void clear_has_pingpara();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::mpfmessage::TelnetPara* telentpara_;
  ::mpfmessage::SshPara* sshpara_;
  ::mpfmessage::PingPara* pingpara_;
  ::google::protobuf::uint32 res_id_;
  int res_type_;
  int test_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsConnectivityTestSynReqImpl();
};
// -------------------------------------------------------------------

class MsgConnectivityTestSynResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgConnectivityTestSynResp) */ {
 public:
  MsgConnectivityTestSynResp();
  virtual ~MsgConnectivityTestSynResp();

  MsgConnectivityTestSynResp(const MsgConnectivityTestSynResp& from);

  inline MsgConnectivityTestSynResp& operator=(const MsgConnectivityTestSynResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgConnectivityTestSynResp(MsgConnectivityTestSynResp&& from) noexcept
    : MsgConnectivityTestSynResp() {
    *this = ::std::move(from);
  }

  inline MsgConnectivityTestSynResp& operator=(MsgConnectivityTestSynResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgConnectivityTestSynResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgConnectivityTestSynResp* internal_default_instance() {
    return reinterpret_cast<const MsgConnectivityTestSynResp*>(
               &_MsgConnectivityTestSynResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    51;

  void Swap(MsgConnectivityTestSynResp* other);
  friend void swap(MsgConnectivityTestSynResp& a, MsgConnectivityTestSynResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgConnectivityTestSynResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgConnectivityTestSynResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgConnectivityTestSynResp& from);
  void MergeFrom(const MsgConnectivityTestSynResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgConnectivityTestSynResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional .mpfmessage.ConnectivityTestResult result = 2;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 2;
  ::mpfmessage::ConnectivityTestResult result() const;
  void set_result(::mpfmessage::ConnectivityTestResult value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgConnectivityTestSynResp)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 res_id_;
  int result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgConnectivityTestSynRespImpl();
};
// -------------------------------------------------------------------

class MsgDevTestPara : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgDevTestPara) */ {
 public:
  MsgDevTestPara();
  virtual ~MsgDevTestPara();

  MsgDevTestPara(const MsgDevTestPara& from);

  inline MsgDevTestPara& operator=(const MsgDevTestPara& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgDevTestPara(MsgDevTestPara&& from) noexcept
    : MsgDevTestPara() {
    *this = ::std::move(from);
  }

  inline MsgDevTestPara& operator=(MsgDevTestPara&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgDevTestPara& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgDevTestPara* internal_default_instance() {
    return reinterpret_cast<const MsgDevTestPara*>(
               &_MsgDevTestPara_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    52;

  void Swap(MsgDevTestPara* other);
  friend void swap(MsgDevTestPara& a, MsgDevTestPara& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgDevTestPara* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgDevTestPara* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgDevTestPara& from);
  void MergeFrom(const MsgDevTestPara& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgDevTestPara* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional .mpfmessage.PingPara ping_para = 4;
  bool has_ping_para() const;
  void clear_ping_para();
  static const int kPingParaFieldNumber = 4;
  const ::mpfmessage::PingPara& ping_para() const;
  ::mpfmessage::PingPara* release_ping_para();
  ::mpfmessage::PingPara* mutable_ping_para();
  void set_allocated_ping_para(::mpfmessage::PingPara* ping_para);

  // optional .mpfmessage.SnmpInfo snmp_para = 5;
  bool has_snmp_para() const;
  void clear_snmp_para();
  static const int kSnmpParaFieldNumber = 5;
  const ::mpfmessage::SnmpInfo& snmp_para() const;
  ::mpfmessage::SnmpInfo* release_snmp_para();
  ::mpfmessage::SnmpInfo* mutable_snmp_para();
  void set_allocated_snmp_para(::mpfmessage::SnmpInfo* snmp_para);

  // optional .mpfmessage.SshPara ssh_para = 6;
  bool has_ssh_para() const;
  void clear_ssh_para();
  static const int kSshParaFieldNumber = 6;
  const ::mpfmessage::SshPara& ssh_para() const;
  ::mpfmessage::SshPara* release_ssh_para();
  ::mpfmessage::SshPara* mutable_ssh_para();
  void set_allocated_ssh_para(::mpfmessage::SshPara* ssh_para);

  // optional .mpfmessage.TelnetPara telnet_para = 7;
  bool has_telnet_para() const;
  void clear_telnet_para();
  static const int kTelnetParaFieldNumber = 7;
  const ::mpfmessage::TelnetPara& telnet_para() const;
  ::mpfmessage::TelnetPara* release_telnet_para();
  ::mpfmessage::TelnetPara* mutable_telnet_para();
  void set_allocated_telnet_para(::mpfmessage::TelnetPara* telnet_para);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional uint32 test_type = 3;
  bool has_test_type() const;
  void clear_test_type();
  static const int kTestTypeFieldNumber = 3;
  ::google::protobuf::uint32 test_type() const;
  void set_test_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgDevTestPara)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_ip();
  void clear_has_ip();
  void set_has_test_type();
  void clear_has_test_type();
  void set_has_ping_para();
  void clear_has_ping_para();
  void set_has_snmp_para();
  void clear_has_snmp_para();
  void set_has_ssh_para();
  void clear_has_ssh_para();
  void set_has_telnet_para();
  void clear_has_telnet_para();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::mpfmessage::PingPara* ping_para_;
  ::mpfmessage::SnmpInfo* snmp_para_;
  ::mpfmessage::SshPara* ssh_para_;
  ::mpfmessage::TelnetPara* telnet_para_;
  ::google::protobuf::uint32 res_id_;
  ::google::protobuf::uint32 test_type_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgDevTestParaImpl();
};
// -------------------------------------------------------------------

class MsgReachableTestReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgReachableTestReq) */ {
 public:
  MsgReachableTestReq();
  virtual ~MsgReachableTestReq();

  MsgReachableTestReq(const MsgReachableTestReq& from);

  inline MsgReachableTestReq& operator=(const MsgReachableTestReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgReachableTestReq(MsgReachableTestReq&& from) noexcept
    : MsgReachableTestReq() {
    *this = ::std::move(from);
  }

  inline MsgReachableTestReq& operator=(MsgReachableTestReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReachableTestReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgReachableTestReq* internal_default_instance() {
    return reinterpret_cast<const MsgReachableTestReq*>(
               &_MsgReachableTestReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    53;

  void Swap(MsgReachableTestReq* other);
  friend void swap(MsgReachableTestReq& a, MsgReachableTestReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgReachableTestReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgReachableTestReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgReachableTestReq& from);
  void MergeFrom(const MsgReachableTestReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgReachableTestReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.MsgDevTestPara dev_para_list = 1;
  int dev_para_list_size() const;
  void clear_dev_para_list();
  static const int kDevParaListFieldNumber = 1;
  const ::mpfmessage::MsgDevTestPara& dev_para_list(int index) const;
  ::mpfmessage::MsgDevTestPara* mutable_dev_para_list(int index);
  ::mpfmessage::MsgDevTestPara* add_dev_para_list();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::MsgDevTestPara >*
      mutable_dev_para_list();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::MsgDevTestPara >&
      dev_para_list() const;

  // optional .mpfmessage.RespAddr notify_addr = 2;
  bool has_notify_addr() const;
  void clear_notify_addr();
  static const int kNotifyAddrFieldNumber = 2;
  const ::mpfmessage::RespAddr& notify_addr() const;
  ::mpfmessage::RespAddr* release_notify_addr();
  ::mpfmessage::RespAddr* mutable_notify_addr();
  void set_allocated_notify_addr(::mpfmessage::RespAddr* notify_addr);

  // optional uint64 collect_time = 3;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 3;
  ::google::protobuf::uint64 collect_time() const;
  void set_collect_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgReachableTestReq)
 private:
  void set_has_notify_addr();
  void clear_has_notify_addr();
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::MsgDevTestPara > dev_para_list_;
  ::mpfmessage::RespAddr* notify_addr_;
  ::google::protobuf::uint64 collect_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgReachableTestReqImpl();
};
// -------------------------------------------------------------------

class MsgReachableTestResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgReachableTestResp) */ {
 public:
  MsgReachableTestResp();
  virtual ~MsgReachableTestResp();

  MsgReachableTestResp(const MsgReachableTestResp& from);

  inline MsgReachableTestResp& operator=(const MsgReachableTestResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgReachableTestResp(MsgReachableTestResp&& from) noexcept
    : MsgReachableTestResp() {
    *this = ::std::move(from);
  }

  inline MsgReachableTestResp& operator=(MsgReachableTestResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReachableTestResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgReachableTestResp* internal_default_instance() {
    return reinterpret_cast<const MsgReachableTestResp*>(
               &_MsgReachableTestResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    54;

  void Swap(MsgReachableTestResp* other);
  friend void swap(MsgReachableTestResp& a, MsgReachableTestResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgReachableTestResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgReachableTestResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgReachableTestResp& from);
  void MergeFrom(const MsgReachableTestResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgReachableTestResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgReachableTestResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgReachableTestRespImpl();
};
// -------------------------------------------------------------------

class PingPerf : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.PingPerf) */ {
 public:
  PingPerf();
  virtual ~PingPerf();

  PingPerf(const PingPerf& from);

  inline PingPerf& operator=(const PingPerf& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PingPerf(PingPerf&& from) noexcept
    : PingPerf() {
    *this = ::std::move(from);
  }

  inline PingPerf& operator=(PingPerf&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingPerf& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PingPerf* internal_default_instance() {
    return reinterpret_cast<const PingPerf*>(
               &_PingPerf_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    55;

  void Swap(PingPerf* other);
  friend void swap(PingPerf& a, PingPerf& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PingPerf* New() const PROTOBUF_FINAL { return New(NULL); }

  PingPerf* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const PingPerf& from);
  void MergeFrom(const PingPerf& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(PingPerf* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 send_pack_num = 1;
  bool has_send_pack_num() const;
  void clear_send_pack_num();
  static const int kSendPackNumFieldNumber = 1;
  ::google::protobuf::uint32 send_pack_num() const;
  void set_send_pack_num(::google::protobuf::uint32 value);

  // optional uint32 recieve_pack_num = 2;
  bool has_recieve_pack_num() const;
  void clear_recieve_pack_num();
  static const int kRecievePackNumFieldNumber = 2;
  ::google::protobuf::uint32 recieve_pack_num() const;
  void set_recieve_pack_num(::google::protobuf::uint32 value);

  // optional uint32 loss_pack_num = 3;
  bool has_loss_pack_num() const;
  void clear_loss_pack_num();
  static const int kLossPackNumFieldNumber = 3;
  ::google::protobuf::uint32 loss_pack_num() const;
  void set_loss_pack_num(::google::protobuf::uint32 value);

  // optional float max_cost_time = 4;
  bool has_max_cost_time() const;
  void clear_max_cost_time();
  static const int kMaxCostTimeFieldNumber = 4;
  float max_cost_time() const;
  void set_max_cost_time(float value);

  // optional float min_cost_time = 5;
  bool has_min_cost_time() const;
  void clear_min_cost_time();
  static const int kMinCostTimeFieldNumber = 5;
  float min_cost_time() const;
  void set_min_cost_time(float value);

  // optional float average_cost_time = 6;
  bool has_average_cost_time() const;
  void clear_average_cost_time();
  static const int kAverageCostTimeFieldNumber = 6;
  float average_cost_time() const;
  void set_average_cost_time(float value);

  // @@protoc_insertion_point(class_scope:mpfmessage.PingPerf)
 private:
  void set_has_send_pack_num();
  void clear_has_send_pack_num();
  void set_has_recieve_pack_num();
  void clear_has_recieve_pack_num();
  void set_has_loss_pack_num();
  void clear_has_loss_pack_num();
  void set_has_max_cost_time();
  void clear_has_max_cost_time();
  void set_has_min_cost_time();
  void clear_has_min_cost_time();
  void set_has_average_cost_time();
  void clear_has_average_cost_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 send_pack_num_;
  ::google::protobuf::uint32 recieve_pack_num_;
  ::google::protobuf::uint32 loss_pack_num_;
  float max_cost_time_;
  float min_cost_time_;
  float average_cost_time_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsPingPerfImpl();
};
// -------------------------------------------------------------------

class ReachableTestResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.ReachableTestResult) */ {
 public:
  ReachableTestResult();
  virtual ~ReachableTestResult();

  ReachableTestResult(const ReachableTestResult& from);

  inline ReachableTestResult& operator=(const ReachableTestResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReachableTestResult(ReachableTestResult&& from) noexcept
    : ReachableTestResult() {
    *this = ::std::move(from);
  }

  inline ReachableTestResult& operator=(ReachableTestResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReachableTestResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReachableTestResult* internal_default_instance() {
    return reinterpret_cast<const ReachableTestResult*>(
               &_ReachableTestResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    56;

  void Swap(ReachableTestResult* other);
  friend void swap(ReachableTestResult& a, ReachableTestResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReachableTestResult* New() const PROTOBUF_FINAL { return New(NULL); }

  ReachableTestResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ReachableTestResult& from);
  void MergeFrom(const ReachableTestResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ReachableTestResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 2;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 2;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional string detail = 7;
  bool has_detail() const;
  void clear_detail();
  static const int kDetailFieldNumber = 7;
  const ::std::string& detail() const;
  void set_detail(const ::std::string& value);
  #if LANG_CXX11
  void set_detail(::std::string&& value);
  #endif
  void set_detail(const char* value);
  void set_detail(const char* value, size_t size);
  ::std::string* mutable_detail();
  ::std::string* release_detail();
  void set_allocated_detail(::std::string* detail);

  // optional .mpfmessage.PingPerf ping_perf = 8;
  bool has_ping_perf() const;
  void clear_ping_perf();
  static const int kPingPerfFieldNumber = 8;
  const ::mpfmessage::PingPerf& ping_perf() const;
  ::mpfmessage::PingPerf* release_ping_perf();
  ::mpfmessage::PingPerf* mutable_ping_perf();
  void set_allocated_ping_perf(::mpfmessage::PingPerf* ping_perf);

  // optional uint64 collect_time = 9;
  bool has_collect_time() const;
  void clear_collect_time();
  static const int kCollectTimeFieldNumber = 9;
  ::google::protobuf::uint64 collect_time() const;
  void set_collect_time(::google::protobuf::uint64 value);

  // optional uint32 res_id = 1;
  bool has_res_id() const;
  void clear_res_id();
  static const int kResIdFieldNumber = 1;
  ::google::protobuf::uint32 res_id() const;
  void set_res_id(::google::protobuf::uint32 value);

  // optional .mpfmessage.TestResult ping_result = 3;
  bool has_ping_result() const;
  void clear_ping_result();
  static const int kPingResultFieldNumber = 3;
  ::mpfmessage::TestResult ping_result() const;
  void set_ping_result(::mpfmessage::TestResult value);

  // optional .mpfmessage.TestResult snmp_result = 4;
  bool has_snmp_result() const;
  void clear_snmp_result();
  static const int kSnmpResultFieldNumber = 4;
  ::mpfmessage::TestResult snmp_result() const;
  void set_snmp_result(::mpfmessage::TestResult value);

  // optional .mpfmessage.TestResult ssh_result = 5;
  bool has_ssh_result() const;
  void clear_ssh_result();
  static const int kSshResultFieldNumber = 5;
  ::mpfmessage::TestResult ssh_result() const;
  void set_ssh_result(::mpfmessage::TestResult value);

  // optional .mpfmessage.TestResult telnet_result = 6;
  bool has_telnet_result() const;
  void clear_telnet_result();
  static const int kTelnetResultFieldNumber = 6;
  ::mpfmessage::TestResult telnet_result() const;
  void set_telnet_result(::mpfmessage::TestResult value);

  // @@protoc_insertion_point(class_scope:mpfmessage.ReachableTestResult)
 private:
  void set_has_res_id();
  void clear_has_res_id();
  void set_has_ip();
  void clear_has_ip();
  void set_has_ping_result();
  void clear_has_ping_result();
  void set_has_snmp_result();
  void clear_has_snmp_result();
  void set_has_ssh_result();
  void clear_has_ssh_result();
  void set_has_telnet_result();
  void clear_has_telnet_result();
  void set_has_detail();
  void clear_has_detail();
  void set_has_ping_perf();
  void clear_has_ping_perf();
  void set_has_collect_time();
  void clear_has_collect_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr detail_;
  ::mpfmessage::PingPerf* ping_perf_;
  ::google::protobuf::uint64 collect_time_;
  ::google::protobuf::uint32 res_id_;
  int ping_result_;
  int snmp_result_;
  int ssh_result_;
  int telnet_result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsReachableTestResultImpl();
};
// -------------------------------------------------------------------

class MsgReachableTestNotify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgReachableTestNotify) */ {
 public:
  MsgReachableTestNotify();
  virtual ~MsgReachableTestNotify();

  MsgReachableTestNotify(const MsgReachableTestNotify& from);

  inline MsgReachableTestNotify& operator=(const MsgReachableTestNotify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgReachableTestNotify(MsgReachableTestNotify&& from) noexcept
    : MsgReachableTestNotify() {
    *this = ::std::move(from);
  }

  inline MsgReachableTestNotify& operator=(MsgReachableTestNotify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReachableTestNotify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgReachableTestNotify* internal_default_instance() {
    return reinterpret_cast<const MsgReachableTestNotify*>(
               &_MsgReachableTestNotify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    57;

  void Swap(MsgReachableTestNotify* other);
  friend void swap(MsgReachableTestNotify& a, MsgReachableTestNotify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgReachableTestNotify* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgReachableTestNotify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgReachableTestNotify& from);
  void MergeFrom(const MsgReachableTestNotify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgReachableTestNotify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.ReachableTestResult result_data = 1;
  int result_data_size() const;
  void clear_result_data();
  static const int kResultDataFieldNumber = 1;
  const ::mpfmessage::ReachableTestResult& result_data(int index) const;
  ::mpfmessage::ReachableTestResult* mutable_result_data(int index);
  ::mpfmessage::ReachableTestResult* add_result_data();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ReachableTestResult >*
      mutable_result_data();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ReachableTestResult >&
      result_data() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgReachableTestNotify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::ReachableTestResult > result_data_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgReachableTestNotifyImpl();
};
// -------------------------------------------------------------------

class IpGroup : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.IpGroup) */ {
 public:
  IpGroup();
  virtual ~IpGroup();

  IpGroup(const IpGroup& from);

  inline IpGroup& operator=(const IpGroup& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IpGroup(IpGroup&& from) noexcept
    : IpGroup() {
    *this = ::std::move(from);
  }

  inline IpGroup& operator=(IpGroup&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IpGroup& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IpGroup* internal_default_instance() {
    return reinterpret_cast<const IpGroup*>(
               &_IpGroup_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    58;

  void Swap(IpGroup* other);
  friend void swap(IpGroup& a, IpGroup& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IpGroup* New() const PROTOBUF_FINAL { return New(NULL); }

  IpGroup* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IpGroup& from);
  void MergeFrom(const IpGroup& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IpGroup* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string start_ip = 1;
  bool has_start_ip() const;
  void clear_start_ip();
  static const int kStartIpFieldNumber = 1;
  const ::std::string& start_ip() const;
  void set_start_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_start_ip(::std::string&& value);
  #endif
  void set_start_ip(const char* value);
  void set_start_ip(const char* value, size_t size);
  ::std::string* mutable_start_ip();
  ::std::string* release_start_ip();
  void set_allocated_start_ip(::std::string* start_ip);

  // optional string end_ip = 2;
  bool has_end_ip() const;
  void clear_end_ip();
  static const int kEndIpFieldNumber = 2;
  const ::std::string& end_ip() const;
  void set_end_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_end_ip(::std::string&& value);
  #endif
  void set_end_ip(const char* value);
  void set_end_ip(const char* value, size_t size);
  ::std::string* mutable_end_ip();
  ::std::string* release_end_ip();
  void set_allocated_end_ip(::std::string* end_ip);

  // @@protoc_insertion_point(class_scope:mpfmessage.IpGroup)
 private:
  void set_has_start_ip();
  void clear_has_start_ip();
  void set_has_end_ip();
  void clear_has_end_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr start_ip_;
  ::google::protobuf::internal::ArenaStringPtr end_ip_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsIpGroupImpl();
};
// -------------------------------------------------------------------

class MsgTopoDiscoveryReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgTopoDiscoveryReq) */ {
 public:
  MsgTopoDiscoveryReq();
  virtual ~MsgTopoDiscoveryReq();

  MsgTopoDiscoveryReq(const MsgTopoDiscoveryReq& from);

  inline MsgTopoDiscoveryReq& operator=(const MsgTopoDiscoveryReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTopoDiscoveryReq(MsgTopoDiscoveryReq&& from) noexcept
    : MsgTopoDiscoveryReq() {
    *this = ::std::move(from);
  }

  inline MsgTopoDiscoveryReq& operator=(MsgTopoDiscoveryReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTopoDiscoveryReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTopoDiscoveryReq* internal_default_instance() {
    return reinterpret_cast<const MsgTopoDiscoveryReq*>(
               &_MsgTopoDiscoveryReq_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    59;

  void Swap(MsgTopoDiscoveryReq* other);
  friend void swap(MsgTopoDiscoveryReq& a, MsgTopoDiscoveryReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTopoDiscoveryReq* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTopoDiscoveryReq* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTopoDiscoveryReq& from);
  void MergeFrom(const MsgTopoDiscoveryReq& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTopoDiscoveryReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mpfmessage.SnmpInfo snmp = 1;
  int snmp_size() const;
  void clear_snmp();
  static const int kSnmpFieldNumber = 1;
  const ::mpfmessage::SnmpInfo& snmp(int index) const;
  ::mpfmessage::SnmpInfo* mutable_snmp(int index);
  ::mpfmessage::SnmpInfo* add_snmp();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SnmpInfo >*
      mutable_snmp();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SnmpInfo >&
      snmp() const;

  // repeated .mpfmessage.IpGroup ip_group = 2;
  int ip_group_size() const;
  void clear_ip_group();
  static const int kIpGroupFieldNumber = 2;
  const ::mpfmessage::IpGroup& ip_group(int index) const;
  ::mpfmessage::IpGroup* mutable_ip_group(int index);
  ::mpfmessage::IpGroup* add_ip_group();
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IpGroup >*
      mutable_ip_group();
  const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IpGroup >&
      ip_group() const;

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgTopoDiscoveryReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::SnmpInfo > snmp_;
  ::google::protobuf::RepeatedPtrField< ::mpfmessage::IpGroup > ip_group_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgTopoDiscoveryReqImpl();
};
// -------------------------------------------------------------------

class MsgTopoFindResp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.MsgTopoFindResp) */ {
 public:
  MsgTopoFindResp();
  virtual ~MsgTopoFindResp();

  MsgTopoFindResp(const MsgTopoFindResp& from);

  inline MsgTopoFindResp& operator=(const MsgTopoFindResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MsgTopoFindResp(MsgTopoFindResp&& from) noexcept
    : MsgTopoFindResp() {
    *this = ::std::move(from);
  }

  inline MsgTopoFindResp& operator=(MsgTopoFindResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgTopoFindResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MsgTopoFindResp* internal_default_instance() {
    return reinterpret_cast<const MsgTopoFindResp*>(
               &_MsgTopoFindResp_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    60;

  void Swap(MsgTopoFindResp* other);
  friend void swap(MsgTopoFindResp& a, MsgTopoFindResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MsgTopoFindResp* New() const PROTOBUF_FINAL { return New(NULL); }

  MsgTopoFindResp* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MsgTopoFindResp& from);
  void MergeFrom(const MsgTopoFindResp& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MsgTopoFindResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mpfmessage.MsgCommonData result = 1;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 1;
  const ::mpfmessage::MsgCommonData& result() const;
  ::mpfmessage::MsgCommonData* release_result();
  ::mpfmessage::MsgCommonData* mutable_result();
  void set_allocated_result(::mpfmessage::MsgCommonData* result);

  // @@protoc_insertion_point(class_scope:mpfmessage.MsgTopoFindResp)
 private:
  void set_has_result();
  void clear_has_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::mpfmessage::MsgCommonData* result_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsMsgTopoFindRespImpl();
};
// -------------------------------------------------------------------

class TopoNodeInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.TopoNodeInfo) */ {
 public:
  TopoNodeInfo();
  virtual ~TopoNodeInfo();

  TopoNodeInfo(const TopoNodeInfo& from);

  inline TopoNodeInfo& operator=(const TopoNodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopoNodeInfo(TopoNodeInfo&& from) noexcept
    : TopoNodeInfo() {
    *this = ::std::move(from);
  }

  inline TopoNodeInfo& operator=(TopoNodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopoNodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopoNodeInfo* internal_default_instance() {
    return reinterpret_cast<const TopoNodeInfo*>(
               &_TopoNodeInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    61;

  void Swap(TopoNodeInfo* other);
  friend void swap(TopoNodeInfo& a, TopoNodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopoNodeInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TopoNodeInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopoNodeInfo& from);
  void MergeFrom(const TopoNodeInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopoNodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ip = 1;
  bool has_ip() const;
  void clear_ip();
  static const int kIpFieldNumber = 1;
  const ::std::string& ip() const;
  void set_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_ip(::std::string&& value);
  #endif
  void set_ip(const char* value);
  void set_ip(const char* value, size_t size);
  ::std::string* mutable_ip();
  ::std::string* release_ip();
  void set_allocated_ip(::std::string* ip);

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .mpfmessage.SnmpInfo snmp_info = 5;
  bool has_snmp_info() const;
  void clear_snmp_info();
  static const int kSnmpInfoFieldNumber = 5;
  const ::mpfmessage::SnmpInfo& snmp_info() const;
  ::mpfmessage::SnmpInfo* release_snmp_info();
  ::mpfmessage::SnmpInfo* mutable_snmp_info();
  void set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info);

  // optional uint32 type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional uint32 run_status = 4;
  bool has_run_status() const;
  void clear_run_status();
  static const int kRunStatusFieldNumber = 4;
  ::google::protobuf::uint32 run_status() const;
  void set_run_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mpfmessage.TopoNodeInfo)
 private:
  void set_has_ip();
  void clear_has_ip();
  void set_has_name();
  void clear_has_name();
  void set_has_type();
  void clear_has_type();
  void set_has_run_status();
  void clear_has_run_status();
  void set_has_snmp_info();
  void clear_has_snmp_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ip_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::mpfmessage::SnmpInfo* snmp_info_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 run_status_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsTopoNodeInfoImpl();
};
// -------------------------------------------------------------------

class TopoLinkInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mpfmessage.TopoLinkInfo) */ {
 public:
  TopoLinkInfo();
  virtual ~TopoLinkInfo();

  TopoLinkInfo(const TopoLinkInfo& from);

  inline TopoLinkInfo& operator=(const TopoLinkInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TopoLinkInfo(TopoLinkInfo&& from) noexcept
    : TopoLinkInfo() {
    *this = ::std::move(from);
  }

  inline TopoLinkInfo& operator=(TopoLinkInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopoLinkInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopoLinkInfo* internal_default_instance() {
    return reinterpret_cast<const TopoLinkInfo*>(
               &_TopoLinkInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    62;

  void Swap(TopoLinkInfo* other);
  friend void swap(TopoLinkInfo& a, TopoLinkInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TopoLinkInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  TopoLinkInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TopoLinkInfo& from);
  void MergeFrom(const TopoLinkInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TopoLinkInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string src_ip = 1;
  bool has_src_ip() const;
  void clear_src_ip();
  static const int kSrcIpFieldNumber = 1;
  const ::std::string& src_ip() const;
  void set_src_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_src_ip(::std::string&& value);
  #endif
  void set_src_ip(const char* value);
  void set_src_ip(const char* value, size_t size);
  ::std::string* mutable_src_ip();
  ::std::string* release_src_ip();
  void set_allocated_src_ip(::std::string* src_ip);

  // optional string dest_ip = 2;
  bool has_dest_ip() const;
  void clear_dest_ip();
  static const int kDestIpFieldNumber = 2;
  const ::std::string& dest_ip() const;
  void set_dest_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_ip(::std::string&& value);
  #endif
  void set_dest_ip(const char* value);
  void set_dest_ip(const char* value, size_t size);
  ::std::string* mutable_dest_ip();
  ::std::string* release_dest_ip();
  void set_allocated_dest_ip(::std::string* dest_ip);

  // optional string src_name = 3;
  bool has_src_name() const;
  void clear_src_name();
  static const int kSrcNameFieldNumber = 3;
  const ::std::string& src_name() const;
  void set_src_name(const ::std::string& value);
  #if LANG_CXX11
  void set_src_name(::std::string&& value);
  #endif
  void set_src_name(const char* value);
  void set_src_name(const char* value, size_t size);
  ::std::string* mutable_src_name();
  ::std::string* release_src_name();
  void set_allocated_src_name(::std::string* src_name);

  // optional string dest_name = 4;
  bool has_dest_name() const;
  void clear_dest_name();
  static const int kDestNameFieldNumber = 4;
  const ::std::string& dest_name() const;
  void set_dest_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_name(::std::string&& value);
  #endif
  void set_dest_name(const char* value);
  void set_dest_name(const char* value, size_t size);
  ::std::string* mutable_dest_name();
  ::std::string* release_dest_name();
  void set_allocated_dest_name(::std::string* dest_name);

  // optional string src_if_name = 5;
  bool has_src_if_name() const;
  void clear_src_if_name();
  static const int kSrcIfNameFieldNumber = 5;
  const ::std::string& src_if_name() const;
  void set_src_if_name(const ::std::string& value);
  #if LANG_CXX11
  void set_src_if_name(::std::string&& value);
  #endif
  void set_src_if_name(const char* value);
  void set_src_if_name(const char* value, size_t size);
  ::std::string* mutable_src_if_name();
  ::std::string* release_src_if_name();
  void set_allocated_src_if_name(::std::string* src_if_name);

  // optional string dest_if_name = 6;
  bool has_dest_if_name() const;
  void clear_dest_if_name();
  static const int kDestIfNameFieldNumber = 6;
  const ::std::string& dest_if_name() const;
  void set_dest_if_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_if_name(::std::string&& value);
  #endif
  void set_dest_if_name(const char* value);
  void set_dest_if_name(const char* value, size_t size);
  ::std::string* mutable_dest_if_name();
  ::std::string* release_dest_if_name();
  void set_allocated_dest_if_name(::std::string* dest_if_name);

  // @@protoc_insertion_point(class_scope:mpfmessage.TopoLinkInfo)
 private:
  void set_has_src_ip();
  void clear_has_src_ip();
  void set_has_dest_ip();
  void clear_has_dest_ip();
  void set_has_src_name();
  void clear_has_src_name();
  void set_has_dest_name();
  void clear_has_dest_name();
  void set_has_src_if_name();
  void clear_has_src_if_name();
  void set_has_dest_if_name();
  void clear_has_dest_if_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr src_ip_;
  ::google::protobuf::internal::ArenaStringPtr dest_ip_;
  ::google::protobuf::internal::ArenaStringPtr src_name_;
  ::google::protobuf::internal::ArenaStringPtr dest_name_;
  ::google::protobuf::internal::ArenaStringPtr src_if_name_;
  ::google::protobuf::internal::ArenaStringPtr dest_if_name_;
  friend struct ::protobuf_devcollector_5fmsg_2eproto::TableStruct;
  friend void ::protobuf_devcollector_5fmsg_2eproto::InitDefaultsTopoLinkInfoImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SnmpBasePara

// optional string ip_addr = 1;
inline bool SnmpBasePara::has_ip_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnmpBasePara::set_has_ip_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnmpBasePara::clear_has_ip_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnmpBasePara::clear_ip_addr() {
  ip_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip_addr();
}
inline const ::std::string& SnmpBasePara::ip_addr() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpBasePara.ip_addr)
  return ip_addr_.GetNoArena();
}
inline void SnmpBasePara::set_ip_addr(const ::std::string& value) {
  set_has_ip_addr();
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpBasePara.ip_addr)
}
#if LANG_CXX11
inline void SnmpBasePara::set_ip_addr(::std::string&& value) {
  set_has_ip_addr();
  ip_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpBasePara.ip_addr)
}
#endif
inline void SnmpBasePara::set_ip_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip_addr();
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpBasePara.ip_addr)
}
inline void SnmpBasePara::set_ip_addr(const char* value, size_t size) {
  set_has_ip_addr();
  ip_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpBasePara.ip_addr)
}
inline ::std::string* SnmpBasePara::mutable_ip_addr() {
  set_has_ip_addr();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpBasePara.ip_addr)
  return ip_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpBasePara::release_ip_addr() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpBasePara.ip_addr)
  clear_has_ip_addr();
  return ip_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpBasePara::set_allocated_ip_addr(::std::string* ip_addr) {
  if (ip_addr != NULL) {
    set_has_ip_addr();
  } else {
    clear_has_ip_addr();
  }
  ip_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_addr);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpBasePara.ip_addr)
}

// optional uint32 port = 2;
inline bool SnmpBasePara::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnmpBasePara::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnmpBasePara::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnmpBasePara::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 SnmpBasePara::port() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpBasePara.port)
  return port_;
}
inline void SnmpBasePara::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpBasePara.port)
}

// optional string read_community = 3;
inline bool SnmpBasePara::has_read_community() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnmpBasePara::set_has_read_community() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnmpBasePara::clear_has_read_community() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnmpBasePara::clear_read_community() {
  read_community_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_read_community();
}
inline const ::std::string& SnmpBasePara::read_community() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpBasePara.read_community)
  return read_community_.GetNoArena();
}
inline void SnmpBasePara::set_read_community(const ::std::string& value) {
  set_has_read_community();
  read_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpBasePara.read_community)
}
#if LANG_CXX11
inline void SnmpBasePara::set_read_community(::std::string&& value) {
  set_has_read_community();
  read_community_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpBasePara.read_community)
}
#endif
inline void SnmpBasePara::set_read_community(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_read_community();
  read_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpBasePara.read_community)
}
inline void SnmpBasePara::set_read_community(const char* value, size_t size) {
  set_has_read_community();
  read_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpBasePara.read_community)
}
inline ::std::string* SnmpBasePara::mutable_read_community() {
  set_has_read_community();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpBasePara.read_community)
  return read_community_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpBasePara::release_read_community() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpBasePara.read_community)
  clear_has_read_community();
  return read_community_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpBasePara::set_allocated_read_community(::std::string* read_community) {
  if (read_community != NULL) {
    set_has_read_community();
  } else {
    clear_has_read_community();
  }
  read_community_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), read_community);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpBasePara.read_community)
}

// optional string write_community = 4;
inline bool SnmpBasePara::has_write_community() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnmpBasePara::set_has_write_community() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnmpBasePara::clear_has_write_community() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnmpBasePara::clear_write_community() {
  write_community_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_write_community();
}
inline const ::std::string& SnmpBasePara::write_community() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpBasePara.write_community)
  return write_community_.GetNoArena();
}
inline void SnmpBasePara::set_write_community(const ::std::string& value) {
  set_has_write_community();
  write_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpBasePara.write_community)
}
#if LANG_CXX11
inline void SnmpBasePara::set_write_community(::std::string&& value) {
  set_has_write_community();
  write_community_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpBasePara.write_community)
}
#endif
inline void SnmpBasePara::set_write_community(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_write_community();
  write_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpBasePara.write_community)
}
inline void SnmpBasePara::set_write_community(const char* value, size_t size) {
  set_has_write_community();
  write_community_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpBasePara.write_community)
}
inline ::std::string* SnmpBasePara::mutable_write_community() {
  set_has_write_community();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpBasePara.write_community)
  return write_community_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpBasePara::release_write_community() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpBasePara.write_community)
  clear_has_write_community();
  return write_community_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpBasePara::set_allocated_write_community(::std::string* write_community) {
  if (write_community != NULL) {
    set_has_write_community();
  } else {
    clear_has_write_community();
  }
  write_community_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), write_community);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpBasePara.write_community)
}

// optional .mpfmessage.SnmpVersion version = 5;
inline bool SnmpBasePara::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnmpBasePara::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SnmpBasePara::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SnmpBasePara::clear_version() {
  version_ = 1;
  clear_has_version();
}
inline ::mpfmessage::SnmpVersion SnmpBasePara::version() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpBasePara.version)
  return static_cast< ::mpfmessage::SnmpVersion >(version_);
}
inline void SnmpBasePara::set_version(::mpfmessage::SnmpVersion value) {
  assert(::mpfmessage::SnmpVersion_IsValid(value));
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpBasePara.version)
}

// -------------------------------------------------------------------

// SnmpExtPara

// optional string user = 1;
inline bool SnmpExtPara::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnmpExtPara::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnmpExtPara::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnmpExtPara::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& SnmpExtPara::user() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.user)
  return user_.GetNoArena();
}
inline void SnmpExtPara::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.user)
}
#if LANG_CXX11
inline void SnmpExtPara::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpExtPara.user)
}
#endif
inline void SnmpExtPara::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpExtPara.user)
}
inline void SnmpExtPara::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpExtPara.user)
}
inline ::std::string* SnmpExtPara::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpExtPara.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpExtPara::release_user() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpExtPara.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpExtPara::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpExtPara.user)
}

// optional .mpfmessage.AuthMethod auth_method = 2;
inline bool SnmpExtPara::has_auth_method() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SnmpExtPara::set_has_auth_method() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SnmpExtPara::clear_has_auth_method() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SnmpExtPara::clear_auth_method() {
  auth_method_ = 1;
  clear_has_auth_method();
}
inline ::mpfmessage::AuthMethod SnmpExtPara::auth_method() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.auth_method)
  return static_cast< ::mpfmessage::AuthMethod >(auth_method_);
}
inline void SnmpExtPara::set_auth_method(::mpfmessage::AuthMethod value) {
  assert(::mpfmessage::AuthMethod_IsValid(value));
  set_has_auth_method();
  auth_method_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.auth_method)
}

// optional string auth_password = 3;
inline bool SnmpExtPara::has_auth_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnmpExtPara::set_has_auth_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnmpExtPara::clear_has_auth_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnmpExtPara::clear_auth_password() {
  auth_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_auth_password();
}
inline const ::std::string& SnmpExtPara::auth_password() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.auth_password)
  return auth_password_.GetNoArena();
}
inline void SnmpExtPara::set_auth_password(const ::std::string& value) {
  set_has_auth_password();
  auth_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.auth_password)
}
#if LANG_CXX11
inline void SnmpExtPara::set_auth_password(::std::string&& value) {
  set_has_auth_password();
  auth_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpExtPara.auth_password)
}
#endif
inline void SnmpExtPara::set_auth_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_auth_password();
  auth_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpExtPara.auth_password)
}
inline void SnmpExtPara::set_auth_password(const char* value, size_t size) {
  set_has_auth_password();
  auth_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpExtPara.auth_password)
}
inline ::std::string* SnmpExtPara::mutable_auth_password() {
  set_has_auth_password();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpExtPara.auth_password)
  return auth_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpExtPara::release_auth_password() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpExtPara.auth_password)
  clear_has_auth_password();
  return auth_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpExtPara::set_allocated_auth_password(::std::string* auth_password) {
  if (auth_password != NULL) {
    set_has_auth_password();
  } else {
    clear_has_auth_password();
  }
  auth_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), auth_password);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpExtPara.auth_password)
}

// optional .mpfmessage.EncryptMethod encryptMethod = 4;
inline bool SnmpExtPara::has_encryptmethod() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SnmpExtPara::set_has_encryptmethod() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SnmpExtPara::clear_has_encryptmethod() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SnmpExtPara::clear_encryptmethod() {
  encryptmethod_ = 1;
  clear_has_encryptmethod();
}
inline ::mpfmessage::EncryptMethod SnmpExtPara::encryptmethod() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.encryptMethod)
  return static_cast< ::mpfmessage::EncryptMethod >(encryptmethod_);
}
inline void SnmpExtPara::set_encryptmethod(::mpfmessage::EncryptMethod value) {
  assert(::mpfmessage::EncryptMethod_IsValid(value));
  set_has_encryptmethod();
  encryptmethod_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.encryptMethod)
}

// optional string encrypt_password = 5;
inline bool SnmpExtPara::has_encrypt_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnmpExtPara::set_has_encrypt_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnmpExtPara::clear_has_encrypt_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnmpExtPara::clear_encrypt_password() {
  encrypt_password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_encrypt_password();
}
inline const ::std::string& SnmpExtPara::encrypt_password() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.encrypt_password)
  return encrypt_password_.GetNoArena();
}
inline void SnmpExtPara::set_encrypt_password(const ::std::string& value) {
  set_has_encrypt_password();
  encrypt_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.encrypt_password)
}
#if LANG_CXX11
inline void SnmpExtPara::set_encrypt_password(::std::string&& value) {
  set_has_encrypt_password();
  encrypt_password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpExtPara.encrypt_password)
}
#endif
inline void SnmpExtPara::set_encrypt_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_encrypt_password();
  encrypt_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpExtPara.encrypt_password)
}
inline void SnmpExtPara::set_encrypt_password(const char* value, size_t size) {
  set_has_encrypt_password();
  encrypt_password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpExtPara.encrypt_password)
}
inline ::std::string* SnmpExtPara::mutable_encrypt_password() {
  set_has_encrypt_password();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpExtPara.encrypt_password)
  return encrypt_password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpExtPara::release_encrypt_password() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpExtPara.encrypt_password)
  clear_has_encrypt_password();
  return encrypt_password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpExtPara::set_allocated_encrypt_password(::std::string* encrypt_password) {
  if (encrypt_password != NULL) {
    set_has_encrypt_password();
  } else {
    clear_has_encrypt_password();
  }
  encrypt_password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), encrypt_password);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpExtPara.encrypt_password)
}

// optional string engine_id = 6;
inline bool SnmpExtPara::has_engine_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnmpExtPara::set_has_engine_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnmpExtPara::clear_has_engine_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnmpExtPara::clear_engine_id() {
  engine_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_engine_id();
}
inline const ::std::string& SnmpExtPara::engine_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpExtPara.engine_id)
  return engine_id_.GetNoArena();
}
inline void SnmpExtPara::set_engine_id(const ::std::string& value) {
  set_has_engine_id();
  engine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpExtPara.engine_id)
}
#if LANG_CXX11
inline void SnmpExtPara::set_engine_id(::std::string&& value) {
  set_has_engine_id();
  engine_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SnmpExtPara.engine_id)
}
#endif
inline void SnmpExtPara::set_engine_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_engine_id();
  engine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SnmpExtPara.engine_id)
}
inline void SnmpExtPara::set_engine_id(const char* value, size_t size) {
  set_has_engine_id();
  engine_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SnmpExtPara.engine_id)
}
inline ::std::string* SnmpExtPara::mutable_engine_id() {
  set_has_engine_id();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpExtPara.engine_id)
  return engine_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SnmpExtPara::release_engine_id() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpExtPara.engine_id)
  clear_has_engine_id();
  return engine_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SnmpExtPara::set_allocated_engine_id(::std::string* engine_id) {
  if (engine_id != NULL) {
    set_has_engine_id();
  } else {
    clear_has_engine_id();
  }
  engine_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), engine_id);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpExtPara.engine_id)
}

// -------------------------------------------------------------------

// SnmpInfo

// optional .mpfmessage.SnmpBasePara base_para = 1;
inline bool SnmpInfo::has_base_para() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SnmpInfo::set_has_base_para() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SnmpInfo::clear_has_base_para() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SnmpInfo::clear_base_para() {
  if (base_para_ != NULL) base_para_->Clear();
  clear_has_base_para();
}
inline const ::mpfmessage::SnmpBasePara& SnmpInfo::base_para() const {
  const ::mpfmessage::SnmpBasePara* p = base_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpInfo.base_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpBasePara*>(
      &::mpfmessage::_SnmpBasePara_default_instance_);
}
inline ::mpfmessage::SnmpBasePara* SnmpInfo::release_base_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpInfo.base_para)
  clear_has_base_para();
  ::mpfmessage::SnmpBasePara* temp = base_para_;
  base_para_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpBasePara* SnmpInfo::mutable_base_para() {
  set_has_base_para();
  if (base_para_ == NULL) {
    base_para_ = new ::mpfmessage::SnmpBasePara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpInfo.base_para)
  return base_para_;
}
inline void SnmpInfo::set_allocated_base_para(::mpfmessage::SnmpBasePara* base_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete base_para_;
  }
  if (base_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      base_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, base_para, submessage_arena);
    }
    set_has_base_para();
  } else {
    clear_has_base_para();
  }
  base_para_ = base_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpInfo.base_para)
}

// optional .mpfmessage.SnmpExtPara ext_para = 2;
inline bool SnmpInfo::has_ext_para() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SnmpInfo::set_has_ext_para() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SnmpInfo::clear_has_ext_para() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SnmpInfo::clear_ext_para() {
  if (ext_para_ != NULL) ext_para_->Clear();
  clear_has_ext_para();
}
inline const ::mpfmessage::SnmpExtPara& SnmpInfo::ext_para() const {
  const ::mpfmessage::SnmpExtPara* p = ext_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpInfo.ext_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpExtPara*>(
      &::mpfmessage::_SnmpExtPara_default_instance_);
}
inline ::mpfmessage::SnmpExtPara* SnmpInfo::release_ext_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.SnmpInfo.ext_para)
  clear_has_ext_para();
  ::mpfmessage::SnmpExtPara* temp = ext_para_;
  ext_para_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpExtPara* SnmpInfo::mutable_ext_para() {
  set_has_ext_para();
  if (ext_para_ == NULL) {
    ext_para_ = new ::mpfmessage::SnmpExtPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.SnmpInfo.ext_para)
  return ext_para_;
}
inline void SnmpInfo::set_allocated_ext_para(::mpfmessage::SnmpExtPara* ext_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ext_para_;
  }
  if (ext_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ext_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ext_para, submessage_arena);
    }
    set_has_ext_para();
  } else {
    clear_has_ext_para();
  }
  ext_para_ = ext_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SnmpInfo.ext_para)
}

// optional uint32 timeout = 3;
inline bool SnmpInfo::has_timeout() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SnmpInfo::set_has_timeout() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SnmpInfo::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SnmpInfo::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 SnmpInfo::timeout() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpInfo.timeout)
  return timeout_;
}
inline void SnmpInfo::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpInfo.timeout)
}

// optional uint32 retry = 4;
inline bool SnmpInfo::has_retry() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SnmpInfo::set_has_retry() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SnmpInfo::clear_has_retry() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SnmpInfo::clear_retry() {
  retry_ = 0u;
  clear_has_retry();
}
inline ::google::protobuf::uint32 SnmpInfo::retry() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SnmpInfo.retry)
  return retry_;
}
inline void SnmpInfo::set_retry(::google::protobuf::uint32 value) {
  set_has_retry();
  retry_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SnmpInfo.retry)
}

// -------------------------------------------------------------------

// TelnetPara

// optional string user = 1;
inline bool TelnetPara::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TelnetPara::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TelnetPara::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TelnetPara::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& TelnetPara::user() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.user)
  return user_.GetNoArena();
}
inline void TelnetPara::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.user)
}
#if LANG_CXX11
inline void TelnetPara::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TelnetPara.user)
}
#endif
inline void TelnetPara::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TelnetPara.user)
}
inline void TelnetPara::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TelnetPara.user)
}
inline ::std::string* TelnetPara::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TelnetPara.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TelnetPara::release_user() {
  // @@protoc_insertion_point(field_release:mpfmessage.TelnetPara.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TelnetPara::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TelnetPara.user)
}

// optional string pass = 2;
inline bool TelnetPara::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TelnetPara::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TelnetPara::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TelnetPara::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass();
}
inline const ::std::string& TelnetPara::pass() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.pass)
  return pass_.GetNoArena();
}
inline void TelnetPara::set_pass(const ::std::string& value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.pass)
}
#if LANG_CXX11
inline void TelnetPara::set_pass(::std::string&& value) {
  set_has_pass();
  pass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TelnetPara.pass)
}
#endif
inline void TelnetPara::set_pass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TelnetPara.pass)
}
inline void TelnetPara::set_pass(const char* value, size_t size) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TelnetPara.pass)
}
inline ::std::string* TelnetPara::mutable_pass() {
  set_has_pass();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TelnetPara.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TelnetPara::release_pass() {
  // @@protoc_insertion_point(field_release:mpfmessage.TelnetPara.pass)
  clear_has_pass();
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TelnetPara::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    set_has_pass();
  } else {
    clear_has_pass();
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TelnetPara.pass)
}

// optional uint32 timeout = 3;
inline bool TelnetPara::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TelnetPara::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TelnetPara::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TelnetPara::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 TelnetPara::timeout() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.timeout)
  return timeout_;
}
inline void TelnetPara::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.timeout)
}

// optional uint32 retry = 4;
inline bool TelnetPara::has_retry() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TelnetPara::set_has_retry() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TelnetPara::clear_has_retry() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TelnetPara::clear_retry() {
  retry_ = 0u;
  clear_has_retry();
}
inline ::google::protobuf::uint32 TelnetPara::retry() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.retry)
  return retry_;
}
inline void TelnetPara::set_retry(::google::protobuf::uint32 value) {
  set_has_retry();
  retry_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.retry)
}

// optional string ip = 5;
inline bool TelnetPara::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TelnetPara::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TelnetPara::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TelnetPara::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& TelnetPara::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.ip)
  return ip_.GetNoArena();
}
inline void TelnetPara::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.ip)
}
#if LANG_CXX11
inline void TelnetPara::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TelnetPara.ip)
}
#endif
inline void TelnetPara::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TelnetPara.ip)
}
inline void TelnetPara::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TelnetPara.ip)
}
inline ::std::string* TelnetPara::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TelnetPara.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TelnetPara::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.TelnetPara.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TelnetPara::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TelnetPara.ip)
}

// optional uint32 port = 6;
inline bool TelnetPara::has_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TelnetPara::set_has_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TelnetPara::clear_has_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TelnetPara::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 TelnetPara::port() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TelnetPara.port)
  return port_;
}
inline void TelnetPara::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.TelnetPara.port)
}

// -------------------------------------------------------------------

// SshPara

// optional string user = 1;
inline bool SshPara::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SshPara::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SshPara::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SshPara::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
inline const ::std::string& SshPara::user() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.user)
  return user_.GetNoArena();
}
inline void SshPara::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.user)
}
#if LANG_CXX11
inline void SshPara::set_user(::std::string&& value) {
  set_has_user();
  user_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SshPara.user)
}
#endif
inline void SshPara::set_user(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SshPara.user)
}
inline void SshPara::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SshPara.user)
}
inline ::std::string* SshPara::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SshPara.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SshPara::release_user() {
  // @@protoc_insertion_point(field_release:mpfmessage.SshPara.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SshPara::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SshPara.user)
}

// optional string pass = 2;
inline bool SshPara::has_pass() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SshPara::set_has_pass() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SshPara::clear_has_pass() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SshPara::clear_pass() {
  pass_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pass();
}
inline const ::std::string& SshPara::pass() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.pass)
  return pass_.GetNoArena();
}
inline void SshPara::set_pass(const ::std::string& value) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.pass)
}
#if LANG_CXX11
inline void SshPara::set_pass(::std::string&& value) {
  set_has_pass();
  pass_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SshPara.pass)
}
#endif
inline void SshPara::set_pass(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SshPara.pass)
}
inline void SshPara::set_pass(const char* value, size_t size) {
  set_has_pass();
  pass_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SshPara.pass)
}
inline ::std::string* SshPara::mutable_pass() {
  set_has_pass();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SshPara.pass)
  return pass_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SshPara::release_pass() {
  // @@protoc_insertion_point(field_release:mpfmessage.SshPara.pass)
  clear_has_pass();
  return pass_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SshPara::set_allocated_pass(::std::string* pass) {
  if (pass != NULL) {
    set_has_pass();
  } else {
    clear_has_pass();
  }
  pass_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pass);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SshPara.pass)
}

// optional uint32 port = 3;
inline bool SshPara::has_port() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SshPara::set_has_port() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SshPara::clear_has_port() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SshPara::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 SshPara::port() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.port)
  return port_;
}
inline void SshPara::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.port)
}

// optional uint32 timeout = 4;
inline bool SshPara::has_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SshPara::set_has_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SshPara::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SshPara::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 SshPara::timeout() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.timeout)
  return timeout_;
}
inline void SshPara::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.timeout)
}

// optional uint32 retry = 5;
inline bool SshPara::has_retry() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SshPara::set_has_retry() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SshPara::clear_has_retry() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SshPara::clear_retry() {
  retry_ = 0u;
  clear_has_retry();
}
inline ::google::protobuf::uint32 SshPara::retry() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.retry)
  return retry_;
}
inline void SshPara::set_retry(::google::protobuf::uint32 value) {
  set_has_retry();
  retry_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.retry)
}

// optional string ip = 6;
inline bool SshPara::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SshPara::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SshPara::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SshPara::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& SshPara::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SshPara.ip)
  return ip_.GetNoArena();
}
inline void SshPara::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SshPara.ip)
}
#if LANG_CXX11
inline void SshPara::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SshPara.ip)
}
#endif
inline void SshPara::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SshPara.ip)
}
inline void SshPara::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SshPara.ip)
}
inline ::std::string* SshPara::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SshPara.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SshPara::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.SshPara.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SshPara::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SshPara.ip)
}

// -------------------------------------------------------------------

// PingPara

// optional string ip = 1;
inline bool PingPara::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingPara::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingPara::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingPara::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& PingPara::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPara.ip)
  return ip_.GetNoArena();
}
inline void PingPara::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.PingPara.ip)
}
#if LANG_CXX11
inline void PingPara::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.PingPara.ip)
}
#endif
inline void PingPara::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.PingPara.ip)
}
inline void PingPara::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.PingPara.ip)
}
inline ::std::string* PingPara::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.PingPara.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PingPara::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.PingPara.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PingPara::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.PingPara.ip)
}

// optional uint32 retry = 2;
inline bool PingPara::has_retry() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingPara::set_has_retry() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingPara::clear_has_retry() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingPara::clear_retry() {
  retry_ = 0u;
  clear_has_retry();
}
inline ::google::protobuf::uint32 PingPara::retry() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPara.retry)
  return retry_;
}
inline void PingPara::set_retry(::google::protobuf::uint32 value) {
  set_has_retry();
  retry_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPara.retry)
}

// optional uint32 res_id = 3;
inline bool PingPara::has_res_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PingPara::set_has_res_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PingPara::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PingPara::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 PingPara::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPara.res_id)
  return res_id_;
}
inline void PingPara::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPara.res_id)
}

// optional uint32 timeout = 4;
inline bool PingPara::has_timeout() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PingPara::set_has_timeout() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PingPara::clear_has_timeout() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PingPara::clear_timeout() {
  timeout_ = 0u;
  clear_has_timeout();
}
inline ::google::protobuf::uint32 PingPara::timeout() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPara.timeout)
  return timeout_;
}
inline void PingPara::set_timeout(::google::protobuf::uint32 value) {
  set_has_timeout();
  timeout_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPara.timeout)
}

// -------------------------------------------------------------------

// DbLoginPara

// optional .mpfmessage.DatabaseType db_type = 1;
inline bool DbLoginPara::has_db_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DbLoginPara::set_has_db_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DbLoginPara::clear_has_db_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DbLoginPara::clear_db_type() {
  db_type_ = 1;
  clear_has_db_type();
}
inline ::mpfmessage::DatabaseType DbLoginPara::db_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.db_type)
  return static_cast< ::mpfmessage::DatabaseType >(db_type_);
}
inline void DbLoginPara::set_db_type(::mpfmessage::DatabaseType value) {
  assert(::mpfmessage::DatabaseType_IsValid(value));
  set_has_db_type();
  db_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.db_type)
}

// optional string login_ip = 2;
inline bool DbLoginPara::has_login_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DbLoginPara::set_has_login_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DbLoginPara::clear_has_login_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DbLoginPara::clear_login_ip() {
  login_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_login_ip();
}
inline const ::std::string& DbLoginPara::login_ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.login_ip)
  return login_ip_.GetNoArena();
}
inline void DbLoginPara::set_login_ip(const ::std::string& value) {
  set_has_login_ip();
  login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.login_ip)
}
#if LANG_CXX11
inline void DbLoginPara::set_login_ip(::std::string&& value) {
  set_has_login_ip();
  login_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DbLoginPara.login_ip)
}
#endif
inline void DbLoginPara::set_login_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_login_ip();
  login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DbLoginPara.login_ip)
}
inline void DbLoginPara::set_login_ip(const char* value, size_t size) {
  set_has_login_ip();
  login_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DbLoginPara.login_ip)
}
inline ::std::string* DbLoginPara::mutable_login_ip() {
  set_has_login_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DbLoginPara.login_ip)
  return login_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbLoginPara::release_login_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.DbLoginPara.login_ip)
  clear_has_login_ip();
  return login_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbLoginPara::set_allocated_login_ip(::std::string* login_ip) {
  if (login_ip != NULL) {
    set_has_login_ip();
  } else {
    clear_has_login_ip();
  }
  login_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), login_ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DbLoginPara.login_ip)
}

// optional uint32 port = 3;
inline bool DbLoginPara::has_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DbLoginPara::set_has_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DbLoginPara::clear_has_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DbLoginPara::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 DbLoginPara::port() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.port)
  return port_;
}
inline void DbLoginPara::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.port)
}

// optional .mpfmessage.OSTYPE os_type = 4;
inline bool DbLoginPara::has_os_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DbLoginPara::set_has_os_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DbLoginPara::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DbLoginPara::clear_os_type() {
  os_type_ = 1;
  clear_has_os_type();
}
inline ::mpfmessage::OSTYPE DbLoginPara::os_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.os_type)
  return static_cast< ::mpfmessage::OSTYPE >(os_type_);
}
inline void DbLoginPara::set_os_type(::mpfmessage::OSTYPE value) {
  assert(::mpfmessage::OSTYPE_IsValid(value));
  set_has_os_type();
  os_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.os_type)
}

// optional string dbname = 5;
inline bool DbLoginPara::has_dbname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DbLoginPara::set_has_dbname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DbLoginPara::clear_has_dbname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DbLoginPara::clear_dbname() {
  dbname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dbname();
}
inline const ::std::string& DbLoginPara::dbname() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.dbname)
  return dbname_.GetNoArena();
}
inline void DbLoginPara::set_dbname(const ::std::string& value) {
  set_has_dbname();
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.dbname)
}
#if LANG_CXX11
inline void DbLoginPara::set_dbname(::std::string&& value) {
  set_has_dbname();
  dbname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DbLoginPara.dbname)
}
#endif
inline void DbLoginPara::set_dbname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dbname();
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DbLoginPara.dbname)
}
inline void DbLoginPara::set_dbname(const char* value, size_t size) {
  set_has_dbname();
  dbname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DbLoginPara.dbname)
}
inline ::std::string* DbLoginPara::mutable_dbname() {
  set_has_dbname();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DbLoginPara.dbname)
  return dbname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbLoginPara::release_dbname() {
  // @@protoc_insertion_point(field_release:mpfmessage.DbLoginPara.dbname)
  clear_has_dbname();
  return dbname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbLoginPara::set_allocated_dbname(::std::string* dbname) {
  if (dbname != NULL) {
    set_has_dbname();
  } else {
    clear_has_dbname();
  }
  dbname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dbname);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DbLoginPara.dbname)
}

// optional string uid = 6;
inline bool DbLoginPara::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DbLoginPara::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DbLoginPara::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DbLoginPara::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
inline const ::std::string& DbLoginPara::uid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.uid)
  return uid_.GetNoArena();
}
inline void DbLoginPara::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.uid)
}
#if LANG_CXX11
inline void DbLoginPara::set_uid(::std::string&& value) {
  set_has_uid();
  uid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DbLoginPara.uid)
}
#endif
inline void DbLoginPara::set_uid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DbLoginPara.uid)
}
inline void DbLoginPara::set_uid(const char* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DbLoginPara.uid)
}
inline ::std::string* DbLoginPara::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DbLoginPara.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbLoginPara::release_uid() {
  // @@protoc_insertion_point(field_release:mpfmessage.DbLoginPara.uid)
  clear_has_uid();
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbLoginPara::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DbLoginPara.uid)
}

// optional string password = 7;
inline bool DbLoginPara::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DbLoginPara::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DbLoginPara::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DbLoginPara::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& DbLoginPara::password() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.password)
  return password_.GetNoArena();
}
inline void DbLoginPara::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.password)
}
#if LANG_CXX11
inline void DbLoginPara::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DbLoginPara.password)
}
#endif
inline void DbLoginPara::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DbLoginPara.password)
}
inline void DbLoginPara::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DbLoginPara.password)
}
inline ::std::string* DbLoginPara::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DbLoginPara.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbLoginPara::release_password() {
  // @@protoc_insertion_point(field_release:mpfmessage.DbLoginPara.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbLoginPara::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DbLoginPara.password)
}

// optional string db_version = 8;
inline bool DbLoginPara::has_db_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DbLoginPara::set_has_db_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DbLoginPara::clear_has_db_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DbLoginPara::clear_db_version() {
  db_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_db_version();
}
inline const ::std::string& DbLoginPara::db_version() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DbLoginPara.db_version)
  return db_version_.GetNoArena();
}
inline void DbLoginPara::set_db_version(const ::std::string& value) {
  set_has_db_version();
  db_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DbLoginPara.db_version)
}
#if LANG_CXX11
inline void DbLoginPara::set_db_version(::std::string&& value) {
  set_has_db_version();
  db_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DbLoginPara.db_version)
}
#endif
inline void DbLoginPara::set_db_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_db_version();
  db_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DbLoginPara.db_version)
}
inline void DbLoginPara::set_db_version(const char* value, size_t size) {
  set_has_db_version();
  db_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DbLoginPara.db_version)
}
inline ::std::string* DbLoginPara::mutable_db_version() {
  set_has_db_version();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DbLoginPara.db_version)
  return db_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DbLoginPara::release_db_version() {
  // @@protoc_insertion_point(field_release:mpfmessage.DbLoginPara.db_version)
  clear_has_db_version();
  return db_version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DbLoginPara::set_allocated_db_version(::std::string* db_version) {
  if (db_version != NULL) {
    set_has_db_version();
  } else {
    clear_has_db_version();
  }
  db_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), db_version);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DbLoginPara.db_version)
}

// -------------------------------------------------------------------

// NetDevBaseInfo

// optional .mpfmessage.Status dev_status = 1;
inline bool NetDevBaseInfo::has_dev_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NetDevBaseInfo::set_has_dev_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NetDevBaseInfo::clear_has_dev_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NetDevBaseInfo::clear_dev_status() {
  dev_status_ = 1;
  clear_has_dev_status();
}
inline ::mpfmessage::Status NetDevBaseInfo::dev_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.dev_status)
  return static_cast< ::mpfmessage::Status >(dev_status_);
}
inline void NetDevBaseInfo::set_dev_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_dev_status();
  dev_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.dev_status)
}

// optional .mpfmessage.ResType dev_type = 2;
inline bool NetDevBaseInfo::has_dev_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NetDevBaseInfo::set_has_dev_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NetDevBaseInfo::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NetDevBaseInfo::clear_dev_type() {
  dev_type_ = 1;
  clear_has_dev_type();
}
inline ::mpfmessage::ResType NetDevBaseInfo::dev_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.dev_type)
  return static_cast< ::mpfmessage::ResType >(dev_type_);
}
inline void NetDevBaseInfo::set_dev_type(::mpfmessage::ResType value) {
  assert(::mpfmessage::ResType_IsValid(value));
  set_has_dev_type();
  dev_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.dev_type)
}

// optional string dev_serial = 3;
inline bool NetDevBaseInfo::has_dev_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NetDevBaseInfo::set_has_dev_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NetDevBaseInfo::clear_has_dev_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NetDevBaseInfo::clear_dev_serial() {
  dev_serial_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dev_serial();
}
inline const ::std::string& NetDevBaseInfo::dev_serial() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.dev_serial)
  return dev_serial_.GetNoArena();
}
inline void NetDevBaseInfo::set_dev_serial(const ::std::string& value) {
  set_has_dev_serial();
  dev_serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.dev_serial)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_dev_serial(::std::string&& value) {
  set_has_dev_serial();
  dev_serial_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.dev_serial)
}
#endif
inline void NetDevBaseInfo::set_dev_serial(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dev_serial();
  dev_serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.dev_serial)
}
inline void NetDevBaseInfo::set_dev_serial(const char* value, size_t size) {
  set_has_dev_serial();
  dev_serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.dev_serial)
}
inline ::std::string* NetDevBaseInfo::mutable_dev_serial() {
  set_has_dev_serial();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.dev_serial)
  return dev_serial_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_dev_serial() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.dev_serial)
  clear_has_dev_serial();
  return dev_serial_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_dev_serial(::std::string* dev_serial) {
  if (dev_serial != NULL) {
    set_has_dev_serial();
  } else {
    clear_has_dev_serial();
  }
  dev_serial_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dev_serial);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.dev_serial)
}

// optional string sys_oid = 4;
inline bool NetDevBaseInfo::has_sys_oid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NetDevBaseInfo::set_has_sys_oid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NetDevBaseInfo::clear_has_sys_oid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NetDevBaseInfo::clear_sys_oid() {
  sys_oid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sys_oid();
}
inline const ::std::string& NetDevBaseInfo::sys_oid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.sys_oid)
  return sys_oid_.GetNoArena();
}
inline void NetDevBaseInfo::set_sys_oid(const ::std::string& value) {
  set_has_sys_oid();
  sys_oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.sys_oid)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_sys_oid(::std::string&& value) {
  set_has_sys_oid();
  sys_oid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.sys_oid)
}
#endif
inline void NetDevBaseInfo::set_sys_oid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sys_oid();
  sys_oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.sys_oid)
}
inline void NetDevBaseInfo::set_sys_oid(const char* value, size_t size) {
  set_has_sys_oid();
  sys_oid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.sys_oid)
}
inline ::std::string* NetDevBaseInfo::mutable_sys_oid() {
  set_has_sys_oid();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.sys_oid)
  return sys_oid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_sys_oid() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.sys_oid)
  clear_has_sys_oid();
  return sys_oid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_sys_oid(::std::string* sys_oid) {
  if (sys_oid != NULL) {
    set_has_sys_oid();
  } else {
    clear_has_sys_oid();
  }
  sys_oid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sys_oid);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.sys_oid)
}

// optional string sys_desc = 5;
inline bool NetDevBaseInfo::has_sys_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NetDevBaseInfo::set_has_sys_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NetDevBaseInfo::clear_has_sys_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NetDevBaseInfo::clear_sys_desc() {
  sys_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sys_desc();
}
inline const ::std::string& NetDevBaseInfo::sys_desc() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.sys_desc)
  return sys_desc_.GetNoArena();
}
inline void NetDevBaseInfo::set_sys_desc(const ::std::string& value) {
  set_has_sys_desc();
  sys_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.sys_desc)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_sys_desc(::std::string&& value) {
  set_has_sys_desc();
  sys_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.sys_desc)
}
#endif
inline void NetDevBaseInfo::set_sys_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sys_desc();
  sys_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.sys_desc)
}
inline void NetDevBaseInfo::set_sys_desc(const char* value, size_t size) {
  set_has_sys_desc();
  sys_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.sys_desc)
}
inline ::std::string* NetDevBaseInfo::mutable_sys_desc() {
  set_has_sys_desc();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.sys_desc)
  return sys_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_sys_desc() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.sys_desc)
  clear_has_sys_desc();
  return sys_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_sys_desc(::std::string* sys_desc) {
  if (sys_desc != NULL) {
    set_has_sys_desc();
  } else {
    clear_has_sys_desc();
  }
  sys_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sys_desc);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.sys_desc)
}

// optional string sys_name = 6;
inline bool NetDevBaseInfo::has_sys_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NetDevBaseInfo::set_has_sys_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NetDevBaseInfo::clear_has_sys_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NetDevBaseInfo::clear_sys_name() {
  sys_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sys_name();
}
inline const ::std::string& NetDevBaseInfo::sys_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.sys_name)
  return sys_name_.GetNoArena();
}
inline void NetDevBaseInfo::set_sys_name(const ::std::string& value) {
  set_has_sys_name();
  sys_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.sys_name)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_sys_name(::std::string&& value) {
  set_has_sys_name();
  sys_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.sys_name)
}
#endif
inline void NetDevBaseInfo::set_sys_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sys_name();
  sys_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.sys_name)
}
inline void NetDevBaseInfo::set_sys_name(const char* value, size_t size) {
  set_has_sys_name();
  sys_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.sys_name)
}
inline ::std::string* NetDevBaseInfo::mutable_sys_name() {
  set_has_sys_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.sys_name)
  return sys_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_sys_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.sys_name)
  clear_has_sys_name();
  return sys_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_sys_name(::std::string* sys_name) {
  if (sys_name != NULL) {
    set_has_sys_name();
  } else {
    clear_has_sys_name();
  }
  sys_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sys_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.sys_name)
}

// optional string contactor = 7;
inline bool NetDevBaseInfo::has_contactor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NetDevBaseInfo::set_has_contactor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NetDevBaseInfo::clear_has_contactor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NetDevBaseInfo::clear_contactor() {
  contactor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_contactor();
}
inline const ::std::string& NetDevBaseInfo::contactor() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.contactor)
  return contactor_.GetNoArena();
}
inline void NetDevBaseInfo::set_contactor(const ::std::string& value) {
  set_has_contactor();
  contactor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.contactor)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_contactor(::std::string&& value) {
  set_has_contactor();
  contactor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.contactor)
}
#endif
inline void NetDevBaseInfo::set_contactor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_contactor();
  contactor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.contactor)
}
inline void NetDevBaseInfo::set_contactor(const char* value, size_t size) {
  set_has_contactor();
  contactor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.contactor)
}
inline ::std::string* NetDevBaseInfo::mutable_contactor() {
  set_has_contactor();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.contactor)
  return contactor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_contactor() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.contactor)
  clear_has_contactor();
  return contactor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_contactor(::std::string* contactor) {
  if (contactor != NULL) {
    set_has_contactor();
  } else {
    clear_has_contactor();
  }
  contactor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contactor);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.contactor)
}

// optional string location = 8;
inline bool NetDevBaseInfo::has_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NetDevBaseInfo::set_has_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NetDevBaseInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NetDevBaseInfo::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_location();
}
inline const ::std::string& NetDevBaseInfo::location() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.location)
  return location_.GetNoArena();
}
inline void NetDevBaseInfo::set_location(const ::std::string& value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.location)
}
#if LANG_CXX11
inline void NetDevBaseInfo::set_location(::std::string&& value) {
  set_has_location();
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.NetDevBaseInfo.location)
}
#endif
inline void NetDevBaseInfo::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.NetDevBaseInfo.location)
}
inline void NetDevBaseInfo::set_location(const char* value, size_t size) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.NetDevBaseInfo.location)
}
inline ::std::string* NetDevBaseInfo::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:mpfmessage.NetDevBaseInfo.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NetDevBaseInfo::release_location() {
  // @@protoc_insertion_point(field_release:mpfmessage.NetDevBaseInfo.location)
  clear_has_location();
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NetDevBaseInfo::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.NetDevBaseInfo.location)
}

// optional uint32 up_time = 9;
inline bool NetDevBaseInfo::has_up_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NetDevBaseInfo::set_has_up_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NetDevBaseInfo::clear_has_up_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NetDevBaseInfo::clear_up_time() {
  up_time_ = 0u;
  clear_has_up_time();
}
inline ::google::protobuf::uint32 NetDevBaseInfo::up_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.up_time)
  return up_time_;
}
inline void NetDevBaseInfo::set_up_time(::google::protobuf::uint32 value) {
  set_has_up_time();
  up_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.up_time)
}

// optional uint32 syn_time = 10;
inline bool NetDevBaseInfo::has_syn_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NetDevBaseInfo::set_has_syn_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NetDevBaseInfo::clear_has_syn_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NetDevBaseInfo::clear_syn_time() {
  syn_time_ = 0u;
  clear_has_syn_time();
}
inline ::google::protobuf::uint32 NetDevBaseInfo::syn_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.NetDevBaseInfo.syn_time)
  return syn_time_;
}
inline void NetDevBaseInfo::set_syn_time(::google::protobuf::uint32 value) {
  set_has_syn_time();
  syn_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.NetDevBaseInfo.syn_time)
}

// -------------------------------------------------------------------

// DiskInfo

// optional .mpfmessage.DISK_ACCESS disk_access = 1;
inline bool DiskInfo::has_disk_access() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiskInfo::set_has_disk_access() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiskInfo::clear_has_disk_access() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiskInfo::clear_disk_access() {
  disk_access_ = 1;
  clear_has_disk_access();
}
inline ::mpfmessage::DISK_ACCESS DiskInfo::disk_access() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiskInfo.disk_access)
  return static_cast< ::mpfmessage::DISK_ACCESS >(disk_access_);
}
inline void DiskInfo::set_disk_access(::mpfmessage::DISK_ACCESS value) {
  assert(::mpfmessage::DISK_ACCESS_IsValid(value));
  set_has_disk_access();
  disk_access_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DiskInfo.disk_access)
}

// optional .mpfmessage.DISK_MEDIA_TYPE media_type = 2;
inline bool DiskInfo::has_media_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiskInfo::set_has_media_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiskInfo::clear_has_media_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiskInfo::clear_media_type() {
  media_type_ = 1;
  clear_has_media_type();
}
inline ::mpfmessage::DISK_MEDIA_TYPE DiskInfo::media_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiskInfo.media_type)
  return static_cast< ::mpfmessage::DISK_MEDIA_TYPE >(media_type_);
}
inline void DiskInfo::set_media_type(::mpfmessage::DISK_MEDIA_TYPE value) {
  assert(::mpfmessage::DISK_MEDIA_TYPE_IsValid(value));
  set_has_media_type();
  media_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DiskInfo.media_type)
}

// optional uint32 disk_size = 3;
inline bool DiskInfo::has_disk_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiskInfo::set_has_disk_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiskInfo::clear_has_disk_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiskInfo::clear_disk_size() {
  disk_size_ = 0u;
  clear_has_disk_size();
}
inline ::google::protobuf::uint32 DiskInfo::disk_size() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiskInfo.disk_size)
  return disk_size_;
}
inline void DiskInfo::set_disk_size(::google::protobuf::uint32 value) {
  set_has_disk_size();
  disk_size_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DiskInfo.disk_size)
}

// -------------------------------------------------------------------

// PartitionInfo

// optional uint32 part_index = 1;
inline bool PartitionInfo::has_part_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PartitionInfo::set_has_part_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PartitionInfo::clear_has_part_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PartitionInfo::clear_part_index() {
  part_index_ = 0u;
  clear_has_part_index();
}
inline ::google::protobuf::uint32 PartitionInfo::part_index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PartitionInfo.part_index)
  return part_index_;
}
inline void PartitionInfo::set_part_index(::google::protobuf::uint32 value) {
  set_has_part_index();
  part_index_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PartitionInfo.part_index)
}

// optional string part_name = 2;
inline bool PartitionInfo::has_part_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PartitionInfo::set_has_part_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PartitionInfo::clear_has_part_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PartitionInfo::clear_part_name() {
  part_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_part_name();
}
inline const ::std::string& PartitionInfo::part_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PartitionInfo.part_name)
  return part_name_.GetNoArena();
}
inline void PartitionInfo::set_part_name(const ::std::string& value) {
  set_has_part_name();
  part_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.PartitionInfo.part_name)
}
#if LANG_CXX11
inline void PartitionInfo::set_part_name(::std::string&& value) {
  set_has_part_name();
  part_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.PartitionInfo.part_name)
}
#endif
inline void PartitionInfo::set_part_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_part_name();
  part_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.PartitionInfo.part_name)
}
inline void PartitionInfo::set_part_name(const char* value, size_t size) {
  set_has_part_name();
  part_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.PartitionInfo.part_name)
}
inline ::std::string* PartitionInfo::mutable_part_name() {
  set_has_part_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.PartitionInfo.part_name)
  return part_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PartitionInfo::release_part_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.PartitionInfo.part_name)
  clear_has_part_name();
  return part_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PartitionInfo::set_allocated_part_name(::std::string* part_name) {
  if (part_name != NULL) {
    set_has_part_name();
  } else {
    clear_has_part_name();
  }
  part_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), part_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.PartitionInfo.part_name)
}

// optional uint32 part_size = 3;
inline bool PartitionInfo::has_part_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PartitionInfo::set_has_part_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PartitionInfo::clear_has_part_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PartitionInfo::clear_part_size() {
  part_size_ = 0u;
  clear_has_part_size();
}
inline ::google::protobuf::uint32 PartitionInfo::part_size() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PartitionInfo.part_size)
  return part_size_;
}
inline void PartitionInfo::set_part_size(::google::protobuf::uint32 value) {
  set_has_part_size();
  part_size_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PartitionInfo.part_size)
}

// optional uint32 part_used = 4;
inline bool PartitionInfo::has_part_used() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PartitionInfo::set_has_part_used() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PartitionInfo::clear_has_part_used() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PartitionInfo::clear_part_used() {
  part_used_ = 0u;
  clear_has_part_used();
}
inline ::google::protobuf::uint32 PartitionInfo::part_used() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PartitionInfo.part_used)
  return part_used_;
}
inline void PartitionInfo::set_part_used(::google::protobuf::uint32 value) {
  set_has_part_used();
  part_used_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PartitionInfo.part_used)
}

// -------------------------------------------------------------------

// ProcessorInfo

// optional uint32 processor_index = 1;
inline bool ProcessorInfo::has_processor_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessorInfo::set_has_processor_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessorInfo::clear_has_processor_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessorInfo::clear_processor_index() {
  processor_index_ = 0u;
  clear_has_processor_index();
}
inline ::google::protobuf::uint32 ProcessorInfo::processor_index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessorInfo.processor_index)
  return processor_index_;
}
inline void ProcessorInfo::set_processor_index(::google::protobuf::uint32 value) {
  set_has_processor_index();
  processor_index_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessorInfo.processor_index)
}

// optional string processor_desc = 2;
inline bool ProcessorInfo::has_processor_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessorInfo::set_has_processor_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessorInfo::clear_has_processor_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessorInfo::clear_processor_desc() {
  processor_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_processor_desc();
}
inline const ::std::string& ProcessorInfo::processor_desc() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessorInfo.processor_desc)
  return processor_desc_.GetNoArena();
}
inline void ProcessorInfo::set_processor_desc(const ::std::string& value) {
  set_has_processor_desc();
  processor_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessorInfo.processor_desc)
}
#if LANG_CXX11
inline void ProcessorInfo::set_processor_desc(::std::string&& value) {
  set_has_processor_desc();
  processor_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ProcessorInfo.processor_desc)
}
#endif
inline void ProcessorInfo::set_processor_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_processor_desc();
  processor_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ProcessorInfo.processor_desc)
}
inline void ProcessorInfo::set_processor_desc(const char* value, size_t size) {
  set_has_processor_desc();
  processor_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ProcessorInfo.processor_desc)
}
inline ::std::string* ProcessorInfo::mutable_processor_desc() {
  set_has_processor_desc();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ProcessorInfo.processor_desc)
  return processor_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessorInfo::release_processor_desc() {
  // @@protoc_insertion_point(field_release:mpfmessage.ProcessorInfo.processor_desc)
  clear_has_processor_desc();
  return processor_desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessorInfo::set_allocated_processor_desc(::std::string* processor_desc) {
  if (processor_desc != NULL) {
    set_has_processor_desc();
  } else {
    clear_has_processor_desc();
  }
  processor_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), processor_desc);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ProcessorInfo.processor_desc)
}

// optional uint32 processor_load = 3;
inline bool ProcessorInfo::has_processor_load() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessorInfo::set_has_processor_load() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessorInfo::clear_has_processor_load() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessorInfo::clear_processor_load() {
  processor_load_ = 0u;
  clear_has_processor_load();
}
inline ::google::protobuf::uint32 ProcessorInfo::processor_load() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessorInfo.processor_load)
  return processor_load_;
}
inline void ProcessorInfo::set_processor_load(::google::protobuf::uint32 value) {
  set_has_processor_load();
  processor_load_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessorInfo.processor_load)
}

// -------------------------------------------------------------------

// HostBaseInfo

// optional string sys_time = 1;
inline bool HostBaseInfo::has_sys_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HostBaseInfo::set_has_sys_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HostBaseInfo::clear_has_sys_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HostBaseInfo::clear_sys_time() {
  sys_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sys_time();
}
inline const ::std::string& HostBaseInfo::sys_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.sys_time)
  return sys_time_.GetNoArena();
}
inline void HostBaseInfo::set_sys_time(const ::std::string& value) {
  set_has_sys_time();
  sys_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.sys_time)
}
#if LANG_CXX11
inline void HostBaseInfo::set_sys_time(::std::string&& value) {
  set_has_sys_time();
  sys_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.HostBaseInfo.sys_time)
}
#endif
inline void HostBaseInfo::set_sys_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sys_time();
  sys_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.HostBaseInfo.sys_time)
}
inline void HostBaseInfo::set_sys_time(const char* value, size_t size) {
  set_has_sys_time();
  sys_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.HostBaseInfo.sys_time)
}
inline ::std::string* HostBaseInfo::mutable_sys_time() {
  set_has_sys_time();
  // @@protoc_insertion_point(field_mutable:mpfmessage.HostBaseInfo.sys_time)
  return sys_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HostBaseInfo::release_sys_time() {
  // @@protoc_insertion_point(field_release:mpfmessage.HostBaseInfo.sys_time)
  clear_has_sys_time();
  return sys_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HostBaseInfo::set_allocated_sys_time(::std::string* sys_time) {
  if (sys_time != NULL) {
    set_has_sys_time();
  } else {
    clear_has_sys_time();
  }
  sys_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sys_time);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.HostBaseInfo.sys_time)
}

// optional uint32 run_time = 2;
inline bool HostBaseInfo::has_run_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HostBaseInfo::set_has_run_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HostBaseInfo::clear_has_run_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HostBaseInfo::clear_run_time() {
  run_time_ = 0u;
  clear_has_run_time();
}
inline ::google::protobuf::uint32 HostBaseInfo::run_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.run_time)
  return run_time_;
}
inline void HostBaseInfo::set_run_time(::google::protobuf::uint32 value) {
  set_has_run_time();
  run_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.run_time)
}

// optional uint32 online_user_num = 3;
inline bool HostBaseInfo::has_online_user_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HostBaseInfo::set_has_online_user_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HostBaseInfo::clear_has_online_user_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HostBaseInfo::clear_online_user_num() {
  online_user_num_ = 0u;
  clear_has_online_user_num();
}
inline ::google::protobuf::uint32 HostBaseInfo::online_user_num() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.online_user_num)
  return online_user_num_;
}
inline void HostBaseInfo::set_online_user_num(::google::protobuf::uint32 value) {
  set_has_online_user_num();
  online_user_num_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.online_user_num)
}

// optional uint32 process_num = 4;
inline bool HostBaseInfo::has_process_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HostBaseInfo::set_has_process_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HostBaseInfo::clear_has_process_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HostBaseInfo::clear_process_num() {
  process_num_ = 0u;
  clear_has_process_num();
}
inline ::google::protobuf::uint32 HostBaseInfo::process_num() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.process_num)
  return process_num_;
}
inline void HostBaseInfo::set_process_num(::google::protobuf::uint32 value) {
  set_has_process_num();
  process_num_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.process_num)
}

// repeated .mpfmessage.ProcessorInfo cpulist = 5;
inline int HostBaseInfo::cpulist_size() const {
  return cpulist_.size();
}
inline void HostBaseInfo::clear_cpulist() {
  cpulist_.Clear();
}
inline const ::mpfmessage::ProcessorInfo& HostBaseInfo::cpulist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.cpulist)
  return cpulist_.Get(index);
}
inline ::mpfmessage::ProcessorInfo* HostBaseInfo::mutable_cpulist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.HostBaseInfo.cpulist)
  return cpulist_.Mutable(index);
}
inline ::mpfmessage::ProcessorInfo* HostBaseInfo::add_cpulist() {
  // @@protoc_insertion_point(field_add:mpfmessage.HostBaseInfo.cpulist)
  return cpulist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessorInfo >*
HostBaseInfo::mutable_cpulist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.HostBaseInfo.cpulist)
  return &cpulist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessorInfo >&
HostBaseInfo::cpulist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.HostBaseInfo.cpulist)
  return cpulist_;
}

// optional uint32 total_phy_memory = 6;
inline bool HostBaseInfo::has_total_phy_memory() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HostBaseInfo::set_has_total_phy_memory() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HostBaseInfo::clear_has_total_phy_memory() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HostBaseInfo::clear_total_phy_memory() {
  total_phy_memory_ = 0u;
  clear_has_total_phy_memory();
}
inline ::google::protobuf::uint32 HostBaseInfo::total_phy_memory() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.total_phy_memory)
  return total_phy_memory_;
}
inline void HostBaseInfo::set_total_phy_memory(::google::protobuf::uint32 value) {
  set_has_total_phy_memory();
  total_phy_memory_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.total_phy_memory)
}

// optional uint32 total_virtual_memory = 7;
inline bool HostBaseInfo::has_total_virtual_memory() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HostBaseInfo::set_has_total_virtual_memory() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HostBaseInfo::clear_has_total_virtual_memory() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HostBaseInfo::clear_total_virtual_memory() {
  total_virtual_memory_ = 0u;
  clear_has_total_virtual_memory();
}
inline ::google::protobuf::uint32 HostBaseInfo::total_virtual_memory() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.total_virtual_memory)
  return total_virtual_memory_;
}
inline void HostBaseInfo::set_total_virtual_memory(::google::protobuf::uint32 value) {
  set_has_total_virtual_memory();
  total_virtual_memory_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.total_virtual_memory)
}

// optional uint32 total_disk_space = 8;
inline bool HostBaseInfo::has_total_disk_space() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HostBaseInfo::set_has_total_disk_space() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HostBaseInfo::clear_has_total_disk_space() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HostBaseInfo::clear_total_disk_space() {
  total_disk_space_ = 0u;
  clear_has_total_disk_space();
}
inline ::google::protobuf::uint32 HostBaseInfo::total_disk_space() const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.total_disk_space)
  return total_disk_space_;
}
inline void HostBaseInfo::set_total_disk_space(::google::protobuf::uint32 value) {
  set_has_total_disk_space();
  total_disk_space_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.HostBaseInfo.total_disk_space)
}

// repeated .mpfmessage.DiskInfo diskList = 9;
inline int HostBaseInfo::disklist_size() const {
  return disklist_.size();
}
inline void HostBaseInfo::clear_disklist() {
  disklist_.Clear();
}
inline const ::mpfmessage::DiskInfo& HostBaseInfo::disklist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.diskList)
  return disklist_.Get(index);
}
inline ::mpfmessage::DiskInfo* HostBaseInfo::mutable_disklist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.HostBaseInfo.diskList)
  return disklist_.Mutable(index);
}
inline ::mpfmessage::DiskInfo* HostBaseInfo::add_disklist() {
  // @@protoc_insertion_point(field_add:mpfmessage.HostBaseInfo.diskList)
  return disklist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::DiskInfo >*
HostBaseInfo::mutable_disklist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.HostBaseInfo.diskList)
  return &disklist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DiskInfo >&
HostBaseInfo::disklist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.HostBaseInfo.diskList)
  return disklist_;
}

// repeated .mpfmessage.PartitionInfo partiList = 10;
inline int HostBaseInfo::partilist_size() const {
  return partilist_.size();
}
inline void HostBaseInfo::clear_partilist() {
  partilist_.Clear();
}
inline const ::mpfmessage::PartitionInfo& HostBaseInfo::partilist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.HostBaseInfo.partiList)
  return partilist_.Get(index);
}
inline ::mpfmessage::PartitionInfo* HostBaseInfo::mutable_partilist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.HostBaseInfo.partiList)
  return partilist_.Mutable(index);
}
inline ::mpfmessage::PartitionInfo* HostBaseInfo::add_partilist() {
  // @@protoc_insertion_point(field_add:mpfmessage.HostBaseInfo.partiList)
  return partilist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >*
HostBaseInfo::mutable_partilist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.HostBaseInfo.partiList)
  return &partilist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >&
HostBaseInfo::partilist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.HostBaseInfo.partiList)
  return partilist_;
}

// -------------------------------------------------------------------

// IfBaseInfo

// optional uint32 index = 1;
inline bool IfBaseInfo::has_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IfBaseInfo::set_has_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IfBaseInfo::clear_has_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IfBaseInfo::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 IfBaseInfo::index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.index)
  return index_;
}
inline void IfBaseInfo::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.index)
}

// optional string desc = 2;
inline bool IfBaseInfo::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IfBaseInfo::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IfBaseInfo::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IfBaseInfo::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& IfBaseInfo::desc() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.desc)
  return desc_.GetNoArena();
}
inline void IfBaseInfo::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.desc)
}
#if LANG_CXX11
inline void IfBaseInfo::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfBaseInfo.desc)
}
#endif
inline void IfBaseInfo::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfBaseInfo.desc)
}
inline void IfBaseInfo::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfBaseInfo.desc)
}
inline ::std::string* IfBaseInfo::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfBaseInfo.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfBaseInfo::release_desc() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfBaseInfo.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfBaseInfo::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfBaseInfo.desc)
}

// optional .mpfmessage.IfType iftype = 3;
inline bool IfBaseInfo::has_iftype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IfBaseInfo::set_has_iftype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IfBaseInfo::clear_has_iftype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IfBaseInfo::clear_iftype() {
  iftype_ = 1;
  clear_has_iftype();
}
inline ::mpfmessage::IfType IfBaseInfo::iftype() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.iftype)
  return static_cast< ::mpfmessage::IfType >(iftype_);
}
inline void IfBaseInfo::set_iftype(::mpfmessage::IfType value) {
  assert(::mpfmessage::IfType_IsValid(value));
  set_has_iftype();
  iftype_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.iftype)
}

// optional bytes if_phys_addr = 4;
inline bool IfBaseInfo::has_if_phys_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IfBaseInfo::set_has_if_phys_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IfBaseInfo::clear_has_if_phys_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IfBaseInfo::clear_if_phys_addr() {
  if_phys_addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_if_phys_addr();
}
inline const ::std::string& IfBaseInfo::if_phys_addr() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.if_phys_addr)
  return if_phys_addr_.GetNoArena();
}
inline void IfBaseInfo::set_if_phys_addr(const ::std::string& value) {
  set_has_if_phys_addr();
  if_phys_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.if_phys_addr)
}
#if LANG_CXX11
inline void IfBaseInfo::set_if_phys_addr(::std::string&& value) {
  set_has_if_phys_addr();
  if_phys_addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfBaseInfo.if_phys_addr)
}
#endif
inline void IfBaseInfo::set_if_phys_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_if_phys_addr();
  if_phys_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfBaseInfo.if_phys_addr)
}
inline void IfBaseInfo::set_if_phys_addr(const void* value, size_t size) {
  set_has_if_phys_addr();
  if_phys_addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfBaseInfo.if_phys_addr)
}
inline ::std::string* IfBaseInfo::mutable_if_phys_addr() {
  set_has_if_phys_addr();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfBaseInfo.if_phys_addr)
  return if_phys_addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfBaseInfo::release_if_phys_addr() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfBaseInfo.if_phys_addr)
  clear_has_if_phys_addr();
  return if_phys_addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfBaseInfo::set_allocated_if_phys_addr(::std::string* if_phys_addr) {
  if (if_phys_addr != NULL) {
    set_has_if_phys_addr();
  } else {
    clear_has_if_phys_addr();
  }
  if_phys_addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), if_phys_addr);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfBaseInfo.if_phys_addr)
}

// optional uint32 rate = 5;
inline bool IfBaseInfo::has_rate() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IfBaseInfo::set_has_rate() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IfBaseInfo::clear_has_rate() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IfBaseInfo::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 IfBaseInfo::rate() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.rate)
  return rate_;
}
inline void IfBaseInfo::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.rate)
}

// optional uint32 mtu = 6;
inline bool IfBaseInfo::has_mtu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IfBaseInfo::set_has_mtu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IfBaseInfo::clear_has_mtu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IfBaseInfo::clear_mtu() {
  mtu_ = 0u;
  clear_has_mtu();
}
inline ::google::protobuf::uint32 IfBaseInfo::mtu() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.mtu)
  return mtu_;
}
inline void IfBaseInfo::set_mtu(::google::protobuf::uint32 value) {
  set_has_mtu();
  mtu_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.mtu)
}

// optional string ip = 7;
inline bool IfBaseInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IfBaseInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IfBaseInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IfBaseInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& IfBaseInfo::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.ip)
  return ip_.GetNoArena();
}
inline void IfBaseInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.ip)
}
#if LANG_CXX11
inline void IfBaseInfo::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfBaseInfo.ip)
}
#endif
inline void IfBaseInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfBaseInfo.ip)
}
inline void IfBaseInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfBaseInfo.ip)
}
inline ::std::string* IfBaseInfo::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfBaseInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfBaseInfo::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfBaseInfo.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfBaseInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfBaseInfo.ip)
}

// optional string mask = 8;
inline bool IfBaseInfo::has_mask() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IfBaseInfo::set_has_mask() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IfBaseInfo::clear_has_mask() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IfBaseInfo::clear_mask() {
  mask_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mask();
}
inline const ::std::string& IfBaseInfo::mask() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.mask)
  return mask_.GetNoArena();
}
inline void IfBaseInfo::set_mask(const ::std::string& value) {
  set_has_mask();
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.mask)
}
#if LANG_CXX11
inline void IfBaseInfo::set_mask(::std::string&& value) {
  set_has_mask();
  mask_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfBaseInfo.mask)
}
#endif
inline void IfBaseInfo::set_mask(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mask();
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfBaseInfo.mask)
}
inline void IfBaseInfo::set_mask(const char* value, size_t size) {
  set_has_mask();
  mask_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfBaseInfo.mask)
}
inline ::std::string* IfBaseInfo::mutable_mask() {
  set_has_mask();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfBaseInfo.mask)
  return mask_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfBaseInfo::release_mask() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfBaseInfo.mask)
  clear_has_mask();
  return mask_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfBaseInfo::set_allocated_mask(::std::string* mask) {
  if (mask != NULL) {
    set_has_mask();
  } else {
    clear_has_mask();
  }
  mask_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mask);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfBaseInfo.mask)
}

// optional .mpfmessage.Status oper_status = 9;
inline bool IfBaseInfo::has_oper_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IfBaseInfo::set_has_oper_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IfBaseInfo::clear_has_oper_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IfBaseInfo::clear_oper_status() {
  oper_status_ = 1;
  clear_has_oper_status();
}
inline ::mpfmessage::Status IfBaseInfo::oper_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.oper_status)
  return static_cast< ::mpfmessage::Status >(oper_status_);
}
inline void IfBaseInfo::set_oper_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_oper_status();
  oper_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.oper_status)
}

// optional .mpfmessage.Status admin_status = 10;
inline bool IfBaseInfo::has_admin_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IfBaseInfo::set_has_admin_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IfBaseInfo::clear_has_admin_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IfBaseInfo::clear_admin_status() {
  admin_status_ = 1;
  clear_has_admin_status();
}
inline ::mpfmessage::Status IfBaseInfo::admin_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.admin_status)
  return static_cast< ::mpfmessage::Status >(admin_status_);
}
inline void IfBaseInfo::set_admin_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_admin_status();
  admin_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.admin_status)
}

// optional string alias = 11;
inline bool IfBaseInfo::has_alias() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IfBaseInfo::set_has_alias() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IfBaseInfo::clear_has_alias() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IfBaseInfo::clear_alias() {
  alias_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_alias();
}
inline const ::std::string& IfBaseInfo::alias() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfBaseInfo.alias)
  return alias_.GetNoArena();
}
inline void IfBaseInfo::set_alias(const ::std::string& value) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfBaseInfo.alias)
}
#if LANG_CXX11
inline void IfBaseInfo::set_alias(::std::string&& value) {
  set_has_alias();
  alias_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfBaseInfo.alias)
}
#endif
inline void IfBaseInfo::set_alias(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfBaseInfo.alias)
}
inline void IfBaseInfo::set_alias(const char* value, size_t size) {
  set_has_alias();
  alias_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfBaseInfo.alias)
}
inline ::std::string* IfBaseInfo::mutable_alias() {
  set_has_alias();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfBaseInfo.alias)
  return alias_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfBaseInfo::release_alias() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfBaseInfo.alias)
  clear_has_alias();
  return alias_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfBaseInfo::set_allocated_alias(::std::string* alias) {
  if (alias != NULL) {
    set_has_alias();
  } else {
    clear_has_alias();
  }
  alias_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), alias);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfBaseInfo.alias)
}

// -------------------------------------------------------------------

// IfResInfo

// optional uint32 dev_resid = 1;
inline bool IfResInfo::has_dev_resid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IfResInfo::set_has_dev_resid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IfResInfo::clear_has_dev_resid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IfResInfo::clear_dev_resid() {
  dev_resid_ = 0u;
  clear_has_dev_resid();
}
inline ::google::protobuf::uint32 IfResInfo::dev_resid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfResInfo.dev_resid)
  return dev_resid_;
}
inline void IfResInfo::set_dev_resid(::google::protobuf::uint32 value) {
  set_has_dev_resid();
  dev_resid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfResInfo.dev_resid)
}

// optional uint32 if_resid = 2;
inline bool IfResInfo::has_if_resid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IfResInfo::set_has_if_resid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IfResInfo::clear_has_if_resid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IfResInfo::clear_if_resid() {
  if_resid_ = 0u;
  clear_has_if_resid();
}
inline ::google::protobuf::uint32 IfResInfo::if_resid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfResInfo.if_resid)
  return if_resid_;
}
inline void IfResInfo::set_if_resid(::google::protobuf::uint32 value) {
  set_has_if_resid();
  if_resid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfResInfo.if_resid)
}

// optional uint32 ifindex = 3;
inline bool IfResInfo::has_ifindex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IfResInfo::set_has_ifindex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IfResInfo::clear_has_ifindex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IfResInfo::clear_ifindex() {
  ifindex_ = 0u;
  clear_has_ifindex();
}
inline ::google::protobuf::uint32 IfResInfo::ifindex() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfResInfo.ifindex)
  return ifindex_;
}
inline void IfResInfo::set_ifindex(::google::protobuf::uint32 value) {
  set_has_ifindex();
  ifindex_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfResInfo.ifindex)
}

// optional string ifdesc = 4;
inline bool IfResInfo::has_ifdesc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IfResInfo::set_has_ifdesc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IfResInfo::clear_has_ifdesc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IfResInfo::clear_ifdesc() {
  ifdesc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ifdesc();
}
inline const ::std::string& IfResInfo::ifdesc() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfResInfo.ifdesc)
  return ifdesc_.GetNoArena();
}
inline void IfResInfo::set_ifdesc(const ::std::string& value) {
  set_has_ifdesc();
  ifdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfResInfo.ifdesc)
}
#if LANG_CXX11
inline void IfResInfo::set_ifdesc(::std::string&& value) {
  set_has_ifdesc();
  ifdesc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfResInfo.ifdesc)
}
#endif
inline void IfResInfo::set_ifdesc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ifdesc();
  ifdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfResInfo.ifdesc)
}
inline void IfResInfo::set_ifdesc(const char* value, size_t size) {
  set_has_ifdesc();
  ifdesc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfResInfo.ifdesc)
}
inline ::std::string* IfResInfo::mutable_ifdesc() {
  set_has_ifdesc();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfResInfo.ifdesc)
  return ifdesc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfResInfo::release_ifdesc() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfResInfo.ifdesc)
  clear_has_ifdesc();
  return ifdesc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfResInfo::set_allocated_ifdesc(::std::string* ifdesc) {
  if (ifdesc != NULL) {
    set_has_ifdesc();
  } else {
    clear_has_ifdesc();
  }
  ifdesc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ifdesc);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfResInfo.ifdesc)
}

// optional string ip = 5;
inline bool IfResInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IfResInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IfResInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IfResInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& IfResInfo::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfResInfo.ip)
  return ip_.GetNoArena();
}
inline void IfResInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfResInfo.ip)
}
#if LANG_CXX11
inline void IfResInfo::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfResInfo.ip)
}
#endif
inline void IfResInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfResInfo.ip)
}
inline void IfResInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfResInfo.ip)
}
inline ::std::string* IfResInfo::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfResInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfResInfo::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfResInfo.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfResInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfResInfo.ip)
}

// -------------------------------------------------------------------

// ProcessInfo

// optional uint32 pid = 1;
inline bool ProcessInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProcessInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProcessInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProcessInfo::clear_pid() {
  pid_ = 0u;
  clear_has_pid();
}
inline ::google::protobuf::uint32 ProcessInfo::pid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.pid)
  return pid_;
}
inline void ProcessInfo::set_pid(::google::protobuf::uint32 value) {
  set_has_pid();
  pid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.pid)
}

// optional string name = 2;
inline bool ProcessInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProcessInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProcessInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProcessInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ProcessInfo::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.name)
  return name_.GetNoArena();
}
inline void ProcessInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.name)
}
#if LANG_CXX11
inline void ProcessInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ProcessInfo.name)
}
#endif
inline void ProcessInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ProcessInfo.name)
}
inline void ProcessInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ProcessInfo.name)
}
inline ::std::string* ProcessInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ProcessInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessInfo::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.ProcessInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ProcessInfo.name)
}

// optional .mpfmessage.SoftwareType type = 3;
inline bool ProcessInfo::has_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProcessInfo::set_has_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProcessInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProcessInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mpfmessage::SoftwareType ProcessInfo::type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.type)
  return static_cast< ::mpfmessage::SoftwareType >(type_);
}
inline void ProcessInfo::set_type(::mpfmessage::SoftwareType value) {
  assert(::mpfmessage::SoftwareType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.type)
}

// optional uint32 cpu_rate = 4;
inline bool ProcessInfo::has_cpu_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProcessInfo::set_has_cpu_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProcessInfo::clear_has_cpu_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProcessInfo::clear_cpu_rate() {
  cpu_rate_ = 0u;
  clear_has_cpu_rate();
}
inline ::google::protobuf::uint32 ProcessInfo::cpu_rate() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.cpu_rate)
  return cpu_rate_;
}
inline void ProcessInfo::set_cpu_rate(::google::protobuf::uint32 value) {
  set_has_cpu_rate();
  cpu_rate_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.cpu_rate)
}

// optional uint32 mem_use = 5;
inline bool ProcessInfo::has_mem_use() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProcessInfo::set_has_mem_use() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProcessInfo::clear_has_mem_use() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProcessInfo::clear_mem_use() {
  mem_use_ = 0u;
  clear_has_mem_use();
}
inline ::google::protobuf::uint32 ProcessInfo::mem_use() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.mem_use)
  return mem_use_;
}
inline void ProcessInfo::set_mem_use(::google::protobuf::uint32 value) {
  set_has_mem_use();
  mem_use_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.mem_use)
}

// optional string run_path = 6;
inline bool ProcessInfo::has_run_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProcessInfo::set_has_run_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProcessInfo::clear_has_run_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProcessInfo::clear_run_path() {
  run_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_path();
}
inline const ::std::string& ProcessInfo::run_path() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.run_path)
  return run_path_.GetNoArena();
}
inline void ProcessInfo::set_run_path(const ::std::string& value) {
  set_has_run_path();
  run_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.run_path)
}
#if LANG_CXX11
inline void ProcessInfo::set_run_path(::std::string&& value) {
  set_has_run_path();
  run_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ProcessInfo.run_path)
}
#endif
inline void ProcessInfo::set_run_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_path();
  run_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ProcessInfo.run_path)
}
inline void ProcessInfo::set_run_path(const char* value, size_t size) {
  set_has_run_path();
  run_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ProcessInfo.run_path)
}
inline ::std::string* ProcessInfo::mutable_run_path() {
  set_has_run_path();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ProcessInfo.run_path)
  return run_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessInfo::release_run_path() {
  // @@protoc_insertion_point(field_release:mpfmessage.ProcessInfo.run_path)
  clear_has_run_path();
  return run_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_run_path(::std::string* run_path) {
  if (run_path != NULL) {
    set_has_run_path();
  } else {
    clear_has_run_path();
  }
  run_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_path);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ProcessInfo.run_path)
}

// optional string parameter = 7;
inline bool ProcessInfo::has_parameter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProcessInfo::set_has_parameter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProcessInfo::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProcessInfo::clear_parameter() {
  parameter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parameter();
}
inline const ::std::string& ProcessInfo::parameter() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.parameter)
  return parameter_.GetNoArena();
}
inline void ProcessInfo::set_parameter(const ::std::string& value) {
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.parameter)
}
#if LANG_CXX11
inline void ProcessInfo::set_parameter(::std::string&& value) {
  set_has_parameter();
  parameter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ProcessInfo.parameter)
}
#endif
inline void ProcessInfo::set_parameter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ProcessInfo.parameter)
}
inline void ProcessInfo::set_parameter(const char* value, size_t size) {
  set_has_parameter();
  parameter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ProcessInfo.parameter)
}
inline ::std::string* ProcessInfo::mutable_parameter() {
  set_has_parameter();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ProcessInfo.parameter)
  return parameter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ProcessInfo::release_parameter() {
  // @@protoc_insertion_point(field_release:mpfmessage.ProcessInfo.parameter)
  clear_has_parameter();
  return parameter_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ProcessInfo::set_allocated_parameter(::std::string* parameter) {
  if (parameter != NULL) {
    set_has_parameter();
  } else {
    clear_has_parameter();
  }
  parameter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parameter);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ProcessInfo.parameter)
}

// optional uint32 status = 8;
inline bool ProcessInfo::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProcessInfo::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProcessInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProcessInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 ProcessInfo::status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ProcessInfo.status)
  return status_;
}
inline void ProcessInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ProcessInfo.status)
}

// -------------------------------------------------------------------

// SoftwareInfo

// optional string name = 1;
inline bool SoftwareInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftwareInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftwareInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftwareInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SoftwareInfo::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SoftwareInfo.name)
  return name_.GetNoArena();
}
inline void SoftwareInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SoftwareInfo.name)
}
#if LANG_CXX11
inline void SoftwareInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SoftwareInfo.name)
}
#endif
inline void SoftwareInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SoftwareInfo.name)
}
inline void SoftwareInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SoftwareInfo.name)
}
inline ::std::string* SoftwareInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SoftwareInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SoftwareInfo::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.SoftwareInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SoftwareInfo.name)
}

// optional .mpfmessage.SoftwareType type = 2;
inline bool SoftwareInfo::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SoftwareInfo::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SoftwareInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SoftwareInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::mpfmessage::SoftwareType SoftwareInfo::type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SoftwareInfo.type)
  return static_cast< ::mpfmessage::SoftwareType >(type_);
}
inline void SoftwareInfo::set_type(::mpfmessage::SoftwareType value) {
  assert(::mpfmessage::SoftwareType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SoftwareInfo.type)
}

// optional string install_time = 3;
inline bool SoftwareInfo::has_install_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SoftwareInfo::set_has_install_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SoftwareInfo::clear_has_install_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SoftwareInfo::clear_install_time() {
  install_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_install_time();
}
inline const ::std::string& SoftwareInfo::install_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SoftwareInfo.install_time)
  return install_time_.GetNoArena();
}
inline void SoftwareInfo::set_install_time(const ::std::string& value) {
  set_has_install_time();
  install_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SoftwareInfo.install_time)
}
#if LANG_CXX11
inline void SoftwareInfo::set_install_time(::std::string&& value) {
  set_has_install_time();
  install_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SoftwareInfo.install_time)
}
#endif
inline void SoftwareInfo::set_install_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_install_time();
  install_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SoftwareInfo.install_time)
}
inline void SoftwareInfo::set_install_time(const char* value, size_t size) {
  set_has_install_time();
  install_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SoftwareInfo.install_time)
}
inline ::std::string* SoftwareInfo::mutable_install_time() {
  set_has_install_time();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SoftwareInfo.install_time)
  return install_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SoftwareInfo::release_install_time() {
  // @@protoc_insertion_point(field_release:mpfmessage.SoftwareInfo.install_time)
  clear_has_install_time();
  return install_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SoftwareInfo::set_allocated_install_time(::std::string* install_time) {
  if (install_time != NULL) {
    set_has_install_time();
  } else {
    clear_has_install_time();
  }
  install_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), install_time);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SoftwareInfo.install_time)
}

// -------------------------------------------------------------------

// PerfParameter

// optional uint32 typeid = 1;
inline bool PerfParameter::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PerfParameter::set_has_typeid_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PerfParameter::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PerfParameter::clear_typeid_() {
  typeid__ = 0u;
  clear_has_typeid_();
}
inline ::google::protobuf::uint32 PerfParameter::typeid_() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PerfParameter.typeid)
  return typeid__;
}
inline void PerfParameter::set_typeid_(::google::protobuf::uint32 value) {
  set_has_typeid_();
  typeid__ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PerfParameter.typeid)
}

// optional string name = 2;
inline bool PerfParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PerfParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PerfParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PerfParameter::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& PerfParameter::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PerfParameter.name)
  return name_.GetNoArena();
}
inline void PerfParameter::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.PerfParameter.name)
}
#if LANG_CXX11
inline void PerfParameter::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.PerfParameter.name)
}
#endif
inline void PerfParameter::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.PerfParameter.name)
}
inline void PerfParameter::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.PerfParameter.name)
}
inline ::std::string* PerfParameter::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.PerfParameter.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PerfParameter::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.PerfParameter.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PerfParameter::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.PerfParameter.name)
}

// optional uint32 value = 3;
inline bool PerfParameter::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PerfParameter::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PerfParameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PerfParameter::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 PerfParameter::value() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PerfParameter.value)
  return value_;
}
inline void PerfParameter::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PerfParameter.value)
}

// -------------------------------------------------------------------

// MidwarePerf

// optional uint32 resid = 1;
inline bool MidwarePerf::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MidwarePerf::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MidwarePerf::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MidwarePerf::clear_resid() {
  resid_ = 0u;
  clear_has_resid();
}
inline ::google::protobuf::uint32 MidwarePerf::resid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.resid)
  return resid_;
}
inline void MidwarePerf::set_resid(::google::protobuf::uint32 value) {
  set_has_resid();
  resid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwarePerf.resid)
}

// optional string name = 2;
inline bool MidwarePerf::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MidwarePerf::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MidwarePerf::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MidwarePerf::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& MidwarePerf::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.name)
  return name_.GetNoArena();
}
inline void MidwarePerf::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.MidwarePerf.name)
}
#if LANG_CXX11
inline void MidwarePerf::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.MidwarePerf.name)
}
#endif
inline void MidwarePerf::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.MidwarePerf.name)
}
inline void MidwarePerf::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.MidwarePerf.name)
}
inline ::std::string* MidwarePerf::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.MidwarePerf.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MidwarePerf::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.MidwarePerf.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MidwarePerf::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MidwarePerf.name)
}

// optional uint32 available = 3;
inline bool MidwarePerf::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MidwarePerf::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MidwarePerf::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MidwarePerf::clear_available() {
  available_ = 0u;
  clear_has_available();
}
inline ::google::protobuf::uint32 MidwarePerf::available() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.available)
  return available_;
}
inline void MidwarePerf::set_available(::google::protobuf::uint32 value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwarePerf.available)
}

// optional uint32 cpu_rate_app = 4;
inline bool MidwarePerf::has_cpu_rate_app() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MidwarePerf::set_has_cpu_rate_app() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MidwarePerf::clear_has_cpu_rate_app() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MidwarePerf::clear_cpu_rate_app() {
  cpu_rate_app_ = 0u;
  clear_has_cpu_rate_app();
}
inline ::google::protobuf::uint32 MidwarePerf::cpu_rate_app() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.cpu_rate_app)
  return cpu_rate_app_;
}
inline void MidwarePerf::set_cpu_rate_app(::google::protobuf::uint32 value) {
  set_has_cpu_rate_app();
  cpu_rate_app_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwarePerf.cpu_rate_app)
}

// optional uint32 mem_use_app = 5;
inline bool MidwarePerf::has_mem_use_app() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MidwarePerf::set_has_mem_use_app() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MidwarePerf::clear_has_mem_use_app() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MidwarePerf::clear_mem_use_app() {
  mem_use_app_ = 0u;
  clear_has_mem_use_app();
}
inline ::google::protobuf::uint32 MidwarePerf::mem_use_app() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.mem_use_app)
  return mem_use_app_;
}
inline void MidwarePerf::set_mem_use_app(::google::protobuf::uint32 value) {
  set_has_mem_use_app();
  mem_use_app_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwarePerf.mem_use_app)
}

// repeated .mpfmessage.PerfParameter paralist = 6;
inline int MidwarePerf::paralist_size() const {
  return paralist_.size();
}
inline void MidwarePerf::clear_paralist() {
  paralist_.Clear();
}
inline const ::mpfmessage::PerfParameter& MidwarePerf::paralist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwarePerf.paralist)
  return paralist_.Get(index);
}
inline ::mpfmessage::PerfParameter* MidwarePerf::mutable_paralist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MidwarePerf.paralist)
  return paralist_.Mutable(index);
}
inline ::mpfmessage::PerfParameter* MidwarePerf::add_paralist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MidwarePerf.paralist)
  return paralist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >*
MidwarePerf::mutable_paralist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MidwarePerf.paralist)
  return &paralist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >&
MidwarePerf::paralist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MidwarePerf.paralist)
  return paralist_;
}

// -------------------------------------------------------------------

// DatabasePerf

// optional uint32 resid = 1;
inline bool DatabasePerf::has_resid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DatabasePerf::set_has_resid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DatabasePerf::clear_has_resid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DatabasePerf::clear_resid() {
  resid_ = 0u;
  clear_has_resid();
}
inline ::google::protobuf::uint32 DatabasePerf::resid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.resid)
  return resid_;
}
inline void DatabasePerf::set_resid(::google::protobuf::uint32 value) {
  set_has_resid();
  resid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DatabasePerf.resid)
}

// optional string name = 2;
inline bool DatabasePerf::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DatabasePerf::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DatabasePerf::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DatabasePerf::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DatabasePerf::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.name)
  return name_.GetNoArena();
}
inline void DatabasePerf::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DatabasePerf.name)
}
#if LANG_CXX11
inline void DatabasePerf::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DatabasePerf.name)
}
#endif
inline void DatabasePerf::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DatabasePerf.name)
}
inline void DatabasePerf::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DatabasePerf.name)
}
inline ::std::string* DatabasePerf::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DatabasePerf.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DatabasePerf::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.DatabasePerf.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DatabasePerf::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DatabasePerf.name)
}

// optional uint32 available = 3;
inline bool DatabasePerf::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DatabasePerf::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DatabasePerf::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DatabasePerf::clear_available() {
  available_ = 0u;
  clear_has_available();
}
inline ::google::protobuf::uint32 DatabasePerf::available() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.available)
  return available_;
}
inline void DatabasePerf::set_available(::google::protobuf::uint32 value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DatabasePerf.available)
}

// optional uint32 cpu_rate_app = 4;
inline bool DatabasePerf::has_cpu_rate_app() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DatabasePerf::set_has_cpu_rate_app() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DatabasePerf::clear_has_cpu_rate_app() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DatabasePerf::clear_cpu_rate_app() {
  cpu_rate_app_ = 0u;
  clear_has_cpu_rate_app();
}
inline ::google::protobuf::uint32 DatabasePerf::cpu_rate_app() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.cpu_rate_app)
  return cpu_rate_app_;
}
inline void DatabasePerf::set_cpu_rate_app(::google::protobuf::uint32 value) {
  set_has_cpu_rate_app();
  cpu_rate_app_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DatabasePerf.cpu_rate_app)
}

// optional uint32 mem_use_app = 5;
inline bool DatabasePerf::has_mem_use_app() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DatabasePerf::set_has_mem_use_app() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DatabasePerf::clear_has_mem_use_app() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DatabasePerf::clear_mem_use_app() {
  mem_use_app_ = 0u;
  clear_has_mem_use_app();
}
inline ::google::protobuf::uint32 DatabasePerf::mem_use_app() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.mem_use_app)
  return mem_use_app_;
}
inline void DatabasePerf::set_mem_use_app(::google::protobuf::uint32 value) {
  set_has_mem_use_app();
  mem_use_app_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DatabasePerf.mem_use_app)
}

// repeated .mpfmessage.PerfParameter paralist = 6;
inline int DatabasePerf::paralist_size() const {
  return paralist_.size();
}
inline void DatabasePerf::clear_paralist() {
  paralist_.Clear();
}
inline const ::mpfmessage::PerfParameter& DatabasePerf::paralist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.DatabasePerf.paralist)
  return paralist_.Get(index);
}
inline ::mpfmessage::PerfParameter* DatabasePerf::mutable_paralist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.DatabasePerf.paralist)
  return paralist_.Mutable(index);
}
inline ::mpfmessage::PerfParameter* DatabasePerf::add_paralist() {
  // @@protoc_insertion_point(field_add:mpfmessage.DatabasePerf.paralist)
  return paralist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >*
DatabasePerf::mutable_paralist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.DatabasePerf.paralist)
  return &paralist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PerfParameter >&
DatabasePerf::paralist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.DatabasePerf.paralist)
  return paralist_;
}

// -------------------------------------------------------------------

// IfPerf

// optional uint32 index = 1;
inline bool IfPerf::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IfPerf::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IfPerf::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IfPerf::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 IfPerf::index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.index)
  return index_;
}
inline void IfPerf::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.index)
}

// optional string desc = 2;
inline bool IfPerf::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IfPerf::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IfPerf::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IfPerf::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& IfPerf::desc() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.desc)
  return desc_.GetNoArena();
}
inline void IfPerf::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.desc)
}
#if LANG_CXX11
inline void IfPerf::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IfPerf.desc)
}
#endif
inline void IfPerf::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IfPerf.desc)
}
inline void IfPerf::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IfPerf.desc)
}
inline ::std::string* IfPerf::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IfPerf.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IfPerf::release_desc() {
  // @@protoc_insertion_point(field_release:mpfmessage.IfPerf.desc)
  clear_has_desc();
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IfPerf::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IfPerf.desc)
}

// optional .mpfmessage.Status oper_status = 3;
inline bool IfPerf::has_oper_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IfPerf::set_has_oper_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IfPerf::clear_has_oper_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IfPerf::clear_oper_status() {
  oper_status_ = 1;
  clear_has_oper_status();
}
inline ::mpfmessage::Status IfPerf::oper_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.oper_status)
  return static_cast< ::mpfmessage::Status >(oper_status_);
}
inline void IfPerf::set_oper_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_oper_status();
  oper_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.oper_status)
}

// optional .mpfmessage.Status admin_status = 4;
inline bool IfPerf::has_admin_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IfPerf::set_has_admin_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IfPerf::clear_has_admin_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IfPerf::clear_admin_status() {
  admin_status_ = 1;
  clear_has_admin_status();
}
inline ::mpfmessage::Status IfPerf::admin_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.admin_status)
  return static_cast< ::mpfmessage::Status >(admin_status_);
}
inline void IfPerf::set_admin_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_admin_status();
  admin_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.admin_status)
}

// optional uint32 rate = 5;
inline bool IfPerf::has_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IfPerf::set_has_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IfPerf::clear_has_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IfPerf::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 IfPerf::rate() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.rate)
  return rate_;
}
inline void IfPerf::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.rate)
}

// optional uint32 byte_in = 6;
inline bool IfPerf::has_byte_in() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IfPerf::set_has_byte_in() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IfPerf::clear_has_byte_in() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IfPerf::clear_byte_in() {
  byte_in_ = 0u;
  clear_has_byte_in();
}
inline ::google::protobuf::uint32 IfPerf::byte_in() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.byte_in)
  return byte_in_;
}
inline void IfPerf::set_byte_in(::google::protobuf::uint32 value) {
  set_has_byte_in();
  byte_in_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.byte_in)
}

// optional uint32 byte_out = 7;
inline bool IfPerf::has_byte_out() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IfPerf::set_has_byte_out() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IfPerf::clear_has_byte_out() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IfPerf::clear_byte_out() {
  byte_out_ = 0u;
  clear_has_byte_out();
}
inline ::google::protobuf::uint32 IfPerf::byte_out() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.byte_out)
  return byte_out_;
}
inline void IfPerf::set_byte_out(::google::protobuf::uint32 value) {
  set_has_byte_out();
  byte_out_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.byte_out)
}

// optional uint32 error_in = 8;
inline bool IfPerf::has_error_in() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IfPerf::set_has_error_in() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IfPerf::clear_has_error_in() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IfPerf::clear_error_in() {
  error_in_ = 0u;
  clear_has_error_in();
}
inline ::google::protobuf::uint32 IfPerf::error_in() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.error_in)
  return error_in_;
}
inline void IfPerf::set_error_in(::google::protobuf::uint32 value) {
  set_has_error_in();
  error_in_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.error_in)
}

// optional uint32 error_out = 9;
inline bool IfPerf::has_error_out() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IfPerf::set_has_error_out() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IfPerf::clear_has_error_out() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IfPerf::clear_error_out() {
  error_out_ = 0u;
  clear_has_error_out();
}
inline ::google::protobuf::uint32 IfPerf::error_out() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.error_out)
  return error_out_;
}
inline void IfPerf::set_error_out(::google::protobuf::uint32 value) {
  set_has_error_out();
  error_out_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.error_out)
}

// optional uint32 discard_in = 10;
inline bool IfPerf::has_discard_in() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IfPerf::set_has_discard_in() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IfPerf::clear_has_discard_in() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IfPerf::clear_discard_in() {
  discard_in_ = 0u;
  clear_has_discard_in();
}
inline ::google::protobuf::uint32 IfPerf::discard_in() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.discard_in)
  return discard_in_;
}
inline void IfPerf::set_discard_in(::google::protobuf::uint32 value) {
  set_has_discard_in();
  discard_in_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.discard_in)
}

// optional uint32 discard_out = 11;
inline bool IfPerf::has_discard_out() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IfPerf::set_has_discard_out() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IfPerf::clear_has_discard_out() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IfPerf::clear_discard_out() {
  discard_out_ = 0u;
  clear_has_discard_out();
}
inline ::google::protobuf::uint32 IfPerf::discard_out() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IfPerf.discard_out)
  return discard_out_;
}
inline void IfPerf::set_discard_out(::google::protobuf::uint32 value) {
  set_has_discard_out();
  discard_out_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.IfPerf.discard_out)
}

// -------------------------------------------------------------------

// MsgTopoDiscoveryResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgTopoDiscoveryResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgTopoDiscoveryResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgTopoDiscoveryResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgTopoDiscoveryResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoDiscoveryResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgTopoDiscoveryResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgTopoDiscoveryResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgTopoDiscoveryResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoDiscoveryResp.result)
  return result_;
}
inline void MsgTopoDiscoveryResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgTopoDiscoveryResp.result)
}

// -------------------------------------------------------------------

// DiscoveredDev

// optional string ip = 1;
inline bool DiscoveredDev::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscoveredDev::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscoveredDev::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscoveredDev::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& DiscoveredDev::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.ip)
  return ip_.GetNoArena();
}
inline void DiscoveredDev::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DiscoveredDev.ip)
}
#if LANG_CXX11
inline void DiscoveredDev::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DiscoveredDev.ip)
}
#endif
inline void DiscoveredDev::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DiscoveredDev.ip)
}
inline void DiscoveredDev::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DiscoveredDev.ip)
}
inline ::std::string* DiscoveredDev::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DiscoveredDev.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveredDev::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.DiscoveredDev.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveredDev::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DiscoveredDev.ip)
}

// optional uint32 resultcode = 2;
inline bool DiscoveredDev::has_resultcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscoveredDev::set_has_resultcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscoveredDev::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscoveredDev::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 DiscoveredDev::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.resultcode)
  return resultcode_;
}
inline void DiscoveredDev::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DiscoveredDev.resultcode)
}

// optional string detail = 3;
inline bool DiscoveredDev::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscoveredDev::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscoveredDev::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscoveredDev::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& DiscoveredDev::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.detail)
  return detail_.GetNoArena();
}
inline void DiscoveredDev::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DiscoveredDev.detail)
}
#if LANG_CXX11
inline void DiscoveredDev::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DiscoveredDev.detail)
}
#endif
inline void DiscoveredDev::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DiscoveredDev.detail)
}
inline void DiscoveredDev::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DiscoveredDev.detail)
}
inline ::std::string* DiscoveredDev::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DiscoveredDev.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DiscoveredDev::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.DiscoveredDev.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DiscoveredDev::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DiscoveredDev.detail)
}

// optional .mpfmessage.NetDevBaseInfo dev_base_info = 4;
inline bool DiscoveredDev::has_dev_base_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscoveredDev::set_has_dev_base_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscoveredDev::clear_has_dev_base_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscoveredDev::clear_dev_base_info() {
  if (dev_base_info_ != NULL) dev_base_info_->Clear();
  clear_has_dev_base_info();
}
inline const ::mpfmessage::NetDevBaseInfo& DiscoveredDev::dev_base_info() const {
  const ::mpfmessage::NetDevBaseInfo* p = dev_base_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.dev_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::NetDevBaseInfo*>(
      &::mpfmessage::_NetDevBaseInfo_default_instance_);
}
inline ::mpfmessage::NetDevBaseInfo* DiscoveredDev::release_dev_base_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.DiscoveredDev.dev_base_info)
  clear_has_dev_base_info();
  ::mpfmessage::NetDevBaseInfo* temp = dev_base_info_;
  dev_base_info_ = NULL;
  return temp;
}
inline ::mpfmessage::NetDevBaseInfo* DiscoveredDev::mutable_dev_base_info() {
  set_has_dev_base_info();
  if (dev_base_info_ == NULL) {
    dev_base_info_ = new ::mpfmessage::NetDevBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.DiscoveredDev.dev_base_info)
  return dev_base_info_;
}
inline void DiscoveredDev::set_allocated_dev_base_info(::mpfmessage::NetDevBaseInfo* dev_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dev_base_info_;
  }
  if (dev_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dev_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dev_base_info, submessage_arena);
    }
    set_has_dev_base_info();
  } else {
    clear_has_dev_base_info();
  }
  dev_base_info_ = dev_base_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DiscoveredDev.dev_base_info)
}

// optional .mpfmessage.HostBaseInfo host_base_info = 5;
inline bool DiscoveredDev::has_host_base_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscoveredDev::set_has_host_base_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscoveredDev::clear_has_host_base_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscoveredDev::clear_host_base_info() {
  if (host_base_info_ != NULL) host_base_info_->Clear();
  clear_has_host_base_info();
}
inline const ::mpfmessage::HostBaseInfo& DiscoveredDev::host_base_info() const {
  const ::mpfmessage::HostBaseInfo* p = host_base_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.host_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::HostBaseInfo*>(
      &::mpfmessage::_HostBaseInfo_default_instance_);
}
inline ::mpfmessage::HostBaseInfo* DiscoveredDev::release_host_base_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.DiscoveredDev.host_base_info)
  clear_has_host_base_info();
  ::mpfmessage::HostBaseInfo* temp = host_base_info_;
  host_base_info_ = NULL;
  return temp;
}
inline ::mpfmessage::HostBaseInfo* DiscoveredDev::mutable_host_base_info() {
  set_has_host_base_info();
  if (host_base_info_ == NULL) {
    host_base_info_ = new ::mpfmessage::HostBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.DiscoveredDev.host_base_info)
  return host_base_info_;
}
inline void DiscoveredDev::set_allocated_host_base_info(::mpfmessage::HostBaseInfo* host_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_base_info_;
  }
  if (host_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_base_info, submessage_arena);
    }
    set_has_host_base_info();
  } else {
    clear_has_host_base_info();
  }
  host_base_info_ = host_base_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DiscoveredDev.host_base_info)
}

// repeated .mpfmessage.IfBaseInfo if_base_info = 6;
inline int DiscoveredDev::if_base_info_size() const {
  return if_base_info_.size();
}
inline void DiscoveredDev::clear_if_base_info() {
  if_base_info_.Clear();
}
inline const ::mpfmessage::IfBaseInfo& DiscoveredDev::if_base_info(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.DiscoveredDev.if_base_info)
  return if_base_info_.Get(index);
}
inline ::mpfmessage::IfBaseInfo* DiscoveredDev::mutable_if_base_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.DiscoveredDev.if_base_info)
  return if_base_info_.Mutable(index);
}
inline ::mpfmessage::IfBaseInfo* DiscoveredDev::add_if_base_info() {
  // @@protoc_insertion_point(field_add:mpfmessage.DiscoveredDev.if_base_info)
  return if_base_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >*
DiscoveredDev::mutable_if_base_info() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.DiscoveredDev.if_base_info)
  return &if_base_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >&
DiscoveredDev::if_base_info() const {
  // @@protoc_insertion_point(field_list:mpfmessage.DiscoveredDev.if_base_info)
  return if_base_info_;
}

// -------------------------------------------------------------------

// MsgTopoDiscoveryNotify

// repeated .mpfmessage.TopoNodeInfo topo_node_info = 1;
inline int MsgTopoDiscoveryNotify::topo_node_info_size() const {
  return topo_node_info_.size();
}
inline void MsgTopoDiscoveryNotify::clear_topo_node_info() {
  topo_node_info_.Clear();
}
inline const ::mpfmessage::TopoNodeInfo& MsgTopoDiscoveryNotify::topo_node_info(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoDiscoveryNotify.topo_node_info)
  return topo_node_info_.Get(index);
}
inline ::mpfmessage::TopoNodeInfo* MsgTopoDiscoveryNotify::mutable_topo_node_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoDiscoveryNotify.topo_node_info)
  return topo_node_info_.Mutable(index);
}
inline ::mpfmessage::TopoNodeInfo* MsgTopoDiscoveryNotify::add_topo_node_info() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgTopoDiscoveryNotify.topo_node_info)
  return topo_node_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoNodeInfo >*
MsgTopoDiscoveryNotify::mutable_topo_node_info() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgTopoDiscoveryNotify.topo_node_info)
  return &topo_node_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoNodeInfo >&
MsgTopoDiscoveryNotify::topo_node_info() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgTopoDiscoveryNotify.topo_node_info)
  return topo_node_info_;
}

// repeated .mpfmessage.TopoLinkInfo topo_link_info = 2;
inline int MsgTopoDiscoveryNotify::topo_link_info_size() const {
  return topo_link_info_.size();
}
inline void MsgTopoDiscoveryNotify::clear_topo_link_info() {
  topo_link_info_.Clear();
}
inline const ::mpfmessage::TopoLinkInfo& MsgTopoDiscoveryNotify::topo_link_info(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoDiscoveryNotify.topo_link_info)
  return topo_link_info_.Get(index);
}
inline ::mpfmessage::TopoLinkInfo* MsgTopoDiscoveryNotify::mutable_topo_link_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoDiscoveryNotify.topo_link_info)
  return topo_link_info_.Mutable(index);
}
inline ::mpfmessage::TopoLinkInfo* MsgTopoDiscoveryNotify::add_topo_link_info() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgTopoDiscoveryNotify.topo_link_info)
  return topo_link_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoLinkInfo >*
MsgTopoDiscoveryNotify::mutable_topo_link_info() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgTopoDiscoveryNotify.topo_link_info)
  return &topo_link_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::TopoLinkInfo >&
MsgTopoDiscoveryNotify::topo_link_info() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgTopoDiscoveryNotify.topo_link_info)
  return topo_link_info_;
}

// -------------------------------------------------------------------

// ResSynInfo

// optional uint32 res_id = 1;
inline bool ResSynInfo::has_res_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResSynInfo::set_has_res_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResSynInfo::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResSynInfo::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 ResSynInfo::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.res_id)
  return res_id_;
}
inline void ResSynInfo::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynInfo.res_id)
}

// optional .mpfmessage.ResType res_type = 2;
inline bool ResSynInfo::has_res_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResSynInfo::set_has_res_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResSynInfo::clear_has_res_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResSynInfo::clear_res_type() {
  res_type_ = 1;
  clear_has_res_type();
}
inline ::mpfmessage::ResType ResSynInfo::res_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.res_type)
  return static_cast< ::mpfmessage::ResType >(res_type_);
}
inline void ResSynInfo::set_res_type(::mpfmessage::ResType value) {
  assert(::mpfmessage::ResType_IsValid(value));
  set_has_res_type();
  res_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynInfo.res_type)
}

// optional .mpfmessage.SnmpInfo snmp_info = 3;
inline bool ResSynInfo::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResSynInfo::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResSynInfo::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResSynInfo::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& ResSynInfo::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* ResSynInfo::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynInfo.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* ResSynInfo::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynInfo.snmp_info)
  return snmp_info_;
}
inline void ResSynInfo::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynInfo.snmp_info)
}

// optional .mpfmessage.TelnetPara telentPara = 4;
inline bool ResSynInfo::has_telentpara() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResSynInfo::set_has_telentpara() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResSynInfo::clear_has_telentpara() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResSynInfo::clear_telentpara() {
  if (telentpara_ != NULL) telentpara_->Clear();
  clear_has_telentpara();
}
inline const ::mpfmessage::TelnetPara& ResSynInfo::telentpara() const {
  const ::mpfmessage::TelnetPara* p = telentpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.telentPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::TelnetPara*>(
      &::mpfmessage::_TelnetPara_default_instance_);
}
inline ::mpfmessage::TelnetPara* ResSynInfo::release_telentpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynInfo.telentPara)
  clear_has_telentpara();
  ::mpfmessage::TelnetPara* temp = telentpara_;
  telentpara_ = NULL;
  return temp;
}
inline ::mpfmessage::TelnetPara* ResSynInfo::mutable_telentpara() {
  set_has_telentpara();
  if (telentpara_ == NULL) {
    telentpara_ = new ::mpfmessage::TelnetPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynInfo.telentPara)
  return telentpara_;
}
inline void ResSynInfo::set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete telentpara_;
  }
  if (telentpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      telentpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, telentpara, submessage_arena);
    }
    set_has_telentpara();
  } else {
    clear_has_telentpara();
  }
  telentpara_ = telentpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynInfo.telentPara)
}

// optional .mpfmessage.SshPara sshPara = 5;
inline bool ResSynInfo::has_sshpara() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResSynInfo::set_has_sshpara() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResSynInfo::clear_has_sshpara() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResSynInfo::clear_sshpara() {
  if (sshpara_ != NULL) sshpara_->Clear();
  clear_has_sshpara();
}
inline const ::mpfmessage::SshPara& ResSynInfo::sshpara() const {
  const ::mpfmessage::SshPara* p = sshpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.sshPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SshPara*>(
      &::mpfmessage::_SshPara_default_instance_);
}
inline ::mpfmessage::SshPara* ResSynInfo::release_sshpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynInfo.sshPara)
  clear_has_sshpara();
  ::mpfmessage::SshPara* temp = sshpara_;
  sshpara_ = NULL;
  return temp;
}
inline ::mpfmessage::SshPara* ResSynInfo::mutable_sshpara() {
  set_has_sshpara();
  if (sshpara_ == NULL) {
    sshpara_ = new ::mpfmessage::SshPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynInfo.sshPara)
  return sshpara_;
}
inline void ResSynInfo::set_allocated_sshpara(::mpfmessage::SshPara* sshpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sshpara_;
  }
  if (sshpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sshpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sshpara, submessage_arena);
    }
    set_has_sshpara();
  } else {
    clear_has_sshpara();
  }
  sshpara_ = sshpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynInfo.sshPara)
}

// repeated .mpfmessage.IfResInfo if_list = 6;
inline int ResSynInfo::if_list_size() const {
  return if_list_.size();
}
inline void ResSynInfo::clear_if_list() {
  if_list_.Clear();
}
inline const ::mpfmessage::IfResInfo& ResSynInfo::if_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynInfo.if_list)
  return if_list_.Get(index);
}
inline ::mpfmessage::IfResInfo* ResSynInfo::mutable_if_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynInfo.if_list)
  return if_list_.Mutable(index);
}
inline ::mpfmessage::IfResInfo* ResSynInfo::add_if_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.ResSynInfo.if_list)
  return if_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfResInfo >*
ResSynInfo::mutable_if_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.ResSynInfo.if_list)
  return &if_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfResInfo >&
ResSynInfo::if_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.ResSynInfo.if_list)
  return if_list_;
}

// -------------------------------------------------------------------

// RespAddr

// optional string addr = 1;
inline bool RespAddr::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RespAddr::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RespAddr::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RespAddr::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& RespAddr::addr() const {
  // @@protoc_insertion_point(field_get:mpfmessage.RespAddr.addr)
  return addr_.GetNoArena();
}
inline void RespAddr::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.RespAddr.addr)
}
#if LANG_CXX11
inline void RespAddr::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.RespAddr.addr)
}
#endif
inline void RespAddr::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.RespAddr.addr)
}
inline void RespAddr::set_addr(const char* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.RespAddr.addr)
}
inline ::std::string* RespAddr::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:mpfmessage.RespAddr.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RespAddr::release_addr() {
  // @@protoc_insertion_point(field_release:mpfmessage.RespAddr.addr)
  clear_has_addr();
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RespAddr::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.RespAddr.addr)
}

// optional uint32 port = 2;
inline bool RespAddr::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RespAddr::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RespAddr::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RespAddr::clear_port() {
  port_ = 0u;
  clear_has_port();
}
inline ::google::protobuf::uint32 RespAddr::port() const {
  // @@protoc_insertion_point(field_get:mpfmessage.RespAddr.port)
  return port_;
}
inline void RespAddr::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.RespAddr.port)
}

// -------------------------------------------------------------------

// MsgResSynReq

// repeated .mpfmessage.ResSynInfo res_list = 1;
inline int MsgResSynReq::res_list_size() const {
  return res_list_.size();
}
inline void MsgResSynReq::clear_res_list() {
  res_list_.Clear();
}
inline const ::mpfmessage::ResSynInfo& MsgResSynReq::res_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgResSynReq.res_list)
  return res_list_.Get(index);
}
inline ::mpfmessage::ResSynInfo* MsgResSynReq::mutable_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgResSynReq.res_list)
  return res_list_.Mutable(index);
}
inline ::mpfmessage::ResSynInfo* MsgResSynReq::add_res_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgResSynReq.res_list)
  return res_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >*
MsgResSynReq::mutable_res_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgResSynReq.res_list)
  return &res_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >&
MsgResSynReq::res_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgResSynReq.res_list)
  return res_list_;
}

// optional .mpfmessage.RespAddr resp_addr = 2;
inline bool MsgResSynReq::has_resp_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgResSynReq::set_has_resp_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgResSynReq::clear_has_resp_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgResSynReq::clear_resp_addr() {
  if (resp_addr_ != NULL) resp_addr_->Clear();
  clear_has_resp_addr();
}
inline const ::mpfmessage::RespAddr& MsgResSynReq::resp_addr() const {
  const ::mpfmessage::RespAddr* p = resp_addr_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgResSynReq.resp_addr)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::RespAddr*>(
      &::mpfmessage::_RespAddr_default_instance_);
}
inline ::mpfmessage::RespAddr* MsgResSynReq::release_resp_addr() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgResSynReq.resp_addr)
  clear_has_resp_addr();
  ::mpfmessage::RespAddr* temp = resp_addr_;
  resp_addr_ = NULL;
  return temp;
}
inline ::mpfmessage::RespAddr* MsgResSynReq::mutable_resp_addr() {
  set_has_resp_addr();
  if (resp_addr_ == NULL) {
    resp_addr_ = new ::mpfmessage::RespAddr;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgResSynReq.resp_addr)
  return resp_addr_;
}
inline void MsgResSynReq::set_allocated_resp_addr(::mpfmessage::RespAddr* resp_addr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete resp_addr_;
  }
  if (resp_addr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      resp_addr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resp_addr, submessage_arena);
    }
    set_has_resp_addr();
  } else {
    clear_has_resp_addr();
  }
  resp_addr_ = resp_addr;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgResSynReq.resp_addr)
}

// -------------------------------------------------------------------

// MsgResSynResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgResSynResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgResSynResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgResSynResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgResSynResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgResSynResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgResSynResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgResSynResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgResSynResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgResSynResp.result)
  return result_;
}
inline void MsgResSynResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgResSynResp.result)
}

// -------------------------------------------------------------------

// ResSynResult

// optional uint32 res_id = 1;
inline bool ResSynResult::has_res_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResSynResult::set_has_res_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResSynResult::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResSynResult::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 ResSynResult::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.res_id)
  return res_id_;
}
inline void ResSynResult::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynResult.res_id)
}

// optional .mpfmessage.ResType res_type = 2;
inline bool ResSynResult::has_res_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResSynResult::set_has_res_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResSynResult::clear_has_res_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResSynResult::clear_res_type() {
  res_type_ = 1;
  clear_has_res_type();
}
inline ::mpfmessage::ResType ResSynResult::res_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.res_type)
  return static_cast< ::mpfmessage::ResType >(res_type_);
}
inline void ResSynResult::set_res_type(::mpfmessage::ResType value) {
  assert(::mpfmessage::ResType_IsValid(value));
  set_has_res_type();
  res_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynResult.res_type)
}

// optional uint32 resultcode = 3;
inline bool ResSynResult::has_resultcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResSynResult::set_has_resultcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResSynResult::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResSynResult::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 ResSynResult::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.resultcode)
  return resultcode_;
}
inline void ResSynResult::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynResult.resultcode)
}

// optional string detail = 4;
inline bool ResSynResult::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResSynResult::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResSynResult::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResSynResult::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& ResSynResult::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.detail)
  return detail_.GetNoArena();
}
inline void ResSynResult::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ResSynResult.detail)
}
#if LANG_CXX11
inline void ResSynResult::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ResSynResult.detail)
}
#endif
inline void ResSynResult::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ResSynResult.detail)
}
inline void ResSynResult::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ResSynResult.detail)
}
inline ::std::string* ResSynResult::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynResult.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ResSynResult::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynResult.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ResSynResult::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynResult.detail)
}

// optional .mpfmessage.NetDevBaseInfo dev_base_info = 5;
inline bool ResSynResult::has_dev_base_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResSynResult::set_has_dev_base_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResSynResult::clear_has_dev_base_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResSynResult::clear_dev_base_info() {
  if (dev_base_info_ != NULL) dev_base_info_->Clear();
  clear_has_dev_base_info();
}
inline const ::mpfmessage::NetDevBaseInfo& ResSynResult::dev_base_info() const {
  const ::mpfmessage::NetDevBaseInfo* p = dev_base_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.dev_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::NetDevBaseInfo*>(
      &::mpfmessage::_NetDevBaseInfo_default_instance_);
}
inline ::mpfmessage::NetDevBaseInfo* ResSynResult::release_dev_base_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynResult.dev_base_info)
  clear_has_dev_base_info();
  ::mpfmessage::NetDevBaseInfo* temp = dev_base_info_;
  dev_base_info_ = NULL;
  return temp;
}
inline ::mpfmessage::NetDevBaseInfo* ResSynResult::mutable_dev_base_info() {
  set_has_dev_base_info();
  if (dev_base_info_ == NULL) {
    dev_base_info_ = new ::mpfmessage::NetDevBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynResult.dev_base_info)
  return dev_base_info_;
}
inline void ResSynResult::set_allocated_dev_base_info(::mpfmessage::NetDevBaseInfo* dev_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dev_base_info_;
  }
  if (dev_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dev_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dev_base_info, submessage_arena);
    }
    set_has_dev_base_info();
  } else {
    clear_has_dev_base_info();
  }
  dev_base_info_ = dev_base_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynResult.dev_base_info)
}

// optional .mpfmessage.HostBaseInfo host_base_info = 6;
inline bool ResSynResult::has_host_base_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResSynResult::set_has_host_base_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResSynResult::clear_has_host_base_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResSynResult::clear_host_base_info() {
  if (host_base_info_ != NULL) host_base_info_->Clear();
  clear_has_host_base_info();
}
inline const ::mpfmessage::HostBaseInfo& ResSynResult::host_base_info() const {
  const ::mpfmessage::HostBaseInfo* p = host_base_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.host_base_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::HostBaseInfo*>(
      &::mpfmessage::_HostBaseInfo_default_instance_);
}
inline ::mpfmessage::HostBaseInfo* ResSynResult::release_host_base_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.ResSynResult.host_base_info)
  clear_has_host_base_info();
  ::mpfmessage::HostBaseInfo* temp = host_base_info_;
  host_base_info_ = NULL;
  return temp;
}
inline ::mpfmessage::HostBaseInfo* ResSynResult::mutable_host_base_info() {
  set_has_host_base_info();
  if (host_base_info_ == NULL) {
    host_base_info_ = new ::mpfmessage::HostBaseInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynResult.host_base_info)
  return host_base_info_;
}
inline void ResSynResult::set_allocated_host_base_info(::mpfmessage::HostBaseInfo* host_base_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete host_base_info_;
  }
  if (host_base_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      host_base_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_base_info, submessage_arena);
    }
    set_has_host_base_info();
  } else {
    clear_has_host_base_info();
  }
  host_base_info_ = host_base_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ResSynResult.host_base_info)
}

// repeated .mpfmessage.IfBaseInfo if_base_info = 7;
inline int ResSynResult::if_base_info_size() const {
  return if_base_info_.size();
}
inline void ResSynResult::clear_if_base_info() {
  if_base_info_.Clear();
}
inline const ::mpfmessage::IfBaseInfo& ResSynResult::if_base_info(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.ResSynResult.if_base_info)
  return if_base_info_.Get(index);
}
inline ::mpfmessage::IfBaseInfo* ResSynResult::mutable_if_base_info(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.ResSynResult.if_base_info)
  return if_base_info_.Mutable(index);
}
inline ::mpfmessage::IfBaseInfo* ResSynResult::add_if_base_info() {
  // @@protoc_insertion_point(field_add:mpfmessage.ResSynResult.if_base_info)
  return if_base_info_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >*
ResSynResult::mutable_if_base_info() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.ResSynResult.if_base_info)
  return &if_base_info_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IfBaseInfo >&
ResSynResult::if_base_info() const {
  // @@protoc_insertion_point(field_list:mpfmessage.ResSynResult.if_base_info)
  return if_base_info_;
}

// -------------------------------------------------------------------

// MsgResSynNotify

// repeated .mpfmessage.ResSynResult res_syn_data = 1;
inline int MsgResSynNotify::res_syn_data_size() const {
  return res_syn_data_.size();
}
inline void MsgResSynNotify::clear_res_syn_data() {
  res_syn_data_.Clear();
}
inline const ::mpfmessage::ResSynResult& MsgResSynNotify::res_syn_data(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgResSynNotify.res_syn_data)
  return res_syn_data_.Get(index);
}
inline ::mpfmessage::ResSynResult* MsgResSynNotify::mutable_res_syn_data(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgResSynNotify.res_syn_data)
  return res_syn_data_.Mutable(index);
}
inline ::mpfmessage::ResSynResult* MsgResSynNotify::add_res_syn_data() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgResSynNotify.res_syn_data)
  return res_syn_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynResult >*
MsgResSynNotify::mutable_res_syn_data() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgResSynNotify.res_syn_data)
  return &res_syn_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynResult >&
MsgResSynNotify::res_syn_data() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgResSynNotify.res_syn_data)
  return res_syn_data_;
}

// -------------------------------------------------------------------

// MsgDevPerfCollectReq

// repeated .mpfmessage.ResSynInfo res_list = 1;
inline int MsgDevPerfCollectReq::res_list_size() const {
  return res_list_.size();
}
inline void MsgDevPerfCollectReq::clear_res_list() {
  res_list_.Clear();
}
inline const ::mpfmessage::ResSynInfo& MsgDevPerfCollectReq::res_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevPerfCollectReq.res_list)
  return res_list_.Get(index);
}
inline ::mpfmessage::ResSynInfo* MsgDevPerfCollectReq::mutable_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevPerfCollectReq.res_list)
  return res_list_.Mutable(index);
}
inline ::mpfmessage::ResSynInfo* MsgDevPerfCollectReq::add_res_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgDevPerfCollectReq.res_list)
  return res_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >*
MsgDevPerfCollectReq::mutable_res_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgDevPerfCollectReq.res_list)
  return &res_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ResSynInfo >&
MsgDevPerfCollectReq::res_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgDevPerfCollectReq.res_list)
  return res_list_;
}

// optional uint32 collect_time = 2;
inline bool MsgDevPerfCollectReq::has_collect_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgDevPerfCollectReq::set_has_collect_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgDevPerfCollectReq::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgDevPerfCollectReq::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgDevPerfCollectReq::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevPerfCollectReq.collect_time)
  return collect_time_;
}
inline void MsgDevPerfCollectReq::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgDevPerfCollectReq.collect_time)
}

// -------------------------------------------------------------------

// MsgDevPerfCollectResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgDevPerfCollectResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgDevPerfCollectResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgDevPerfCollectResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgDevPerfCollectResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevPerfCollectResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgDevPerfCollectResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevPerfCollectResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgDevPerfCollectResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevPerfCollectResp.result)
  return result_;
}
inline void MsgDevPerfCollectResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevPerfCollectResp.result)
}

// -------------------------------------------------------------------

// MsgGetHostProcListReq

// optional uint32 host_res_id = 1;
inline bool MsgGetHostProcListReq::has_host_res_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgGetHostProcListReq::set_has_host_res_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgGetHostProcListReq::clear_has_host_res_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgGetHostProcListReq::clear_host_res_id() {
  host_res_id_ = 0u;
  clear_has_host_res_id();
}
inline ::google::protobuf::uint32 MsgGetHostProcListReq::host_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListReq.host_res_id)
  return host_res_id_;
}
inline void MsgGetHostProcListReq::set_host_res_id(::google::protobuf::uint32 value) {
  set_has_host_res_id();
  host_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostProcListReq.host_res_id)
}

// optional .mpfmessage.SnmpInfo snmp_info = 2;
inline bool MsgGetHostProcListReq::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetHostProcListReq::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetHostProcListReq::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGetHostProcListReq::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& MsgGetHostProcListReq::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListReq.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* MsgGetHostProcListReq::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostProcListReq.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* MsgGetHostProcListReq::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListReq.snmp_info)
  return snmp_info_;
}
inline void MsgGetHostProcListReq::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostProcListReq.snmp_info)
}

// optional .mpfmessage.TelnetPara telentPara = 3;
inline bool MsgGetHostProcListReq::has_telentpara() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgGetHostProcListReq::set_has_telentpara() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgGetHostProcListReq::clear_has_telentpara() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgGetHostProcListReq::clear_telentpara() {
  if (telentpara_ != NULL) telentpara_->Clear();
  clear_has_telentpara();
}
inline const ::mpfmessage::TelnetPara& MsgGetHostProcListReq::telentpara() const {
  const ::mpfmessage::TelnetPara* p = telentpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListReq.telentPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::TelnetPara*>(
      &::mpfmessage::_TelnetPara_default_instance_);
}
inline ::mpfmessage::TelnetPara* MsgGetHostProcListReq::release_telentpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostProcListReq.telentPara)
  clear_has_telentpara();
  ::mpfmessage::TelnetPara* temp = telentpara_;
  telentpara_ = NULL;
  return temp;
}
inline ::mpfmessage::TelnetPara* MsgGetHostProcListReq::mutable_telentpara() {
  set_has_telentpara();
  if (telentpara_ == NULL) {
    telentpara_ = new ::mpfmessage::TelnetPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListReq.telentPara)
  return telentpara_;
}
inline void MsgGetHostProcListReq::set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete telentpara_;
  }
  if (telentpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      telentpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, telentpara, submessage_arena);
    }
    set_has_telentpara();
  } else {
    clear_has_telentpara();
  }
  telentpara_ = telentpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostProcListReq.telentPara)
}

// optional .mpfmessage.SshPara sshPara = 4;
inline bool MsgGetHostProcListReq::has_sshpara() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgGetHostProcListReq::set_has_sshpara() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgGetHostProcListReq::clear_has_sshpara() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgGetHostProcListReq::clear_sshpara() {
  if (sshpara_ != NULL) sshpara_->Clear();
  clear_has_sshpara();
}
inline const ::mpfmessage::SshPara& MsgGetHostProcListReq::sshpara() const {
  const ::mpfmessage::SshPara* p = sshpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListReq.sshPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SshPara*>(
      &::mpfmessage::_SshPara_default_instance_);
}
inline ::mpfmessage::SshPara* MsgGetHostProcListReq::release_sshpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostProcListReq.sshPara)
  clear_has_sshpara();
  ::mpfmessage::SshPara* temp = sshpara_;
  sshpara_ = NULL;
  return temp;
}
inline ::mpfmessage::SshPara* MsgGetHostProcListReq::mutable_sshpara() {
  set_has_sshpara();
  if (sshpara_ == NULL) {
    sshpara_ = new ::mpfmessage::SshPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListReq.sshPara)
  return sshpara_;
}
inline void MsgGetHostProcListReq::set_allocated_sshpara(::mpfmessage::SshPara* sshpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sshpara_;
  }
  if (sshpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sshpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sshpara, submessage_arena);
    }
    set_has_sshpara();
  } else {
    clear_has_sshpara();
  }
  sshpara_ = sshpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostProcListReq.sshPara)
}

// -------------------------------------------------------------------

// MsgGetHostProcListResp

// optional uint32 host_res_id = 1;
inline bool MsgGetHostProcListResp::has_host_res_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgGetHostProcListResp::set_has_host_res_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgGetHostProcListResp::clear_has_host_res_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgGetHostProcListResp::clear_host_res_id() {
  host_res_id_ = 0u;
  clear_has_host_res_id();
}
inline ::google::protobuf::uint32 MsgGetHostProcListResp::host_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.host_res_id)
  return host_res_id_;
}
inline void MsgGetHostProcListResp::set_host_res_id(::google::protobuf::uint32 value) {
  set_has_host_res_id();
  host_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostProcListResp.host_res_id)
}

// optional uint32 resultcode = 2;
inline bool MsgGetHostProcListResp::has_resultcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgGetHostProcListResp::set_has_resultcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgGetHostProcListResp::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgGetHostProcListResp::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 MsgGetHostProcListResp::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.resultcode)
  return resultcode_;
}
inline void MsgGetHostProcListResp::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostProcListResp.resultcode)
}

// optional string detail = 3;
inline bool MsgGetHostProcListResp::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetHostProcListResp::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetHostProcListResp::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGetHostProcListResp::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& MsgGetHostProcListResp::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.detail)
  return detail_.GetNoArena();
}
inline void MsgGetHostProcListResp::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostProcListResp.detail)
}
#if LANG_CXX11
inline void MsgGetHostProcListResp::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.MsgGetHostProcListResp.detail)
}
#endif
inline void MsgGetHostProcListResp::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.MsgGetHostProcListResp.detail)
}
inline void MsgGetHostProcListResp::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.MsgGetHostProcListResp.detail)
}
inline ::std::string* MsgGetHostProcListResp::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListResp.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgGetHostProcListResp::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostProcListResp.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgGetHostProcListResp::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostProcListResp.detail)
}

// repeated .mpfmessage.SoftwareInfo softwarelist = 4;
inline int MsgGetHostProcListResp::softwarelist_size() const {
  return softwarelist_.size();
}
inline void MsgGetHostProcListResp::clear_softwarelist() {
  softwarelist_.Clear();
}
inline const ::mpfmessage::SoftwareInfo& MsgGetHostProcListResp::softwarelist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.softwarelist)
  return softwarelist_.Get(index);
}
inline ::mpfmessage::SoftwareInfo* MsgGetHostProcListResp::mutable_softwarelist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListResp.softwarelist)
  return softwarelist_.Mutable(index);
}
inline ::mpfmessage::SoftwareInfo* MsgGetHostProcListResp::add_softwarelist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgGetHostProcListResp.softwarelist)
  return softwarelist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::SoftwareInfo >*
MsgGetHostProcListResp::mutable_softwarelist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgGetHostProcListResp.softwarelist)
  return &softwarelist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SoftwareInfo >&
MsgGetHostProcListResp::softwarelist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgGetHostProcListResp.softwarelist)
  return softwarelist_;
}

// repeated .mpfmessage.ProcessInfo proclist = 5;
inline int MsgGetHostProcListResp::proclist_size() const {
  return proclist_.size();
}
inline void MsgGetHostProcListResp::clear_proclist() {
  proclist_.Clear();
}
inline const ::mpfmessage::ProcessInfo& MsgGetHostProcListResp::proclist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.proclist)
  return proclist_.Get(index);
}
inline ::mpfmessage::ProcessInfo* MsgGetHostProcListResp::mutable_proclist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostProcListResp.proclist)
  return proclist_.Mutable(index);
}
inline ::mpfmessage::ProcessInfo* MsgGetHostProcListResp::add_proclist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgGetHostProcListResp.proclist)
  return proclist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessInfo >*
MsgGetHostProcListResp::mutable_proclist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgGetHostProcListResp.proclist)
  return &proclist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ProcessInfo >&
MsgGetHostProcListResp::proclist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgGetHostProcListResp.proclist)
  return proclist_;
}

// optional uint32 collect_time = 6;
inline bool MsgGetHostProcListResp::has_collect_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgGetHostProcListResp::set_has_collect_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgGetHostProcListResp::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgGetHostProcListResp::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgGetHostProcListResp::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostProcListResp.collect_time)
  return collect_time_;
}
inline void MsgGetHostProcListResp::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostProcListResp.collect_time)
}

// -------------------------------------------------------------------

// MsgGetHostFileSystemListReq

// optional uint32 host_res_id = 1;
inline bool MsgGetHostFileSystemListReq::has_host_res_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgGetHostFileSystemListReq::set_has_host_res_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgGetHostFileSystemListReq::clear_has_host_res_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgGetHostFileSystemListReq::clear_host_res_id() {
  host_res_id_ = 0u;
  clear_has_host_res_id();
}
inline ::google::protobuf::uint32 MsgGetHostFileSystemListReq::host_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListReq.host_res_id)
  return host_res_id_;
}
inline void MsgGetHostFileSystemListReq::set_host_res_id(::google::protobuf::uint32 value) {
  set_has_host_res_id();
  host_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostFileSystemListReq.host_res_id)
}

// optional .mpfmessage.SnmpInfo snmp_info = 2;
inline bool MsgGetHostFileSystemListReq::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetHostFileSystemListReq::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetHostFileSystemListReq::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGetHostFileSystemListReq::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& MsgGetHostFileSystemListReq::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListReq.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* MsgGetHostFileSystemListReq::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostFileSystemListReq.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* MsgGetHostFileSystemListReq::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostFileSystemListReq.snmp_info)
  return snmp_info_;
}
inline void MsgGetHostFileSystemListReq::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostFileSystemListReq.snmp_info)
}

// optional .mpfmessage.TelnetPara telentPara = 3;
inline bool MsgGetHostFileSystemListReq::has_telentpara() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgGetHostFileSystemListReq::set_has_telentpara() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgGetHostFileSystemListReq::clear_has_telentpara() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgGetHostFileSystemListReq::clear_telentpara() {
  if (telentpara_ != NULL) telentpara_->Clear();
  clear_has_telentpara();
}
inline const ::mpfmessage::TelnetPara& MsgGetHostFileSystemListReq::telentpara() const {
  const ::mpfmessage::TelnetPara* p = telentpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListReq.telentPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::TelnetPara*>(
      &::mpfmessage::_TelnetPara_default_instance_);
}
inline ::mpfmessage::TelnetPara* MsgGetHostFileSystemListReq::release_telentpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostFileSystemListReq.telentPara)
  clear_has_telentpara();
  ::mpfmessage::TelnetPara* temp = telentpara_;
  telentpara_ = NULL;
  return temp;
}
inline ::mpfmessage::TelnetPara* MsgGetHostFileSystemListReq::mutable_telentpara() {
  set_has_telentpara();
  if (telentpara_ == NULL) {
    telentpara_ = new ::mpfmessage::TelnetPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostFileSystemListReq.telentPara)
  return telentpara_;
}
inline void MsgGetHostFileSystemListReq::set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete telentpara_;
  }
  if (telentpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      telentpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, telentpara, submessage_arena);
    }
    set_has_telentpara();
  } else {
    clear_has_telentpara();
  }
  telentpara_ = telentpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostFileSystemListReq.telentPara)
}

// optional .mpfmessage.SshPara sshPara = 4;
inline bool MsgGetHostFileSystemListReq::has_sshpara() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgGetHostFileSystemListReq::set_has_sshpara() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgGetHostFileSystemListReq::clear_has_sshpara() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgGetHostFileSystemListReq::clear_sshpara() {
  if (sshpara_ != NULL) sshpara_->Clear();
  clear_has_sshpara();
}
inline const ::mpfmessage::SshPara& MsgGetHostFileSystemListReq::sshpara() const {
  const ::mpfmessage::SshPara* p = sshpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListReq.sshPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SshPara*>(
      &::mpfmessage::_SshPara_default_instance_);
}
inline ::mpfmessage::SshPara* MsgGetHostFileSystemListReq::release_sshpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostFileSystemListReq.sshPara)
  clear_has_sshpara();
  ::mpfmessage::SshPara* temp = sshpara_;
  sshpara_ = NULL;
  return temp;
}
inline ::mpfmessage::SshPara* MsgGetHostFileSystemListReq::mutable_sshpara() {
  set_has_sshpara();
  if (sshpara_ == NULL) {
    sshpara_ = new ::mpfmessage::SshPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostFileSystemListReq.sshPara)
  return sshpara_;
}
inline void MsgGetHostFileSystemListReq::set_allocated_sshpara(::mpfmessage::SshPara* sshpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sshpara_;
  }
  if (sshpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sshpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sshpara, submessage_arena);
    }
    set_has_sshpara();
  } else {
    clear_has_sshpara();
  }
  sshpara_ = sshpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostFileSystemListReq.sshPara)
}

// -------------------------------------------------------------------

// MsgGetHostFileSystemListResp

// optional uint32 host_res_id = 1;
inline bool MsgGetHostFileSystemListResp::has_host_res_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgGetHostFileSystemListResp::set_has_host_res_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgGetHostFileSystemListResp::clear_has_host_res_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgGetHostFileSystemListResp::clear_host_res_id() {
  host_res_id_ = 0u;
  clear_has_host_res_id();
}
inline ::google::protobuf::uint32 MsgGetHostFileSystemListResp::host_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListResp.host_res_id)
  return host_res_id_;
}
inline void MsgGetHostFileSystemListResp::set_host_res_id(::google::protobuf::uint32 value) {
  set_has_host_res_id();
  host_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostFileSystemListResp.host_res_id)
}

// optional uint32 resultcode = 2;
inline bool MsgGetHostFileSystemListResp::has_resultcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgGetHostFileSystemListResp::set_has_resultcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgGetHostFileSystemListResp::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgGetHostFileSystemListResp::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 MsgGetHostFileSystemListResp::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListResp.resultcode)
  return resultcode_;
}
inline void MsgGetHostFileSystemListResp::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostFileSystemListResp.resultcode)
}

// optional string detail = 3;
inline bool MsgGetHostFileSystemListResp::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetHostFileSystemListResp::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetHostFileSystemListResp::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGetHostFileSystemListResp::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& MsgGetHostFileSystemListResp::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListResp.detail)
  return detail_.GetNoArena();
}
inline void MsgGetHostFileSystemListResp::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostFileSystemListResp.detail)
}
#if LANG_CXX11
inline void MsgGetHostFileSystemListResp::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.MsgGetHostFileSystemListResp.detail)
}
#endif
inline void MsgGetHostFileSystemListResp::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.MsgGetHostFileSystemListResp.detail)
}
inline void MsgGetHostFileSystemListResp::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.MsgGetHostFileSystemListResp.detail)
}
inline ::std::string* MsgGetHostFileSystemListResp::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostFileSystemListResp.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgGetHostFileSystemListResp::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetHostFileSystemListResp.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgGetHostFileSystemListResp::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetHostFileSystemListResp.detail)
}

// repeated .mpfmessage.PartitionInfo partiList = 4;
inline int MsgGetHostFileSystemListResp::partilist_size() const {
  return partilist_.size();
}
inline void MsgGetHostFileSystemListResp::clear_partilist() {
  partilist_.Clear();
}
inline const ::mpfmessage::PartitionInfo& MsgGetHostFileSystemListResp::partilist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListResp.partiList)
  return partilist_.Get(index);
}
inline ::mpfmessage::PartitionInfo* MsgGetHostFileSystemListResp::mutable_partilist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetHostFileSystemListResp.partiList)
  return partilist_.Mutable(index);
}
inline ::mpfmessage::PartitionInfo* MsgGetHostFileSystemListResp::add_partilist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgGetHostFileSystemListResp.partiList)
  return partilist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >*
MsgGetHostFileSystemListResp::mutable_partilist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgGetHostFileSystemListResp.partiList)
  return &partilist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::PartitionInfo >&
MsgGetHostFileSystemListResp::partilist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgGetHostFileSystemListResp.partiList)
  return partilist_;
}

// optional uint32 collect_time = 5;
inline bool MsgGetHostFileSystemListResp::has_collect_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgGetHostFileSystemListResp::set_has_collect_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgGetHostFileSystemListResp::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgGetHostFileSystemListResp::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgGetHostFileSystemListResp::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetHostFileSystemListResp.collect_time)
  return collect_time_;
}
inline void MsgGetHostFileSystemListResp::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetHostFileSystemListResp.collect_time)
}

// -------------------------------------------------------------------

// DBResInfo

// optional uint32 res_id = 1;
inline bool DBResInfo::has_res_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DBResInfo::set_has_res_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DBResInfo::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DBResInfo::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 DBResInfo::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DBResInfo.res_id)
  return res_id_;
}
inline void DBResInfo::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DBResInfo.res_id)
}

// optional .mpfmessage.SnmpInfo snmp_info = 2;
inline bool DBResInfo::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DBResInfo::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DBResInfo::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DBResInfo::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& DBResInfo::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.DBResInfo.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* DBResInfo::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.DBResInfo.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* DBResInfo::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.DBResInfo.snmp_info)
  return snmp_info_;
}
inline void DBResInfo::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DBResInfo.snmp_info)
}

// optional .mpfmessage.DbLoginPara db_conn_pare = 3;
inline bool DBResInfo::has_db_conn_pare() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DBResInfo::set_has_db_conn_pare() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DBResInfo::clear_has_db_conn_pare() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DBResInfo::clear_db_conn_pare() {
  if (db_conn_pare_ != NULL) db_conn_pare_->Clear();
  clear_has_db_conn_pare();
}
inline const ::mpfmessage::DbLoginPara& DBResInfo::db_conn_pare() const {
  const ::mpfmessage::DbLoginPara* p = db_conn_pare_;
  // @@protoc_insertion_point(field_get:mpfmessage.DBResInfo.db_conn_pare)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::DbLoginPara*>(
      &::mpfmessage::_DbLoginPara_default_instance_);
}
inline ::mpfmessage::DbLoginPara* DBResInfo::release_db_conn_pare() {
  // @@protoc_insertion_point(field_release:mpfmessage.DBResInfo.db_conn_pare)
  clear_has_db_conn_pare();
  ::mpfmessage::DbLoginPara* temp = db_conn_pare_;
  db_conn_pare_ = NULL;
  return temp;
}
inline ::mpfmessage::DbLoginPara* DBResInfo::mutable_db_conn_pare() {
  set_has_db_conn_pare();
  if (db_conn_pare_ == NULL) {
    db_conn_pare_ = new ::mpfmessage::DbLoginPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.DBResInfo.db_conn_pare)
  return db_conn_pare_;
}
inline void DBResInfo::set_allocated_db_conn_pare(::mpfmessage::DbLoginPara* db_conn_pare) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete db_conn_pare_;
  }
  if (db_conn_pare) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      db_conn_pare = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, db_conn_pare, submessage_arena);
    }
    set_has_db_conn_pare();
  } else {
    clear_has_db_conn_pare();
  }
  db_conn_pare_ = db_conn_pare;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DBResInfo.db_conn_pare)
}

// -------------------------------------------------------------------

// MsgDBPerfCollectReq

// repeated .mpfmessage.DBResInfo dbreslist = 1;
inline int MsgDBPerfCollectReq::dbreslist_size() const {
  return dbreslist_.size();
}
inline void MsgDBPerfCollectReq::clear_dbreslist() {
  dbreslist_.Clear();
}
inline const ::mpfmessage::DBResInfo& MsgDBPerfCollectReq::dbreslist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDBPerfCollectReq.dbreslist)
  return dbreslist_.Get(index);
}
inline ::mpfmessage::DBResInfo* MsgDBPerfCollectReq::mutable_dbreslist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDBPerfCollectReq.dbreslist)
  return dbreslist_.Mutable(index);
}
inline ::mpfmessage::DBResInfo* MsgDBPerfCollectReq::add_dbreslist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgDBPerfCollectReq.dbreslist)
  return dbreslist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::DBResInfo >*
MsgDBPerfCollectReq::mutable_dbreslist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgDBPerfCollectReq.dbreslist)
  return &dbreslist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DBResInfo >&
MsgDBPerfCollectReq::dbreslist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgDBPerfCollectReq.dbreslist)
  return dbreslist_;
}

// optional uint32 collect_time = 2;
inline bool MsgDBPerfCollectReq::has_collect_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgDBPerfCollectReq::set_has_collect_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgDBPerfCollectReq::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgDBPerfCollectReq::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgDBPerfCollectReq::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDBPerfCollectReq.collect_time)
  return collect_time_;
}
inline void MsgDBPerfCollectReq::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgDBPerfCollectReq.collect_time)
}

// -------------------------------------------------------------------

// MsgDBPerfCollectResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgDBPerfCollectResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgDBPerfCollectResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgDBPerfCollectResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgDBPerfCollectResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDBPerfCollectResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgDBPerfCollectResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDBPerfCollectResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgDBPerfCollectResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDBPerfCollectResp.result)
  return result_;
}
inline void MsgDBPerfCollectResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDBPerfCollectResp.result)
}

// -------------------------------------------------------------------

// MidwareResInfo

// optional uint32 res_id = 1;
inline bool MidwareResInfo::has_res_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MidwareResInfo::set_has_res_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MidwareResInfo::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MidwareResInfo::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 MidwareResInfo::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwareResInfo.res_id)
  return res_id_;
}
inline void MidwareResInfo::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwareResInfo.res_id)
}

// optional .mpfmessage.SnmpInfo snmp_info = 2;
inline bool MidwareResInfo::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MidwareResInfo::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MidwareResInfo::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MidwareResInfo::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& MidwareResInfo::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.MidwareResInfo.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* MidwareResInfo::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.MidwareResInfo.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* MidwareResInfo::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MidwareResInfo.snmp_info)
  return snmp_info_;
}
inline void MidwareResInfo::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MidwareResInfo.snmp_info)
}

// optional .mpfmessage.OSTYPE os_type = 3;
inline bool MidwareResInfo::has_os_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MidwareResInfo::set_has_os_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MidwareResInfo::clear_has_os_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MidwareResInfo::clear_os_type() {
  os_type_ = 1;
  clear_has_os_type();
}
inline ::mpfmessage::OSTYPE MidwareResInfo::os_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwareResInfo.os_type)
  return static_cast< ::mpfmessage::OSTYPE >(os_type_);
}
inline void MidwareResInfo::set_os_type(::mpfmessage::OSTYPE value) {
  assert(::mpfmessage::OSTYPE_IsValid(value));
  set_has_os_type();
  os_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwareResInfo.os_type)
}

// optional .mpfmessage.MidwareType mid_type = 4;
inline bool MidwareResInfo::has_mid_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MidwareResInfo::set_has_mid_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MidwareResInfo::clear_has_mid_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MidwareResInfo::clear_mid_type() {
  mid_type_ = 1;
  clear_has_mid_type();
}
inline ::mpfmessage::MidwareType MidwareResInfo::mid_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MidwareResInfo.mid_type)
  return static_cast< ::mpfmessage::MidwareType >(mid_type_);
}
inline void MidwareResInfo::set_mid_type(::mpfmessage::MidwareType value) {
  assert(::mpfmessage::MidwareType_IsValid(value));
  set_has_mid_type();
  mid_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MidwareResInfo.mid_type)
}

// -------------------------------------------------------------------

// MsgMidwarePerfCollectReq

// repeated .mpfmessage.MidwareResInfo midreslist = 1;
inline int MsgMidwarePerfCollectReq::midreslist_size() const {
  return midreslist_.size();
}
inline void MsgMidwarePerfCollectReq::clear_midreslist() {
  midreslist_.Clear();
}
inline const ::mpfmessage::MidwareResInfo& MsgMidwarePerfCollectReq::midreslist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgMidwarePerfCollectReq.midreslist)
  return midreslist_.Get(index);
}
inline ::mpfmessage::MidwareResInfo* MsgMidwarePerfCollectReq::mutable_midreslist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgMidwarePerfCollectReq.midreslist)
  return midreslist_.Mutable(index);
}
inline ::mpfmessage::MidwareResInfo* MsgMidwarePerfCollectReq::add_midreslist() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgMidwarePerfCollectReq.midreslist)
  return midreslist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::MidwareResInfo >*
MsgMidwarePerfCollectReq::mutable_midreslist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgMidwarePerfCollectReq.midreslist)
  return &midreslist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::MidwareResInfo >&
MsgMidwarePerfCollectReq::midreslist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgMidwarePerfCollectReq.midreslist)
  return midreslist_;
}

// optional uint32 collect_time = 2;
inline bool MsgMidwarePerfCollectReq::has_collect_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgMidwarePerfCollectReq::set_has_collect_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgMidwarePerfCollectReq::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgMidwarePerfCollectReq::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgMidwarePerfCollectReq::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgMidwarePerfCollectReq.collect_time)
  return collect_time_;
}
inline void MsgMidwarePerfCollectReq::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgMidwarePerfCollectReq.collect_time)
}

// -------------------------------------------------------------------

// MsgMidwarePerfCollectResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgMidwarePerfCollectResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgMidwarePerfCollectResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgMidwarePerfCollectResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgMidwarePerfCollectResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgMidwarePerfCollectResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgMidwarePerfCollectResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgMidwarePerfCollectResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgMidwarePerfCollectResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgMidwarePerfCollectResp.result)
  return result_;
}
inline void MsgMidwarePerfCollectResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgMidwarePerfCollectResp.result)
}

// -------------------------------------------------------------------

// DataSourceId

// optional uint32 device_room_id = 1;
inline bool DataSourceId::has_device_room_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceId::set_has_device_room_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceId::clear_has_device_room_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceId::clear_device_room_id() {
  device_room_id_ = 0u;
  clear_has_device_room_id();
}
inline ::google::protobuf::uint32 DataSourceId::device_room_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceId.device_room_id)
  return device_room_id_;
}
inline void DataSourceId::set_device_room_id(::google::protobuf::uint32 value) {
  set_has_device_room_id();
  device_room_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DataSourceId.device_room_id)
}

// optional uint32 res_id = 2;
inline bool DataSourceId::has_res_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceId::set_has_res_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceId::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceId::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 DataSourceId::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceId.res_id)
  return res_id_;
}
inline void DataSourceId::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DataSourceId.res_id)
}

// optional .mpfmessage.SnmpInfo snmp_info = 3;
inline bool DataSourceId::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceId::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceId::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceId::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& DataSourceId::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceId.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* DataSourceId::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.DataSourceId.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* DataSourceId::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.DataSourceId.snmp_info)
  return snmp_info_;
}
inline void DataSourceId::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DataSourceId.snmp_info)
}

// -------------------------------------------------------------------

// MsgRoomResSyncReq

// repeated .mpfmessage.DataSourceId ds_list = 1;
inline int MsgRoomResSyncReq::ds_list_size() const {
  return ds_list_.size();
}
inline void MsgRoomResSyncReq::clear_ds_list() {
  ds_list_.Clear();
}
inline const ::mpfmessage::DataSourceId& MsgRoomResSyncReq::ds_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgRoomResSyncReq.ds_list)
  return ds_list_.Get(index);
}
inline ::mpfmessage::DataSourceId* MsgRoomResSyncReq::mutable_ds_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgRoomResSyncReq.ds_list)
  return ds_list_.Mutable(index);
}
inline ::mpfmessage::DataSourceId* MsgRoomResSyncReq::add_ds_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgRoomResSyncReq.ds_list)
  return ds_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >*
MsgRoomResSyncReq::mutable_ds_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgRoomResSyncReq.ds_list)
  return &ds_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >&
MsgRoomResSyncReq::ds_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgRoomResSyncReq.ds_list)
  return ds_list_;
}

// -------------------------------------------------------------------

// Sensor

// optional string serial = 1;
inline bool Sensor::has_serial() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Sensor::set_has_serial() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Sensor::clear_has_serial() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Sensor::clear_serial() {
  serial_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serial();
}
inline const ::std::string& Sensor::serial() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.serial)
  return serial_.GetNoArena();
}
inline void Sensor::set_serial(const ::std::string& value) {
  set_has_serial();
  serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.serial)
}
#if LANG_CXX11
inline void Sensor::set_serial(::std::string&& value) {
  set_has_serial();
  serial_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.Sensor.serial)
}
#endif
inline void Sensor::set_serial(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serial();
  serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.Sensor.serial)
}
inline void Sensor::set_serial(const char* value, size_t size) {
  set_has_serial();
  serial_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.Sensor.serial)
}
inline ::std::string* Sensor::mutable_serial() {
  set_has_serial();
  // @@protoc_insertion_point(field_mutable:mpfmessage.Sensor.serial)
  return serial_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_serial() {
  // @@protoc_insertion_point(field_release:mpfmessage.Sensor.serial)
  clear_has_serial();
  return serial_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_serial(::std::string* serial) {
  if (serial != NULL) {
    set_has_serial();
  } else {
    clear_has_serial();
  }
  serial_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.Sensor.serial)
}

// optional string name = 2;
inline bool Sensor::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Sensor::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Sensor::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Sensor::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Sensor::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.name)
  return name_.GetNoArena();
}
inline void Sensor::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.name)
}
#if LANG_CXX11
inline void Sensor::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.Sensor.name)
}
#endif
inline void Sensor::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.Sensor.name)
}
inline void Sensor::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.Sensor.name)
}
inline ::std::string* Sensor::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.Sensor.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.Sensor.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.Sensor.name)
}

// optional uint32 type = 3;
inline bool Sensor::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Sensor::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Sensor::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Sensor::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Sensor::type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.type)
  return type_;
}
inline void Sensor::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.type)
}

// optional string units = 4;
inline bool Sensor::has_units() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Sensor::set_has_units() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Sensor::clear_has_units() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Sensor::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& Sensor::units() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.units)
  return units_.GetNoArena();
}
inline void Sensor::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.units)
}
#if LANG_CXX11
inline void Sensor::set_units(::std::string&& value) {
  set_has_units();
  units_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.Sensor.units)
}
#endif
inline void Sensor::set_units(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.Sensor.units)
}
inline void Sensor::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.Sensor.units)
}
inline ::std::string* Sensor::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:mpfmessage.Sensor.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_units() {
  // @@protoc_insertion_point(field_release:mpfmessage.Sensor.units)
  clear_has_units();
  return units_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.Sensor.units)
}

// optional .mpfmessage.AvailableStatus status = 5;
inline bool Sensor::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Sensor::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Sensor::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Sensor::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mpfmessage::AvailableStatus Sensor::status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.status)
  return static_cast< ::mpfmessage::AvailableStatus >(status_);
}
inline void Sensor::set_status(::mpfmessage::AvailableStatus value) {
  assert(::mpfmessage::AvailableStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.status)
}

// optional uint32 sensorid = 6;
inline bool Sensor::has_sensorid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Sensor::set_has_sensorid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Sensor::clear_has_sensorid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Sensor::clear_sensorid() {
  sensorid_ = 0u;
  clear_has_sensorid();
}
inline ::google::protobuf::uint32 Sensor::sensorid() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.sensorid)
  return sensorid_;
}
inline void Sensor::set_sensorid(::google::protobuf::uint32 value) {
  set_has_sensorid();
  sensorid_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.sensorid)
}

// optional string index = 7;
inline bool Sensor::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Sensor::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Sensor::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Sensor::clear_index() {
  index_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_index();
}
inline const ::std::string& Sensor::index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.Sensor.index)
  return index_.GetNoArena();
}
inline void Sensor::set_index(const ::std::string& value) {
  set_has_index();
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.Sensor.index)
}
#if LANG_CXX11
inline void Sensor::set_index(::std::string&& value) {
  set_has_index();
  index_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.Sensor.index)
}
#endif
inline void Sensor::set_index(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_index();
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.Sensor.index)
}
inline void Sensor::set_index(const char* value, size_t size) {
  set_has_index();
  index_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.Sensor.index)
}
inline ::std::string* Sensor::mutable_index() {
  set_has_index();
  // @@protoc_insertion_point(field_mutable:mpfmessage.Sensor.index)
  return index_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Sensor::release_index() {
  // @@protoc_insertion_point(field_release:mpfmessage.Sensor.index)
  clear_has_index();
  return index_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Sensor::set_allocated_index(::std::string* index) {
  if (index != NULL) {
    set_has_index();
  } else {
    clear_has_index();
  }
  index_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), index);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.Sensor.index)
}

// -------------------------------------------------------------------

// DataSourceSyncResult

// optional uint32 ds_res_id = 1;
inline bool DataSourceSyncResult::has_ds_res_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataSourceSyncResult::set_has_ds_res_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataSourceSyncResult::clear_has_ds_res_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataSourceSyncResult::clear_ds_res_id() {
  ds_res_id_ = 0u;
  clear_has_ds_res_id();
}
inline ::google::protobuf::uint32 DataSourceSyncResult::ds_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceSyncResult.ds_res_id)
  return ds_res_id_;
}
inline void DataSourceSyncResult::set_ds_res_id(::google::protobuf::uint32 value) {
  set_has_ds_res_id();
  ds_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DataSourceSyncResult.ds_res_id)
}

// optional uint32 resultcode = 2;
inline bool DataSourceSyncResult::has_resultcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataSourceSyncResult::set_has_resultcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataSourceSyncResult::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataSourceSyncResult::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 DataSourceSyncResult::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceSyncResult.resultcode)
  return resultcode_;
}
inline void DataSourceSyncResult::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.DataSourceSyncResult.resultcode)
}

// optional string detail = 3;
inline bool DataSourceSyncResult::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataSourceSyncResult::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataSourceSyncResult::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataSourceSyncResult::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& DataSourceSyncResult::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceSyncResult.detail)
  return detail_.GetNoArena();
}
inline void DataSourceSyncResult::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.DataSourceSyncResult.detail)
}
#if LANG_CXX11
inline void DataSourceSyncResult::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.DataSourceSyncResult.detail)
}
#endif
inline void DataSourceSyncResult::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.DataSourceSyncResult.detail)
}
inline void DataSourceSyncResult::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.DataSourceSyncResult.detail)
}
inline ::std::string* DataSourceSyncResult::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.DataSourceSyncResult.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataSourceSyncResult::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.DataSourceSyncResult.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataSourceSyncResult::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.DataSourceSyncResult.detail)
}

// repeated .mpfmessage.Sensor sensorlist = 4;
inline int DataSourceSyncResult::sensorlist_size() const {
  return sensorlist_.size();
}
inline void DataSourceSyncResult::clear_sensorlist() {
  sensorlist_.Clear();
}
inline const ::mpfmessage::Sensor& DataSourceSyncResult::sensorlist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.DataSourceSyncResult.sensorlist)
  return sensorlist_.Get(index);
}
inline ::mpfmessage::Sensor* DataSourceSyncResult::mutable_sensorlist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.DataSourceSyncResult.sensorlist)
  return sensorlist_.Mutable(index);
}
inline ::mpfmessage::Sensor* DataSourceSyncResult::add_sensorlist() {
  // @@protoc_insertion_point(field_add:mpfmessage.DataSourceSyncResult.sensorlist)
  return sensorlist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::Sensor >*
DataSourceSyncResult::mutable_sensorlist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.DataSourceSyncResult.sensorlist)
  return &sensorlist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::Sensor >&
DataSourceSyncResult::sensorlist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.DataSourceSyncResult.sensorlist)
  return sensorlist_;
}

// -------------------------------------------------------------------

// MsgMachineRoomResSyncResp

// repeated .mpfmessage.DataSourceSyncResult ds_res_list = 1;
inline int MsgMachineRoomResSyncResp::ds_res_list_size() const {
  return ds_res_list_.size();
}
inline void MsgMachineRoomResSyncResp::clear_ds_res_list() {
  ds_res_list_.Clear();
}
inline const ::mpfmessage::DataSourceSyncResult& MsgMachineRoomResSyncResp::ds_res_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgMachineRoomResSyncResp.ds_res_list)
  return ds_res_list_.Get(index);
}
inline ::mpfmessage::DataSourceSyncResult* MsgMachineRoomResSyncResp::mutable_ds_res_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgMachineRoomResSyncResp.ds_res_list)
  return ds_res_list_.Mutable(index);
}
inline ::mpfmessage::DataSourceSyncResult* MsgMachineRoomResSyncResp::add_ds_res_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgMachineRoomResSyncResp.ds_res_list)
  return ds_res_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceSyncResult >*
MsgMachineRoomResSyncResp::mutable_ds_res_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgMachineRoomResSyncResp.ds_res_list)
  return &ds_res_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceSyncResult >&
MsgMachineRoomResSyncResp::ds_res_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgMachineRoomResSyncResp.ds_res_list)
  return ds_res_list_;
}

// -------------------------------------------------------------------

// MsgGetSenserValueReq

// repeated .mpfmessage.DataSourceId ds_list = 1;
inline int MsgGetSenserValueReq::ds_list_size() const {
  return ds_list_.size();
}
inline void MsgGetSenserValueReq::clear_ds_list() {
  ds_list_.Clear();
}
inline const ::mpfmessage::DataSourceId& MsgGetSenserValueReq::ds_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetSenserValueReq.ds_list)
  return ds_list_.Get(index);
}
inline ::mpfmessage::DataSourceId* MsgGetSenserValueReq::mutable_ds_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetSenserValueReq.ds_list)
  return ds_list_.Mutable(index);
}
inline ::mpfmessage::DataSourceId* MsgGetSenserValueReq::add_ds_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgGetSenserValueReq.ds_list)
  return ds_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >*
MsgGetSenserValueReq::mutable_ds_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgGetSenserValueReq.ds_list)
  return &ds_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::DataSourceId >&
MsgGetSenserValueReq::ds_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgGetSenserValueReq.ds_list)
  return ds_list_;
}

// optional uint32 collect_time = 2;
inline bool MsgGetSenserValueReq::has_collect_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetSenserValueReq::set_has_collect_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetSenserValueReq::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgGetSenserValueReq::clear_collect_time() {
  collect_time_ = 0u;
  clear_has_collect_time();
}
inline ::google::protobuf::uint32 MsgGetSenserValueReq::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetSenserValueReq.collect_time)
  return collect_time_;
}
inline void MsgGetSenserValueReq::set_collect_time(::google::protobuf::uint32 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgGetSenserValueReq.collect_time)
}

// -------------------------------------------------------------------

// SenserValue

// optional uint32 index = 1;
inline bool SenserValue::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenserValue::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenserValue::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenserValue::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SenserValue::index() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.index)
  return index_;
}
inline void SenserValue::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.index)
}

// optional uint32 type = 2;
inline bool SenserValue::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenserValue::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenserValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenserValue::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 SenserValue::type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.type)
  return type_;
}
inline void SenserValue::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.type)
}

// optional uint32 available = 3;
inline bool SenserValue::has_available() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SenserValue::set_has_available() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SenserValue::clear_has_available() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SenserValue::clear_available() {
  available_ = 0u;
  clear_has_available();
}
inline ::google::protobuf::uint32 SenserValue::available() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.available)
  return available_;
}
inline void SenserValue::set_available(::google::protobuf::uint32 value) {
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.available)
}

// optional .mpfmessage.Status status = 4;
inline bool SenserValue::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SenserValue::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SenserValue::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SenserValue::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mpfmessage::Status SenserValue::status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.status)
  return static_cast< ::mpfmessage::Status >(status_);
}
inline void SenserValue::set_status(::mpfmessage::Status value) {
  assert(::mpfmessage::Status_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.status)
}

// optional uint32 value = 5;
inline bool SenserValue::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SenserValue::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SenserValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SenserValue::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 SenserValue::value() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.value)
  return value_;
}
inline void SenserValue::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.value)
}

// optional uint32 timestamp = 6;
inline bool SenserValue::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SenserValue::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SenserValue::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SenserValue::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 SenserValue::timestamp() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserValue.timestamp)
  return timestamp_;
}
inline void SenserValue::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserValue.timestamp)
}

// -------------------------------------------------------------------

// SenserSyncResult

// optional uint32 ds_res_id = 1;
inline bool SenserSyncResult::has_ds_res_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SenserSyncResult::set_has_ds_res_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SenserSyncResult::clear_has_ds_res_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SenserSyncResult::clear_ds_res_id() {
  ds_res_id_ = 0u;
  clear_has_ds_res_id();
}
inline ::google::protobuf::uint32 SenserSyncResult::ds_res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserSyncResult.ds_res_id)
  return ds_res_id_;
}
inline void SenserSyncResult::set_ds_res_id(::google::protobuf::uint32 value) {
  set_has_ds_res_id();
  ds_res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserSyncResult.ds_res_id)
}

// optional uint32 resultcode = 2;
inline bool SenserSyncResult::has_resultcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SenserSyncResult::set_has_resultcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SenserSyncResult::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SenserSyncResult::clear_resultcode() {
  resultcode_ = 0u;
  clear_has_resultcode();
}
inline ::google::protobuf::uint32 SenserSyncResult::resultcode() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserSyncResult.resultcode)
  return resultcode_;
}
inline void SenserSyncResult::set_resultcode(::google::protobuf::uint32 value) {
  set_has_resultcode();
  resultcode_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.SenserSyncResult.resultcode)
}

// optional string detail = 3;
inline bool SenserSyncResult::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SenserSyncResult::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SenserSyncResult::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SenserSyncResult::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& SenserSyncResult::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserSyncResult.detail)
  return detail_.GetNoArena();
}
inline void SenserSyncResult::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.SenserSyncResult.detail)
}
#if LANG_CXX11
inline void SenserSyncResult::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.SenserSyncResult.detail)
}
#endif
inline void SenserSyncResult::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.SenserSyncResult.detail)
}
inline void SenserSyncResult::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.SenserSyncResult.detail)
}
inline ::std::string* SenserSyncResult::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.SenserSyncResult.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SenserSyncResult::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.SenserSyncResult.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SenserSyncResult::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.SenserSyncResult.detail)
}

// repeated .mpfmessage.SenserValue valuelist = 4;
inline int SenserSyncResult::valuelist_size() const {
  return valuelist_.size();
}
inline void SenserSyncResult::clear_valuelist() {
  valuelist_.Clear();
}
inline const ::mpfmessage::SenserValue& SenserSyncResult::valuelist(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.SenserSyncResult.valuelist)
  return valuelist_.Get(index);
}
inline ::mpfmessage::SenserValue* SenserSyncResult::mutable_valuelist(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.SenserSyncResult.valuelist)
  return valuelist_.Mutable(index);
}
inline ::mpfmessage::SenserValue* SenserSyncResult::add_valuelist() {
  // @@protoc_insertion_point(field_add:mpfmessage.SenserSyncResult.valuelist)
  return valuelist_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::SenserValue >*
SenserSyncResult::mutable_valuelist() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.SenserSyncResult.valuelist)
  return &valuelist_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SenserValue >&
SenserSyncResult::valuelist() const {
  // @@protoc_insertion_point(field_list:mpfmessage.SenserSyncResult.valuelist)
  return valuelist_;
}

// -------------------------------------------------------------------

// MsgGetSenserValueResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgGetSenserValueResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgGetSenserValueResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgGetSenserValueResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgGetSenserValueResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgGetSenserValueResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgGetSenserValueResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgGetSenserValueResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgGetSenserValueResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgGetSenserValueResp.result)
  return result_;
}
inline void MsgGetSenserValueResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgGetSenserValueResp.result)
}

// -------------------------------------------------------------------

// ConnectivityTestSynReq

// optional uint32 res_id = 1;
inline bool ConnectivityTestSynReq::has_res_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ConnectivityTestSynReq::set_has_res_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ConnectivityTestSynReq::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ConnectivityTestSynReq::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 ConnectivityTestSynReq::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.res_id)
  return res_id_;
}
inline void ConnectivityTestSynReq::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ConnectivityTestSynReq.res_id)
}

// optional .mpfmessage.ResType res_type = 2;
inline bool ConnectivityTestSynReq::has_res_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ConnectivityTestSynReq::set_has_res_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ConnectivityTestSynReq::clear_has_res_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ConnectivityTestSynReq::clear_res_type() {
  res_type_ = 1;
  clear_has_res_type();
}
inline ::mpfmessage::ResType ConnectivityTestSynReq::res_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.res_type)
  return static_cast< ::mpfmessage::ResType >(res_type_);
}
inline void ConnectivityTestSynReq::set_res_type(::mpfmessage::ResType value) {
  assert(::mpfmessage::ResType_IsValid(value));
  set_has_res_type();
  res_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ConnectivityTestSynReq.res_type)
}

// optional .mpfmessage.ConnectivityTestType test_type = 3;
inline bool ConnectivityTestSynReq::has_test_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ConnectivityTestSynReq::set_has_test_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ConnectivityTestSynReq::clear_has_test_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ConnectivityTestSynReq::clear_test_type() {
  test_type_ = 1;
  clear_has_test_type();
}
inline ::mpfmessage::ConnectivityTestType ConnectivityTestSynReq::test_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.test_type)
  return static_cast< ::mpfmessage::ConnectivityTestType >(test_type_);
}
inline void ConnectivityTestSynReq::set_test_type(::mpfmessage::ConnectivityTestType value) {
  assert(::mpfmessage::ConnectivityTestType_IsValid(value));
  set_has_test_type();
  test_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ConnectivityTestSynReq.test_type)
}

// optional .mpfmessage.SnmpInfo snmp_info = 4;
inline bool ConnectivityTestSynReq::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConnectivityTestSynReq::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConnectivityTestSynReq::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConnectivityTestSynReq::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& ConnectivityTestSynReq::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* ConnectivityTestSynReq::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.ConnectivityTestSynReq.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* ConnectivityTestSynReq::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ConnectivityTestSynReq.snmp_info)
  return snmp_info_;
}
inline void ConnectivityTestSynReq::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ConnectivityTestSynReq.snmp_info)
}

// optional .mpfmessage.TelnetPara telentPara = 5;
inline bool ConnectivityTestSynReq::has_telentpara() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConnectivityTestSynReq::set_has_telentpara() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConnectivityTestSynReq::clear_has_telentpara() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConnectivityTestSynReq::clear_telentpara() {
  if (telentpara_ != NULL) telentpara_->Clear();
  clear_has_telentpara();
}
inline const ::mpfmessage::TelnetPara& ConnectivityTestSynReq::telentpara() const {
  const ::mpfmessage::TelnetPara* p = telentpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.telentPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::TelnetPara*>(
      &::mpfmessage::_TelnetPara_default_instance_);
}
inline ::mpfmessage::TelnetPara* ConnectivityTestSynReq::release_telentpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.ConnectivityTestSynReq.telentPara)
  clear_has_telentpara();
  ::mpfmessage::TelnetPara* temp = telentpara_;
  telentpara_ = NULL;
  return temp;
}
inline ::mpfmessage::TelnetPara* ConnectivityTestSynReq::mutable_telentpara() {
  set_has_telentpara();
  if (telentpara_ == NULL) {
    telentpara_ = new ::mpfmessage::TelnetPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ConnectivityTestSynReq.telentPara)
  return telentpara_;
}
inline void ConnectivityTestSynReq::set_allocated_telentpara(::mpfmessage::TelnetPara* telentpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete telentpara_;
  }
  if (telentpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      telentpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, telentpara, submessage_arena);
    }
    set_has_telentpara();
  } else {
    clear_has_telentpara();
  }
  telentpara_ = telentpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ConnectivityTestSynReq.telentPara)
}

// optional .mpfmessage.SshPara sshPara = 6;
inline bool ConnectivityTestSynReq::has_sshpara() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConnectivityTestSynReq::set_has_sshpara() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConnectivityTestSynReq::clear_has_sshpara() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConnectivityTestSynReq::clear_sshpara() {
  if (sshpara_ != NULL) sshpara_->Clear();
  clear_has_sshpara();
}
inline const ::mpfmessage::SshPara& ConnectivityTestSynReq::sshpara() const {
  const ::mpfmessage::SshPara* p = sshpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.sshPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SshPara*>(
      &::mpfmessage::_SshPara_default_instance_);
}
inline ::mpfmessage::SshPara* ConnectivityTestSynReq::release_sshpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.ConnectivityTestSynReq.sshPara)
  clear_has_sshpara();
  ::mpfmessage::SshPara* temp = sshpara_;
  sshpara_ = NULL;
  return temp;
}
inline ::mpfmessage::SshPara* ConnectivityTestSynReq::mutable_sshpara() {
  set_has_sshpara();
  if (sshpara_ == NULL) {
    sshpara_ = new ::mpfmessage::SshPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ConnectivityTestSynReq.sshPara)
  return sshpara_;
}
inline void ConnectivityTestSynReq::set_allocated_sshpara(::mpfmessage::SshPara* sshpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sshpara_;
  }
  if (sshpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sshpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sshpara, submessage_arena);
    }
    set_has_sshpara();
  } else {
    clear_has_sshpara();
  }
  sshpara_ = sshpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ConnectivityTestSynReq.sshPara)
}

// optional .mpfmessage.PingPara pingPara = 7;
inline bool ConnectivityTestSynReq::has_pingpara() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConnectivityTestSynReq::set_has_pingpara() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConnectivityTestSynReq::clear_has_pingpara() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConnectivityTestSynReq::clear_pingpara() {
  if (pingpara_ != NULL) pingpara_->Clear();
  clear_has_pingpara();
}
inline const ::mpfmessage::PingPara& ConnectivityTestSynReq::pingpara() const {
  const ::mpfmessage::PingPara* p = pingpara_;
  // @@protoc_insertion_point(field_get:mpfmessage.ConnectivityTestSynReq.pingPara)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::PingPara*>(
      &::mpfmessage::_PingPara_default_instance_);
}
inline ::mpfmessage::PingPara* ConnectivityTestSynReq::release_pingpara() {
  // @@protoc_insertion_point(field_release:mpfmessage.ConnectivityTestSynReq.pingPara)
  clear_has_pingpara();
  ::mpfmessage::PingPara* temp = pingpara_;
  pingpara_ = NULL;
  return temp;
}
inline ::mpfmessage::PingPara* ConnectivityTestSynReq::mutable_pingpara() {
  set_has_pingpara();
  if (pingpara_ == NULL) {
    pingpara_ = new ::mpfmessage::PingPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ConnectivityTestSynReq.pingPara)
  return pingpara_;
}
inline void ConnectivityTestSynReq::set_allocated_pingpara(::mpfmessage::PingPara* pingpara) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete pingpara_;
  }
  if (pingpara) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      pingpara = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pingpara, submessage_arena);
    }
    set_has_pingpara();
  } else {
    clear_has_pingpara();
  }
  pingpara_ = pingpara;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ConnectivityTestSynReq.pingPara)
}

// -------------------------------------------------------------------

// MsgConnectivityTestSynResp

// optional uint32 res_id = 1;
inline bool MsgConnectivityTestSynResp::has_res_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgConnectivityTestSynResp::set_has_res_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgConnectivityTestSynResp::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgConnectivityTestSynResp::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 MsgConnectivityTestSynResp::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgConnectivityTestSynResp.res_id)
  return res_id_;
}
inline void MsgConnectivityTestSynResp::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgConnectivityTestSynResp.res_id)
}

// optional .mpfmessage.ConnectivityTestResult result = 2;
inline bool MsgConnectivityTestSynResp::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgConnectivityTestSynResp::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgConnectivityTestSynResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgConnectivityTestSynResp::clear_result() {
  result_ = 1;
  clear_has_result();
}
inline ::mpfmessage::ConnectivityTestResult MsgConnectivityTestSynResp::result() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgConnectivityTestSynResp.result)
  return static_cast< ::mpfmessage::ConnectivityTestResult >(result_);
}
inline void MsgConnectivityTestSynResp::set_result(::mpfmessage::ConnectivityTestResult value) {
  assert(::mpfmessage::ConnectivityTestResult_IsValid(value));
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgConnectivityTestSynResp.result)
}

// -------------------------------------------------------------------

// MsgDevTestPara

// optional uint32 res_id = 1;
inline bool MsgDevTestPara::has_res_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgDevTestPara::set_has_res_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgDevTestPara::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgDevTestPara::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 MsgDevTestPara::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.res_id)
  return res_id_;
}
inline void MsgDevTestPara::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgDevTestPara.res_id)
}

// optional string ip = 2;
inline bool MsgDevTestPara::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgDevTestPara::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgDevTestPara::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgDevTestPara::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& MsgDevTestPara::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.ip)
  return ip_.GetNoArena();
}
inline void MsgDevTestPara::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.MsgDevTestPara.ip)
}
#if LANG_CXX11
inline void MsgDevTestPara::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.MsgDevTestPara.ip)
}
#endif
inline void MsgDevTestPara::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.MsgDevTestPara.ip)
}
inline void MsgDevTestPara::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.MsgDevTestPara.ip)
}
inline ::std::string* MsgDevTestPara::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevTestPara.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MsgDevTestPara::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevTestPara.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MsgDevTestPara::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevTestPara.ip)
}

// optional uint32 test_type = 3;
inline bool MsgDevTestPara::has_test_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MsgDevTestPara::set_has_test_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MsgDevTestPara::clear_has_test_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MsgDevTestPara::clear_test_type() {
  test_type_ = 0u;
  clear_has_test_type();
}
inline ::google::protobuf::uint32 MsgDevTestPara::test_type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.test_type)
  return test_type_;
}
inline void MsgDevTestPara::set_test_type(::google::protobuf::uint32 value) {
  set_has_test_type();
  test_type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgDevTestPara.test_type)
}

// optional .mpfmessage.PingPara ping_para = 4;
inline bool MsgDevTestPara::has_ping_para() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgDevTestPara::set_has_ping_para() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgDevTestPara::clear_has_ping_para() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgDevTestPara::clear_ping_para() {
  if (ping_para_ != NULL) ping_para_->Clear();
  clear_has_ping_para();
}
inline const ::mpfmessage::PingPara& MsgDevTestPara::ping_para() const {
  const ::mpfmessage::PingPara* p = ping_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.ping_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::PingPara*>(
      &::mpfmessage::_PingPara_default_instance_);
}
inline ::mpfmessage::PingPara* MsgDevTestPara::release_ping_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevTestPara.ping_para)
  clear_has_ping_para();
  ::mpfmessage::PingPara* temp = ping_para_;
  ping_para_ = NULL;
  return temp;
}
inline ::mpfmessage::PingPara* MsgDevTestPara::mutable_ping_para() {
  set_has_ping_para();
  if (ping_para_ == NULL) {
    ping_para_ = new ::mpfmessage::PingPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevTestPara.ping_para)
  return ping_para_;
}
inline void MsgDevTestPara::set_allocated_ping_para(::mpfmessage::PingPara* ping_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ping_para_;
  }
  if (ping_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ping_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ping_para, submessage_arena);
    }
    set_has_ping_para();
  } else {
    clear_has_ping_para();
  }
  ping_para_ = ping_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevTestPara.ping_para)
}

// optional .mpfmessage.SnmpInfo snmp_para = 5;
inline bool MsgDevTestPara::has_snmp_para() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgDevTestPara::set_has_snmp_para() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgDevTestPara::clear_has_snmp_para() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgDevTestPara::clear_snmp_para() {
  if (snmp_para_ != NULL) snmp_para_->Clear();
  clear_has_snmp_para();
}
inline const ::mpfmessage::SnmpInfo& MsgDevTestPara::snmp_para() const {
  const ::mpfmessage::SnmpInfo* p = snmp_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.snmp_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* MsgDevTestPara::release_snmp_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevTestPara.snmp_para)
  clear_has_snmp_para();
  ::mpfmessage::SnmpInfo* temp = snmp_para_;
  snmp_para_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* MsgDevTestPara::mutable_snmp_para() {
  set_has_snmp_para();
  if (snmp_para_ == NULL) {
    snmp_para_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevTestPara.snmp_para)
  return snmp_para_;
}
inline void MsgDevTestPara::set_allocated_snmp_para(::mpfmessage::SnmpInfo* snmp_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_para_;
  }
  if (snmp_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_para, submessage_arena);
    }
    set_has_snmp_para();
  } else {
    clear_has_snmp_para();
  }
  snmp_para_ = snmp_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevTestPara.snmp_para)
}

// optional .mpfmessage.SshPara ssh_para = 6;
inline bool MsgDevTestPara::has_ssh_para() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgDevTestPara::set_has_ssh_para() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgDevTestPara::clear_has_ssh_para() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgDevTestPara::clear_ssh_para() {
  if (ssh_para_ != NULL) ssh_para_->Clear();
  clear_has_ssh_para();
}
inline const ::mpfmessage::SshPara& MsgDevTestPara::ssh_para() const {
  const ::mpfmessage::SshPara* p = ssh_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.ssh_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SshPara*>(
      &::mpfmessage::_SshPara_default_instance_);
}
inline ::mpfmessage::SshPara* MsgDevTestPara::release_ssh_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevTestPara.ssh_para)
  clear_has_ssh_para();
  ::mpfmessage::SshPara* temp = ssh_para_;
  ssh_para_ = NULL;
  return temp;
}
inline ::mpfmessage::SshPara* MsgDevTestPara::mutable_ssh_para() {
  set_has_ssh_para();
  if (ssh_para_ == NULL) {
    ssh_para_ = new ::mpfmessage::SshPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevTestPara.ssh_para)
  return ssh_para_;
}
inline void MsgDevTestPara::set_allocated_ssh_para(::mpfmessage::SshPara* ssh_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ssh_para_;
  }
  if (ssh_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ssh_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ssh_para, submessage_arena);
    }
    set_has_ssh_para();
  } else {
    clear_has_ssh_para();
  }
  ssh_para_ = ssh_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevTestPara.ssh_para)
}

// optional .mpfmessage.TelnetPara telnet_para = 7;
inline bool MsgDevTestPara::has_telnet_para() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgDevTestPara::set_has_telnet_para() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgDevTestPara::clear_has_telnet_para() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgDevTestPara::clear_telnet_para() {
  if (telnet_para_ != NULL) telnet_para_->Clear();
  clear_has_telnet_para();
}
inline const ::mpfmessage::TelnetPara& MsgDevTestPara::telnet_para() const {
  const ::mpfmessage::TelnetPara* p = telnet_para_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgDevTestPara.telnet_para)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::TelnetPara*>(
      &::mpfmessage::_TelnetPara_default_instance_);
}
inline ::mpfmessage::TelnetPara* MsgDevTestPara::release_telnet_para() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgDevTestPara.telnet_para)
  clear_has_telnet_para();
  ::mpfmessage::TelnetPara* temp = telnet_para_;
  telnet_para_ = NULL;
  return temp;
}
inline ::mpfmessage::TelnetPara* MsgDevTestPara::mutable_telnet_para() {
  set_has_telnet_para();
  if (telnet_para_ == NULL) {
    telnet_para_ = new ::mpfmessage::TelnetPara;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgDevTestPara.telnet_para)
  return telnet_para_;
}
inline void MsgDevTestPara::set_allocated_telnet_para(::mpfmessage::TelnetPara* telnet_para) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete telnet_para_;
  }
  if (telnet_para) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      telnet_para = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, telnet_para, submessage_arena);
    }
    set_has_telnet_para();
  } else {
    clear_has_telnet_para();
  }
  telnet_para_ = telnet_para;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgDevTestPara.telnet_para)
}

// -------------------------------------------------------------------

// MsgReachableTestReq

// repeated .mpfmessage.MsgDevTestPara dev_para_list = 1;
inline int MsgReachableTestReq::dev_para_list_size() const {
  return dev_para_list_.size();
}
inline void MsgReachableTestReq::clear_dev_para_list() {
  dev_para_list_.Clear();
}
inline const ::mpfmessage::MsgDevTestPara& MsgReachableTestReq::dev_para_list(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgReachableTestReq.dev_para_list)
  return dev_para_list_.Get(index);
}
inline ::mpfmessage::MsgDevTestPara* MsgReachableTestReq::mutable_dev_para_list(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgReachableTestReq.dev_para_list)
  return dev_para_list_.Mutable(index);
}
inline ::mpfmessage::MsgDevTestPara* MsgReachableTestReq::add_dev_para_list() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgReachableTestReq.dev_para_list)
  return dev_para_list_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::MsgDevTestPara >*
MsgReachableTestReq::mutable_dev_para_list() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgReachableTestReq.dev_para_list)
  return &dev_para_list_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::MsgDevTestPara >&
MsgReachableTestReq::dev_para_list() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgReachableTestReq.dev_para_list)
  return dev_para_list_;
}

// optional .mpfmessage.RespAddr notify_addr = 2;
inline bool MsgReachableTestReq::has_notify_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReachableTestReq::set_has_notify_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReachableTestReq::clear_has_notify_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReachableTestReq::clear_notify_addr() {
  if (notify_addr_ != NULL) notify_addr_->Clear();
  clear_has_notify_addr();
}
inline const ::mpfmessage::RespAddr& MsgReachableTestReq::notify_addr() const {
  const ::mpfmessage::RespAddr* p = notify_addr_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgReachableTestReq.notify_addr)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::RespAddr*>(
      &::mpfmessage::_RespAddr_default_instance_);
}
inline ::mpfmessage::RespAddr* MsgReachableTestReq::release_notify_addr() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgReachableTestReq.notify_addr)
  clear_has_notify_addr();
  ::mpfmessage::RespAddr* temp = notify_addr_;
  notify_addr_ = NULL;
  return temp;
}
inline ::mpfmessage::RespAddr* MsgReachableTestReq::mutable_notify_addr() {
  set_has_notify_addr();
  if (notify_addr_ == NULL) {
    notify_addr_ = new ::mpfmessage::RespAddr;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgReachableTestReq.notify_addr)
  return notify_addr_;
}
inline void MsgReachableTestReq::set_allocated_notify_addr(::mpfmessage::RespAddr* notify_addr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete notify_addr_;
  }
  if (notify_addr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      notify_addr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, notify_addr, submessage_arena);
    }
    set_has_notify_addr();
  } else {
    clear_has_notify_addr();
  }
  notify_addr_ = notify_addr;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgReachableTestReq.notify_addr)
}

// optional uint64 collect_time = 3;
inline bool MsgReachableTestReq::has_collect_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReachableTestReq::set_has_collect_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReachableTestReq::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReachableTestReq::clear_collect_time() {
  collect_time_ = GOOGLE_ULONGLONG(0);
  clear_has_collect_time();
}
inline ::google::protobuf::uint64 MsgReachableTestReq::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgReachableTestReq.collect_time)
  return collect_time_;
}
inline void MsgReachableTestReq::set_collect_time(::google::protobuf::uint64 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.MsgReachableTestReq.collect_time)
}

// -------------------------------------------------------------------

// MsgReachableTestResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgReachableTestResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReachableTestResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReachableTestResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgReachableTestResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgReachableTestResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgReachableTestResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgReachableTestResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgReachableTestResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgReachableTestResp.result)
  return result_;
}
inline void MsgReachableTestResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgReachableTestResp.result)
}

// -------------------------------------------------------------------

// PingPerf

// optional uint32 send_pack_num = 1;
inline bool PingPerf::has_send_pack_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PingPerf::set_has_send_pack_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PingPerf::clear_has_send_pack_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PingPerf::clear_send_pack_num() {
  send_pack_num_ = 0u;
  clear_has_send_pack_num();
}
inline ::google::protobuf::uint32 PingPerf::send_pack_num() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.send_pack_num)
  return send_pack_num_;
}
inline void PingPerf::set_send_pack_num(::google::protobuf::uint32 value) {
  set_has_send_pack_num();
  send_pack_num_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.send_pack_num)
}

// optional uint32 recieve_pack_num = 2;
inline bool PingPerf::has_recieve_pack_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PingPerf::set_has_recieve_pack_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PingPerf::clear_has_recieve_pack_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PingPerf::clear_recieve_pack_num() {
  recieve_pack_num_ = 0u;
  clear_has_recieve_pack_num();
}
inline ::google::protobuf::uint32 PingPerf::recieve_pack_num() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.recieve_pack_num)
  return recieve_pack_num_;
}
inline void PingPerf::set_recieve_pack_num(::google::protobuf::uint32 value) {
  set_has_recieve_pack_num();
  recieve_pack_num_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.recieve_pack_num)
}

// optional uint32 loss_pack_num = 3;
inline bool PingPerf::has_loss_pack_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PingPerf::set_has_loss_pack_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PingPerf::clear_has_loss_pack_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PingPerf::clear_loss_pack_num() {
  loss_pack_num_ = 0u;
  clear_has_loss_pack_num();
}
inline ::google::protobuf::uint32 PingPerf::loss_pack_num() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.loss_pack_num)
  return loss_pack_num_;
}
inline void PingPerf::set_loss_pack_num(::google::protobuf::uint32 value) {
  set_has_loss_pack_num();
  loss_pack_num_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.loss_pack_num)
}

// optional float max_cost_time = 4;
inline bool PingPerf::has_max_cost_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PingPerf::set_has_max_cost_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PingPerf::clear_has_max_cost_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PingPerf::clear_max_cost_time() {
  max_cost_time_ = 0;
  clear_has_max_cost_time();
}
inline float PingPerf::max_cost_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.max_cost_time)
  return max_cost_time_;
}
inline void PingPerf::set_max_cost_time(float value) {
  set_has_max_cost_time();
  max_cost_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.max_cost_time)
}

// optional float min_cost_time = 5;
inline bool PingPerf::has_min_cost_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PingPerf::set_has_min_cost_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PingPerf::clear_has_min_cost_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PingPerf::clear_min_cost_time() {
  min_cost_time_ = 0;
  clear_has_min_cost_time();
}
inline float PingPerf::min_cost_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.min_cost_time)
  return min_cost_time_;
}
inline void PingPerf::set_min_cost_time(float value) {
  set_has_min_cost_time();
  min_cost_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.min_cost_time)
}

// optional float average_cost_time = 6;
inline bool PingPerf::has_average_cost_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PingPerf::set_has_average_cost_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PingPerf::clear_has_average_cost_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PingPerf::clear_average_cost_time() {
  average_cost_time_ = 0;
  clear_has_average_cost_time();
}
inline float PingPerf::average_cost_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.PingPerf.average_cost_time)
  return average_cost_time_;
}
inline void PingPerf::set_average_cost_time(float value) {
  set_has_average_cost_time();
  average_cost_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.PingPerf.average_cost_time)
}

// -------------------------------------------------------------------

// ReachableTestResult

// optional uint32 res_id = 1;
inline bool ReachableTestResult::has_res_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReachableTestResult::set_has_res_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReachableTestResult::clear_has_res_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReachableTestResult::clear_res_id() {
  res_id_ = 0u;
  clear_has_res_id();
}
inline ::google::protobuf::uint32 ReachableTestResult::res_id() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.res_id)
  return res_id_;
}
inline void ReachableTestResult::set_res_id(::google::protobuf::uint32 value) {
  set_has_res_id();
  res_id_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.res_id)
}

// optional string ip = 2;
inline bool ReachableTestResult::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReachableTestResult::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReachableTestResult::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReachableTestResult::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& ReachableTestResult::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.ip)
  return ip_.GetNoArena();
}
inline void ReachableTestResult::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.ip)
}
#if LANG_CXX11
inline void ReachableTestResult::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ReachableTestResult.ip)
}
#endif
inline void ReachableTestResult::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ReachableTestResult.ip)
}
inline void ReachableTestResult::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ReachableTestResult.ip)
}
inline ::std::string* ReachableTestResult::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ReachableTestResult.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReachableTestResult::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.ReachableTestResult.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReachableTestResult::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ReachableTestResult.ip)
}

// optional .mpfmessage.TestResult ping_result = 3;
inline bool ReachableTestResult::has_ping_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReachableTestResult::set_has_ping_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReachableTestResult::clear_has_ping_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReachableTestResult::clear_ping_result() {
  ping_result_ = 1;
  clear_has_ping_result();
}
inline ::mpfmessage::TestResult ReachableTestResult::ping_result() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.ping_result)
  return static_cast< ::mpfmessage::TestResult >(ping_result_);
}
inline void ReachableTestResult::set_ping_result(::mpfmessage::TestResult value) {
  assert(::mpfmessage::TestResult_IsValid(value));
  set_has_ping_result();
  ping_result_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.ping_result)
}

// optional .mpfmessage.TestResult snmp_result = 4;
inline bool ReachableTestResult::has_snmp_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReachableTestResult::set_has_snmp_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReachableTestResult::clear_has_snmp_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReachableTestResult::clear_snmp_result() {
  snmp_result_ = 1;
  clear_has_snmp_result();
}
inline ::mpfmessage::TestResult ReachableTestResult::snmp_result() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.snmp_result)
  return static_cast< ::mpfmessage::TestResult >(snmp_result_);
}
inline void ReachableTestResult::set_snmp_result(::mpfmessage::TestResult value) {
  assert(::mpfmessage::TestResult_IsValid(value));
  set_has_snmp_result();
  snmp_result_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.snmp_result)
}

// optional .mpfmessage.TestResult ssh_result = 5;
inline bool ReachableTestResult::has_ssh_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReachableTestResult::set_has_ssh_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReachableTestResult::clear_has_ssh_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReachableTestResult::clear_ssh_result() {
  ssh_result_ = 1;
  clear_has_ssh_result();
}
inline ::mpfmessage::TestResult ReachableTestResult::ssh_result() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.ssh_result)
  return static_cast< ::mpfmessage::TestResult >(ssh_result_);
}
inline void ReachableTestResult::set_ssh_result(::mpfmessage::TestResult value) {
  assert(::mpfmessage::TestResult_IsValid(value));
  set_has_ssh_result();
  ssh_result_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.ssh_result)
}

// optional .mpfmessage.TestResult telnet_result = 6;
inline bool ReachableTestResult::has_telnet_result() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReachableTestResult::set_has_telnet_result() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReachableTestResult::clear_has_telnet_result() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReachableTestResult::clear_telnet_result() {
  telnet_result_ = 1;
  clear_has_telnet_result();
}
inline ::mpfmessage::TestResult ReachableTestResult::telnet_result() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.telnet_result)
  return static_cast< ::mpfmessage::TestResult >(telnet_result_);
}
inline void ReachableTestResult::set_telnet_result(::mpfmessage::TestResult value) {
  assert(::mpfmessage::TestResult_IsValid(value));
  set_has_telnet_result();
  telnet_result_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.telnet_result)
}

// optional string detail = 7;
inline bool ReachableTestResult::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReachableTestResult::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReachableTestResult::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReachableTestResult::clear_detail() {
  detail_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_detail();
}
inline const ::std::string& ReachableTestResult::detail() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.detail)
  return detail_.GetNoArena();
}
inline void ReachableTestResult::set_detail(const ::std::string& value) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.detail)
}
#if LANG_CXX11
inline void ReachableTestResult::set_detail(::std::string&& value) {
  set_has_detail();
  detail_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.ReachableTestResult.detail)
}
#endif
inline void ReachableTestResult::set_detail(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.ReachableTestResult.detail)
}
inline void ReachableTestResult::set_detail(const char* value, size_t size) {
  set_has_detail();
  detail_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.ReachableTestResult.detail)
}
inline ::std::string* ReachableTestResult::mutable_detail() {
  set_has_detail();
  // @@protoc_insertion_point(field_mutable:mpfmessage.ReachableTestResult.detail)
  return detail_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReachableTestResult::release_detail() {
  // @@protoc_insertion_point(field_release:mpfmessage.ReachableTestResult.detail)
  clear_has_detail();
  return detail_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReachableTestResult::set_allocated_detail(::std::string* detail) {
  if (detail != NULL) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
  detail_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), detail);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ReachableTestResult.detail)
}

// optional .mpfmessage.PingPerf ping_perf = 8;
inline bool ReachableTestResult::has_ping_perf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReachableTestResult::set_has_ping_perf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReachableTestResult::clear_has_ping_perf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReachableTestResult::clear_ping_perf() {
  if (ping_perf_ != NULL) ping_perf_->Clear();
  clear_has_ping_perf();
}
inline const ::mpfmessage::PingPerf& ReachableTestResult::ping_perf() const {
  const ::mpfmessage::PingPerf* p = ping_perf_;
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.ping_perf)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::PingPerf*>(
      &::mpfmessage::_PingPerf_default_instance_);
}
inline ::mpfmessage::PingPerf* ReachableTestResult::release_ping_perf() {
  // @@protoc_insertion_point(field_release:mpfmessage.ReachableTestResult.ping_perf)
  clear_has_ping_perf();
  ::mpfmessage::PingPerf* temp = ping_perf_;
  ping_perf_ = NULL;
  return temp;
}
inline ::mpfmessage::PingPerf* ReachableTestResult::mutable_ping_perf() {
  set_has_ping_perf();
  if (ping_perf_ == NULL) {
    ping_perf_ = new ::mpfmessage::PingPerf;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.ReachableTestResult.ping_perf)
  return ping_perf_;
}
inline void ReachableTestResult::set_allocated_ping_perf(::mpfmessage::PingPerf* ping_perf) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ping_perf_;
  }
  if (ping_perf) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ping_perf = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ping_perf, submessage_arena);
    }
    set_has_ping_perf();
  } else {
    clear_has_ping_perf();
  }
  ping_perf_ = ping_perf;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.ReachableTestResult.ping_perf)
}

// optional uint64 collect_time = 9;
inline bool ReachableTestResult::has_collect_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReachableTestResult::set_has_collect_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReachableTestResult::clear_has_collect_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReachableTestResult::clear_collect_time() {
  collect_time_ = GOOGLE_ULONGLONG(0);
  clear_has_collect_time();
}
inline ::google::protobuf::uint64 ReachableTestResult::collect_time() const {
  // @@protoc_insertion_point(field_get:mpfmessage.ReachableTestResult.collect_time)
  return collect_time_;
}
inline void ReachableTestResult::set_collect_time(::google::protobuf::uint64 value) {
  set_has_collect_time();
  collect_time_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.ReachableTestResult.collect_time)
}

// -------------------------------------------------------------------

// MsgReachableTestNotify

// repeated .mpfmessage.ReachableTestResult result_data = 1;
inline int MsgReachableTestNotify::result_data_size() const {
  return result_data_.size();
}
inline void MsgReachableTestNotify::clear_result_data() {
  result_data_.Clear();
}
inline const ::mpfmessage::ReachableTestResult& MsgReachableTestNotify::result_data(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgReachableTestNotify.result_data)
  return result_data_.Get(index);
}
inline ::mpfmessage::ReachableTestResult* MsgReachableTestNotify::mutable_result_data(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgReachableTestNotify.result_data)
  return result_data_.Mutable(index);
}
inline ::mpfmessage::ReachableTestResult* MsgReachableTestNotify::add_result_data() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgReachableTestNotify.result_data)
  return result_data_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::ReachableTestResult >*
MsgReachableTestNotify::mutable_result_data() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgReachableTestNotify.result_data)
  return &result_data_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::ReachableTestResult >&
MsgReachableTestNotify::result_data() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgReachableTestNotify.result_data)
  return result_data_;
}

// -------------------------------------------------------------------

// IpGroup

// optional string start_ip = 1;
inline bool IpGroup::has_start_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IpGroup::set_has_start_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IpGroup::clear_has_start_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IpGroup::clear_start_ip() {
  start_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_start_ip();
}
inline const ::std::string& IpGroup::start_ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IpGroup.start_ip)
  return start_ip_.GetNoArena();
}
inline void IpGroup::set_start_ip(const ::std::string& value) {
  set_has_start_ip();
  start_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IpGroup.start_ip)
}
#if LANG_CXX11
inline void IpGroup::set_start_ip(::std::string&& value) {
  set_has_start_ip();
  start_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IpGroup.start_ip)
}
#endif
inline void IpGroup::set_start_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_start_ip();
  start_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IpGroup.start_ip)
}
inline void IpGroup::set_start_ip(const char* value, size_t size) {
  set_has_start_ip();
  start_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IpGroup.start_ip)
}
inline ::std::string* IpGroup::mutable_start_ip() {
  set_has_start_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IpGroup.start_ip)
  return start_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IpGroup::release_start_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.IpGroup.start_ip)
  clear_has_start_ip();
  return start_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpGroup::set_allocated_start_ip(::std::string* start_ip) {
  if (start_ip != NULL) {
    set_has_start_ip();
  } else {
    clear_has_start_ip();
  }
  start_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), start_ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IpGroup.start_ip)
}

// optional string end_ip = 2;
inline bool IpGroup::has_end_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IpGroup::set_has_end_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IpGroup::clear_has_end_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IpGroup::clear_end_ip() {
  end_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_end_ip();
}
inline const ::std::string& IpGroup::end_ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.IpGroup.end_ip)
  return end_ip_.GetNoArena();
}
inline void IpGroup::set_end_ip(const ::std::string& value) {
  set_has_end_ip();
  end_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.IpGroup.end_ip)
}
#if LANG_CXX11
inline void IpGroup::set_end_ip(::std::string&& value) {
  set_has_end_ip();
  end_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.IpGroup.end_ip)
}
#endif
inline void IpGroup::set_end_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_end_ip();
  end_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.IpGroup.end_ip)
}
inline void IpGroup::set_end_ip(const char* value, size_t size) {
  set_has_end_ip();
  end_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.IpGroup.end_ip)
}
inline ::std::string* IpGroup::mutable_end_ip() {
  set_has_end_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.IpGroup.end_ip)
  return end_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* IpGroup::release_end_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.IpGroup.end_ip)
  clear_has_end_ip();
  return end_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void IpGroup::set_allocated_end_ip(::std::string* end_ip) {
  if (end_ip != NULL) {
    set_has_end_ip();
  } else {
    clear_has_end_ip();
  }
  end_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), end_ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.IpGroup.end_ip)
}

// -------------------------------------------------------------------

// MsgTopoDiscoveryReq

// repeated .mpfmessage.SnmpInfo snmp = 1;
inline int MsgTopoDiscoveryReq::snmp_size() const {
  return snmp_.size();
}
inline void MsgTopoDiscoveryReq::clear_snmp() {
  snmp_.Clear();
}
inline const ::mpfmessage::SnmpInfo& MsgTopoDiscoveryReq::snmp(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoDiscoveryReq.snmp)
  return snmp_.Get(index);
}
inline ::mpfmessage::SnmpInfo* MsgTopoDiscoveryReq::mutable_snmp(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoDiscoveryReq.snmp)
  return snmp_.Mutable(index);
}
inline ::mpfmessage::SnmpInfo* MsgTopoDiscoveryReq::add_snmp() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgTopoDiscoveryReq.snmp)
  return snmp_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::SnmpInfo >*
MsgTopoDiscoveryReq::mutable_snmp() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgTopoDiscoveryReq.snmp)
  return &snmp_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::SnmpInfo >&
MsgTopoDiscoveryReq::snmp() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgTopoDiscoveryReq.snmp)
  return snmp_;
}

// repeated .mpfmessage.IpGroup ip_group = 2;
inline int MsgTopoDiscoveryReq::ip_group_size() const {
  return ip_group_.size();
}
inline void MsgTopoDiscoveryReq::clear_ip_group() {
  ip_group_.Clear();
}
inline const ::mpfmessage::IpGroup& MsgTopoDiscoveryReq::ip_group(int index) const {
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoDiscoveryReq.ip_group)
  return ip_group_.Get(index);
}
inline ::mpfmessage::IpGroup* MsgTopoDiscoveryReq::mutable_ip_group(int index) {
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoDiscoveryReq.ip_group)
  return ip_group_.Mutable(index);
}
inline ::mpfmessage::IpGroup* MsgTopoDiscoveryReq::add_ip_group() {
  // @@protoc_insertion_point(field_add:mpfmessage.MsgTopoDiscoveryReq.ip_group)
  return ip_group_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::mpfmessage::IpGroup >*
MsgTopoDiscoveryReq::mutable_ip_group() {
  // @@protoc_insertion_point(field_mutable_list:mpfmessage.MsgTopoDiscoveryReq.ip_group)
  return &ip_group_;
}
inline const ::google::protobuf::RepeatedPtrField< ::mpfmessage::IpGroup >&
MsgTopoDiscoveryReq::ip_group() const {
  // @@protoc_insertion_point(field_list:mpfmessage.MsgTopoDiscoveryReq.ip_group)
  return ip_group_;
}

// -------------------------------------------------------------------

// MsgTopoFindResp

// optional .mpfmessage.MsgCommonData result = 1;
inline bool MsgTopoFindResp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgTopoFindResp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgTopoFindResp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::mpfmessage::MsgCommonData& MsgTopoFindResp::result() const {
  const ::mpfmessage::MsgCommonData* p = result_;
  // @@protoc_insertion_point(field_get:mpfmessage.MsgTopoFindResp.result)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::MsgCommonData*>(
      &::mpfmessage::_MsgCommonData_default_instance_);
}
inline ::mpfmessage::MsgCommonData* MsgTopoFindResp::release_result() {
  // @@protoc_insertion_point(field_release:mpfmessage.MsgTopoFindResp.result)
  clear_has_result();
  ::mpfmessage::MsgCommonData* temp = result_;
  result_ = NULL;
  return temp;
}
inline ::mpfmessage::MsgCommonData* MsgTopoFindResp::mutable_result() {
  set_has_result();
  if (result_ == NULL) {
    result_ = new ::mpfmessage::MsgCommonData;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.MsgTopoFindResp.result)
  return result_;
}
inline void MsgTopoFindResp::set_allocated_result(::mpfmessage::MsgCommonData* result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(result_);
  }
  if (result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    set_has_result();
  } else {
    clear_has_result();
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.MsgTopoFindResp.result)
}

// -------------------------------------------------------------------

// TopoNodeInfo

// optional string ip = 1;
inline bool TopoNodeInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopoNodeInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopoNodeInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopoNodeInfo::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
inline const ::std::string& TopoNodeInfo::ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoNodeInfo.ip)
  return ip_.GetNoArena();
}
inline void TopoNodeInfo::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoNodeInfo.ip)
}
#if LANG_CXX11
inline void TopoNodeInfo::set_ip(::std::string&& value) {
  set_has_ip();
  ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoNodeInfo.ip)
}
#endif
inline void TopoNodeInfo::set_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoNodeInfo.ip)
}
inline void TopoNodeInfo::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoNodeInfo.ip)
}
inline ::std::string* TopoNodeInfo::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoNodeInfo.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoNodeInfo::release_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoNodeInfo.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoNodeInfo::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoNodeInfo.ip)
}

// optional string name = 2;
inline bool TopoNodeInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopoNodeInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopoNodeInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopoNodeInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& TopoNodeInfo::name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoNodeInfo.name)
  return name_.GetNoArena();
}
inline void TopoNodeInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoNodeInfo.name)
}
#if LANG_CXX11
inline void TopoNodeInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoNodeInfo.name)
}
#endif
inline void TopoNodeInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoNodeInfo.name)
}
inline void TopoNodeInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoNodeInfo.name)
}
inline ::std::string* TopoNodeInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoNodeInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoNodeInfo::release_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoNodeInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoNodeInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoNodeInfo.name)
}

// optional uint32 type = 3;
inline bool TopoNodeInfo::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopoNodeInfo::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopoNodeInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopoNodeInfo::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TopoNodeInfo::type() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoNodeInfo.type)
  return type_;
}
inline void TopoNodeInfo::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.TopoNodeInfo.type)
}

// optional uint32 run_status = 4;
inline bool TopoNodeInfo::has_run_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopoNodeInfo::set_has_run_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopoNodeInfo::clear_has_run_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopoNodeInfo::clear_run_status() {
  run_status_ = 0u;
  clear_has_run_status();
}
inline ::google::protobuf::uint32 TopoNodeInfo::run_status() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoNodeInfo.run_status)
  return run_status_;
}
inline void TopoNodeInfo::set_run_status(::google::protobuf::uint32 value) {
  set_has_run_status();
  run_status_ = value;
  // @@protoc_insertion_point(field_set:mpfmessage.TopoNodeInfo.run_status)
}

// optional .mpfmessage.SnmpInfo snmp_info = 5;
inline bool TopoNodeInfo::has_snmp_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopoNodeInfo::set_has_snmp_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopoNodeInfo::clear_has_snmp_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopoNodeInfo::clear_snmp_info() {
  if (snmp_info_ != NULL) snmp_info_->Clear();
  clear_has_snmp_info();
}
inline const ::mpfmessage::SnmpInfo& TopoNodeInfo::snmp_info() const {
  const ::mpfmessage::SnmpInfo* p = snmp_info_;
  // @@protoc_insertion_point(field_get:mpfmessage.TopoNodeInfo.snmp_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mpfmessage::SnmpInfo*>(
      &::mpfmessage::_SnmpInfo_default_instance_);
}
inline ::mpfmessage::SnmpInfo* TopoNodeInfo::release_snmp_info() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoNodeInfo.snmp_info)
  clear_has_snmp_info();
  ::mpfmessage::SnmpInfo* temp = snmp_info_;
  snmp_info_ = NULL;
  return temp;
}
inline ::mpfmessage::SnmpInfo* TopoNodeInfo::mutable_snmp_info() {
  set_has_snmp_info();
  if (snmp_info_ == NULL) {
    snmp_info_ = new ::mpfmessage::SnmpInfo;
  }
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoNodeInfo.snmp_info)
  return snmp_info_;
}
inline void TopoNodeInfo::set_allocated_snmp_info(::mpfmessage::SnmpInfo* snmp_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete snmp_info_;
  }
  if (snmp_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      snmp_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, snmp_info, submessage_arena);
    }
    set_has_snmp_info();
  } else {
    clear_has_snmp_info();
  }
  snmp_info_ = snmp_info;
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoNodeInfo.snmp_info)
}

// -------------------------------------------------------------------

// TopoLinkInfo

// optional string src_ip = 1;
inline bool TopoLinkInfo::has_src_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopoLinkInfo::set_has_src_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopoLinkInfo::clear_has_src_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopoLinkInfo::clear_src_ip() {
  src_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_ip();
}
inline const ::std::string& TopoLinkInfo::src_ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.src_ip)
  return src_ip_.GetNoArena();
}
inline void TopoLinkInfo::set_src_ip(const ::std::string& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.src_ip)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_src_ip(::std::string&& value) {
  set_has_src_ip();
  src_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.src_ip)
}
#endif
inline void TopoLinkInfo::set_src_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.src_ip)
}
inline void TopoLinkInfo::set_src_ip(const char* value, size_t size) {
  set_has_src_ip();
  src_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.src_ip)
}
inline ::std::string* TopoLinkInfo::mutable_src_ip() {
  set_has_src_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.src_ip)
  return src_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_src_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.src_ip)
  clear_has_src_ip();
  return src_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_src_ip(::std::string* src_ip) {
  if (src_ip != NULL) {
    set_has_src_ip();
  } else {
    clear_has_src_ip();
  }
  src_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.src_ip)
}

// optional string dest_ip = 2;
inline bool TopoLinkInfo::has_dest_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopoLinkInfo::set_has_dest_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopoLinkInfo::clear_has_dest_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopoLinkInfo::clear_dest_ip() {
  dest_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_ip();
}
inline const ::std::string& TopoLinkInfo::dest_ip() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.dest_ip)
  return dest_ip_.GetNoArena();
}
inline void TopoLinkInfo::set_dest_ip(const ::std::string& value) {
  set_has_dest_ip();
  dest_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.dest_ip)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_dest_ip(::std::string&& value) {
  set_has_dest_ip();
  dest_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.dest_ip)
}
#endif
inline void TopoLinkInfo::set_dest_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_ip();
  dest_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.dest_ip)
}
inline void TopoLinkInfo::set_dest_ip(const char* value, size_t size) {
  set_has_dest_ip();
  dest_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.dest_ip)
}
inline ::std::string* TopoLinkInfo::mutable_dest_ip() {
  set_has_dest_ip();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.dest_ip)
  return dest_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_dest_ip() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.dest_ip)
  clear_has_dest_ip();
  return dest_ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_dest_ip(::std::string* dest_ip) {
  if (dest_ip != NULL) {
    set_has_dest_ip();
  } else {
    clear_has_dest_ip();
  }
  dest_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_ip);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.dest_ip)
}

// optional string src_name = 3;
inline bool TopoLinkInfo::has_src_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopoLinkInfo::set_has_src_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopoLinkInfo::clear_has_src_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopoLinkInfo::clear_src_name() {
  src_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_name();
}
inline const ::std::string& TopoLinkInfo::src_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.src_name)
  return src_name_.GetNoArena();
}
inline void TopoLinkInfo::set_src_name(const ::std::string& value) {
  set_has_src_name();
  src_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.src_name)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_src_name(::std::string&& value) {
  set_has_src_name();
  src_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.src_name)
}
#endif
inline void TopoLinkInfo::set_src_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_name();
  src_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.src_name)
}
inline void TopoLinkInfo::set_src_name(const char* value, size_t size) {
  set_has_src_name();
  src_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.src_name)
}
inline ::std::string* TopoLinkInfo::mutable_src_name() {
  set_has_src_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.src_name)
  return src_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_src_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.src_name)
  clear_has_src_name();
  return src_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_src_name(::std::string* src_name) {
  if (src_name != NULL) {
    set_has_src_name();
  } else {
    clear_has_src_name();
  }
  src_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.src_name)
}

// optional string dest_name = 4;
inline bool TopoLinkInfo::has_dest_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopoLinkInfo::set_has_dest_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopoLinkInfo::clear_has_dest_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopoLinkInfo::clear_dest_name() {
  dest_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_name();
}
inline const ::std::string& TopoLinkInfo::dest_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.dest_name)
  return dest_name_.GetNoArena();
}
inline void TopoLinkInfo::set_dest_name(const ::std::string& value) {
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.dest_name)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_dest_name(::std::string&& value) {
  set_has_dest_name();
  dest_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.dest_name)
}
#endif
inline void TopoLinkInfo::set_dest_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.dest_name)
}
inline void TopoLinkInfo::set_dest_name(const char* value, size_t size) {
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.dest_name)
}
inline ::std::string* TopoLinkInfo::mutable_dest_name() {
  set_has_dest_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.dest_name)
  return dest_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_dest_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.dest_name)
  clear_has_dest_name();
  return dest_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_dest_name(::std::string* dest_name) {
  if (dest_name != NULL) {
    set_has_dest_name();
  } else {
    clear_has_dest_name();
  }
  dest_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.dest_name)
}

// optional string src_if_name = 5;
inline bool TopoLinkInfo::has_src_if_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopoLinkInfo::set_has_src_if_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopoLinkInfo::clear_has_src_if_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopoLinkInfo::clear_src_if_name() {
  src_if_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_src_if_name();
}
inline const ::std::string& TopoLinkInfo::src_if_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.src_if_name)
  return src_if_name_.GetNoArena();
}
inline void TopoLinkInfo::set_src_if_name(const ::std::string& value) {
  set_has_src_if_name();
  src_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.src_if_name)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_src_if_name(::std::string&& value) {
  set_has_src_if_name();
  src_if_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.src_if_name)
}
#endif
inline void TopoLinkInfo::set_src_if_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_src_if_name();
  src_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.src_if_name)
}
inline void TopoLinkInfo::set_src_if_name(const char* value, size_t size) {
  set_has_src_if_name();
  src_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.src_if_name)
}
inline ::std::string* TopoLinkInfo::mutable_src_if_name() {
  set_has_src_if_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.src_if_name)
  return src_if_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_src_if_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.src_if_name)
  clear_has_src_if_name();
  return src_if_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_src_if_name(::std::string* src_if_name) {
  if (src_if_name != NULL) {
    set_has_src_if_name();
  } else {
    clear_has_src_if_name();
  }
  src_if_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_if_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.src_if_name)
}

// optional string dest_if_name = 6;
inline bool TopoLinkInfo::has_dest_if_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopoLinkInfo::set_has_dest_if_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopoLinkInfo::clear_has_dest_if_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopoLinkInfo::clear_dest_if_name() {
  dest_if_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_if_name();
}
inline const ::std::string& TopoLinkInfo::dest_if_name() const {
  // @@protoc_insertion_point(field_get:mpfmessage.TopoLinkInfo.dest_if_name)
  return dest_if_name_.GetNoArena();
}
inline void TopoLinkInfo::set_dest_if_name(const ::std::string& value) {
  set_has_dest_if_name();
  dest_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mpfmessage.TopoLinkInfo.dest_if_name)
}
#if LANG_CXX11
inline void TopoLinkInfo::set_dest_if_name(::std::string&& value) {
  set_has_dest_if_name();
  dest_if_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mpfmessage.TopoLinkInfo.dest_if_name)
}
#endif
inline void TopoLinkInfo::set_dest_if_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_if_name();
  dest_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mpfmessage.TopoLinkInfo.dest_if_name)
}
inline void TopoLinkInfo::set_dest_if_name(const char* value, size_t size) {
  set_has_dest_if_name();
  dest_if_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mpfmessage.TopoLinkInfo.dest_if_name)
}
inline ::std::string* TopoLinkInfo::mutable_dest_if_name() {
  set_has_dest_if_name();
  // @@protoc_insertion_point(field_mutable:mpfmessage.TopoLinkInfo.dest_if_name)
  return dest_if_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TopoLinkInfo::release_dest_if_name() {
  // @@protoc_insertion_point(field_release:mpfmessage.TopoLinkInfo.dest_if_name)
  clear_has_dest_if_name();
  return dest_if_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TopoLinkInfo::set_allocated_dest_if_name(::std::string* dest_if_name) {
  if (dest_if_name != NULL) {
    set_has_dest_if_name();
  } else {
    clear_has_dest_if_name();
  }
  dest_if_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_if_name);
  // @@protoc_insertion_point(field_set_allocated:mpfmessage.TopoLinkInfo.dest_if_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mpfmessage

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mpfmessage::ResType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::ResType>() {
  return ::mpfmessage::ResType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::SnmpVersion> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::SnmpVersion>() {
  return ::mpfmessage::SnmpVersion_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::AuthMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::AuthMethod>() {
  return ::mpfmessage::AuthMethod_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::EncryptMethod> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::EncryptMethod>() {
  return ::mpfmessage::EncryptMethod_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::DatabaseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::DatabaseType>() {
  return ::mpfmessage::DatabaseType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::OSTYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::OSTYPE>() {
  return ::mpfmessage::OSTYPE_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::MidwareType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::MidwareType>() {
  return ::mpfmessage::MidwareType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::DISK_ACCESS> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::DISK_ACCESS>() {
  return ::mpfmessage::DISK_ACCESS_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::DISK_MEDIA_TYPE> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::DISK_MEDIA_TYPE>() {
  return ::mpfmessage::DISK_MEDIA_TYPE_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::Status>() {
  return ::mpfmessage::Status_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::IfType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::IfType>() {
  return ::mpfmessage::IfType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::SoftwareType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::SoftwareType>() {
  return ::mpfmessage::SoftwareType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::AvailableStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::AvailableStatus>() {
  return ::mpfmessage::AvailableStatus_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::ConnectivityTestType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::ConnectivityTestType>() {
  return ::mpfmessage::ConnectivityTestType_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::ConnectivityTestResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::ConnectivityTestResult>() {
  return ::mpfmessage::ConnectivityTestResult_descriptor();
}
template <> struct is_proto_enum< ::mpfmessage::TestResult> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mpfmessage::TestResult>() {
  return ::mpfmessage::TestResult_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_devcollector_5fmsg_2eproto__INCLUDED
